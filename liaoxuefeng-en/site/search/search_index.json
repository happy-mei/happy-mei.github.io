{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Liaoxuefeng Java Tutorial \u7ffb\u8bd1\u81ea\u5ed6\u96ea\u5cf0Java\u6559\u7a0b","text":"<p>Start from Introduction</p> <p>Return to Mei's blog</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>This website is an unofficial translation of the original content from \u5ed6\u96ea\u5cf0\u7684Java\u6559\u7a0b, created solely for educational and non-commercial purposes.</p> <p>All intellectual property rights of the original content belong to Liao Xuefeng. If you are the original author or rights holder and would like this content removed or modified, please contact me, and I will respond promptly.</p> <p>This project is not affiliated with, endorsed by, or sponsored by Liao Xuefeng.</p>"},{"location":"#_1","title":"\u514d\u8d23\u58f0\u660e","text":"<p>\u672c\u7f51\u7ad9\u662f\u5bf9\u5ed6\u96ea\u5cf0\u7684Java\u6559\u7a0b\u5185\u5bb9\u7684\u975e\u5b98\u65b9\u7ffb\u8bd1\uff0c\u4ec5\u7528\u4e8e\u5b66\u4e60\u548c\u6559\u5b66\u76ee\u7684\uff0c\u4e0d\u7528\u4e8e\u4efb\u4f55\u5546\u4e1a\u7528\u9014\u3002</p> <p>\u539f\u59cb\u5185\u5bb9\u7684\u77e5\u8bc6\u4ea7\u6743\u5f52\u5ed6\u96ea\u5cf0\u6240\u6709\u3002 \u5982\u679c\u60a8\u662f\u539f\u4f5c\u8005\u6216\u6743\u5229\u4eba\uff0c\u5e76\u5e0c\u671b\u672c\u5185\u5bb9\u88ab\u5220\u9664\u6216\u4fee\u6539\uff0c\u8bf7\u4e0e\u6211\u8054\u7cfb\uff0c\u6211\u5c06\u7acb\u5373\u5904\u7406\u3002</p> <p>\u672c\u9879\u76ee\u4e0e\u5ed6\u96ea\u5cf0\u65e0\u4efb\u4f55\u5173\u8054\u3001\u6388\u6743\u6216\u5408\u4f5c\u5173\u7cfb\u3002</p>"},{"location":"10-introduction/","title":"1 Introduction","text":""},{"location":"10-introduction/#introduction","title":"Introduction","text":"<p>This is a zero-based Java tutorial specifically for white people.</p> <p>Why learn Java?</p> <p>Because Java is the world's No. 1 programming language, Java engineers are also the most in-demand software engineers in the market, choose Java, is to choose a high salary.</p> <p></p>"},{"location":"10-introduction/#why-is-java-the-most-widely-used","title":"Why is Java the most widely used?","text":"<p>From the Internet to enterprise platforms, Java is the most widely used programming language, and here's why:</p> <ul> <li>Java is a cross-platform language based on the JVM virtual machine; write once, run everywhere;</li> <li>Java programs are easy to write and have built-in garbage collection so you don't have to think about memory management;</li> <li>The Java Virtual Machine has industrial-grade stability and highly optimized performance that has been tested over a long period of time;</li> <li>Java has the broadest open source community support, with a wide range of high-quality components readily available.</li> </ul> <p>The Java language perennially dominates the three major markets:</p> <ul> <li>Internet and enterprise applications, which is the long-term strength and market position of Java EE;</li> <li>Big Data platforms, mainly Hadoop, Spark, Flink, etc., who are developed in Java or Scala (kind of programming language running on JVM);</li> <li>Android mobile platform.</li> </ul> <p>This means that Java has the widest job market.</p>"},{"location":"10-introduction/#tutorial-features","title":"Tutorial Features","text":"<p>Although it is a zero-basic Java tutorial, but covers the core programming from basic to advanced Java, after learning, you can grow from a small white architect to realize the hard power of high-paying jobs!</p> <p>You can also practice while you learn and you can practice online!</p> <p>And, always update to the latest version of Java! The current tutorial version is:</p>"},{"location":"10-introduction/#java-22","title":"Java 22!","text":"<p>Most importantly:</p>"},{"location":"10-introduction/#free","title":"Free!","text":"<p>Don't hesitate! Start learning Java now, from beginner to architect!</p> <p></p>"},{"location":"20-quick-start/","title":"Overview","text":""},{"location":"20-quick-start/#quick-start","title":"Quick start","text":"<p>This chapter focuses on getting up to speed on the basics of Java programs, understanding and using variables and various data types, and introducing basic program flow control statements.</p> <p></p> <p>This chapter allows you to write basic Java programs.</p>"},{"location":"20-quick-start/10-history/","title":"Java History","text":""},{"location":"20-quick-start/10-history/#java-history","title":"Java history","text":"<p>Java was first developed by SUN's (which has been acquired by Oracle) James Gosling (High Commander, known as the father of Java) in the early 1990s as a programming language, initially named Oak, targeted at Embedded applications for small home appliance devices, resulting in little market response. Who expected the rise of the Internet, so that Oak revitalized, so SUN revamped Oak, officially released in 1995 under the name of Java, the reason is that Oak has been registered, so SUN registered the trademark Java. With the rapid development of the Internet, Java gradually became the most important network programming language.</p> <p>Java lies between compiled languages and interpreted languages. Compiled languages, such as C and C++, have code that is compiled directly into machine code for execution, but different platforms (x86, ARM, etc.) have different instruction sets for their CPUs, so it is necessary to compile the corresponding machine code for each platform. Interpreted languages such as Python and Ruby do not have this problem, and can be loaded directly by the interpreter into the source code and then run, at the cost of running too inefficiently. Java is to compile the code into a \"byte code\", which is similar to the abstract CPU instructions, and then, for different platforms to write a virtual machine, the virtual machine of different platforms is responsible for loading the byte code and execution, so as to realize the \"once written, run everywhere! This realizes the effect of \"write once, run everywhere\". Of course, this is for Java developers. For the virtual machine, you need to develop for each platform separately. In order to ensure that different platforms, virtual machines developed by different companies can correctly execute Java byte code, SUN has developed a series of Java virtual machine specifications. From a practical point of view, the JVM compatibility is done very well, the lower version of the Java byte code can be completely normal run on the higher version of the JVM.</p> <p>With the development of Java, SUN gave Java another three different versions:</p> <ul> <li>Java SE: Standard Edition</li> <li>Java EE: Enterprise Edition</li> <li>Java ME: Micro Edition</li> </ul> <p>What is the relationship between these three?</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Java EE                    \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502    \u2502Java SE             \u2502 \u2502\n\u2502    \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502\n\u2502    \u2502    \u2502   Java ME   \u2502 \u2502 \u2502\n\u2502    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Simply put, Java SE is the standard edition, including the standard JVM and standard libraries, while Java EE is the enterprise edition, which is just based on Java SE plus a large number of APIs and libraries, in order to facilitate the development of Web applications, databases, messaging services, etc., Java EE applications using the virtual machine and Java SE is exactly the same.</p> <p>Java ME is different from Java SE, it is a \"thin version\" for embedded devices, Java SE's standard libraries can not be used on Java ME, Java ME's virtual machine is also a \"thin version\".</p> <p>There is no doubt that Java SE is the core of the entire Java platform, and Java EE is necessary for further learning about web applications. We are familiar with frameworks such as Spring that are part of the Java EE open source ecosystem. Unfortunately, Java ME never really caught on, instead Android development became one of the standards for mobile platforms, so learning Java ME is not recommended without special needs.</p> <p>So our recommended roadmap for learning Java is as follows:</p> <ol> <li>First of all, you need to learn Java SE, master the Java language itself, Java core development techniques and the use of Java standard libraries;</li> <li>If you continue to learn Java EE, then Spring framework, database development, distributed architecture is what you need to learn;</li> <li>if you want to learn big data development, then Hadoop, Spark, Flink, these big data platforms is what you need to learn, they are based on Java or Scala development;</li> <li>if you want to learn mobile development, then in-depth Android platform, master Android App development.</li> </ol> <p>Regardless of the choice, the core technology of Java SE is fundamental, and this tutorial is designed to make you fully proficient in Java SE and master Java EE!</p>"},{"location":"20-quick-start/10-history/#java-version","title":"Java version","text":"<p>Starting with the release of version 1.0 in 1996, the latest version of Java to date is Java 21:</p> Time Version 1996 1.0 1997 1.1 1998 1.2 2000 1.3 2002 1.4 2004 1.5 / 5.0 2005 1.6 / 6.0 2011 1.7 / 7.0 2014 1.8 / 8.0 2017/9 1.9 / 9.0 2018/3 10 2018/9 11 2019/3 12 2019/9 13 2020/3 14 2020/9 15 2021/3 16 2021/9 17 2022/3 18 2022/9 19 2023/3 20 2023/9 21 2024/3 22 2024/9 23 <p>The version of Java used in this tutorial is the latest version Java 23.</p>"},{"location":"20-quick-start/10-history/#explanation-of-terms","title":"Explanation of terms","text":"<p>Beginners learn Java, often hear the terms JDK, JRE, what are they in the end?</p> <ul> <li>JDK: Java Development Kit</li> <li>JRE: Java Runtime Environment</li> </ul> <p>Simply put, JRE is the virtual machine that runs Java bytecode. However, if there is only Java source code, to be compiled into Java byte code, you need the JDK, because the JDK in addition to the inclusion of the JRE, but also provides a compiler, debugger and other development tools.</p> <p>The relationship between the two is as follows:</p> <pre><code>\u250c\u2500    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502     \u2502     Compiler, debugger, etc.     \u2502\n  \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n JDK \u250c\u2500 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  \u2502  \u2502                                  \u2502\n  \u2502 JRE \u2502      JVM + Runtime Library       \u2502\n  \u2502  \u2502  \u2502                                  \u2502\n  \u2514\u2500 \u2514\u2500 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502Windows\u2502\u2502 Linux \u2502\u2502 macOS \u2502\u2502others \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>To learn Java development, of course, you need to install the JDK.</p> <p>What about JSR, JCP ......?</p> <ul> <li>JSR specification: Java Specification Request</li> <li>JCP Organization: Java Community Process</li> </ul> <p>In order to ensure that the normative nature of the Java language, SUN has engaged in a JSR specification, where you want to add a function to the Java platform, such as access to the database, we must first create a JSR specification to define the interface, so that the various database vendors are in accordance with the specification to write a Java driver, the developer does not have to worry about their own database code written on the MySQL can run! but can't run on PostgreSQL.</p> <p>So the JSR is a series of specifications that standardize everything from the memory model of the JVM to the web program interface. And the organization responsible for reviewing the JSRs is the JCP.</p> <p>When a JSR specification is released, in order to allow everyone to have a reference, but also released a \"reference implementation\", as well as a \"compatibility test suite\":</p> <ul> <li>RI: Reference Implementation</li> <li>TCK: Technology Compatibility Kit</li> </ul> <p>For example, someone proposed to get a Java-based message server , this proposal is very good ah , but only a proposal is not enough , you have to post the code can really run , which is the RI. if there are other people also want to develop such a message server , how to ensure that these message servers are the same interface, functionality for the developer ? So also have to provide TCK.</p> <p>Generally speaking, RI is just a \"can run\" the right code, it does not seek speed, so if you really want to choose a Java messaging server, generally no one uses RI, everyone will choose a competitive commercial or open source products.</p> <p>Reference: JSR for Java Messaging Service JMS: https://jcp.org/en/jsr/detail?id=914</p> <p>```question type=radio \u8bf7\u95eeJava\u4e4b\u7236\u662f\uff1a</p> <pre><code>James Bond\n</code></pre> <p>[x] James Gosling     James Simons ```</p>"},{"location":"20-quick-start/20-dev-env/","title":"Overview","text":""},{"location":"20-quick-start/20-dev-env/#build-the-development-environment","title":"Build the development environment","text":"<p>To start learning Java programming, we need to first set up a development environment.</p> <p>In this section we describe how to install the JDK, compile Java programs at the command line, and how to use an IDE to develop Java.</p>"},{"location":"20-quick-start/20-dev-env/10-install-jdk/","title":"Install JDK","text":""},{"location":"20-quick-start/20-dev-env/10-install-jdk/#install-jdk","title":"Install JDK","text":"<p>Because Java programs must run on top of the JVM, the first thing we do is install the JDK.</p> <p>Search for JDK 23 and make sure you download the latest stable version of the JDK from Oracle's official website:</p> <pre><code>Java SE Development Kit 23 downloads\n\nLinux macOS Windows\n              -------\n\nx64 Compressed Archive Download\nx64 Installer Download\nx64 MSI Installer Download\n</code></pre> <p>Choose the right operating system and installer, find the download link <code>Download</code> for Java SE 23, download and install it. for Windows choose <code>x64 MSI Installer</code> in preference, for Linux and macOS choose the right installer according to your computer's CPU whether it is ARM or x86.</p>"},{"location":"20-quick-start/20-dev-env/10-install-jdk/#setting-environment-variables","title":"Setting environment variables","text":"<p>After installing the JDK, you need to set a <code>JAVA_HOME</code> environment variable, which points to the JDK installation directory. Under Windows, it is the installation directory, similarly:</p> <pre><code>C:\\Program Files\\Java\\jdk-23\n</code></pre> <p>Under macOS, it's in <code>~/.bash_profile</code> or <code>~/.zprofile</code>, which it is:</p> <pre><code>export JAVA_HOME=`/usr/libexec/java_home -v 23`\n</code></pre> <p>Then, append the <code>bin</code> directory of <code>JAVA_HOME</code> to the system environment variable <code>PATH</code>. On Windows, it looks like this:</p> <pre><code>Path=%JAVA_HOME%\\bin;&lt;\u73b0\u6709\u7684\u5176\u4ed6\u8def\u5f84&gt;\n</code></pre> <p>Under macOS, it's in <code>~/.bash_profile</code> or <code>~/.zprofile</code> and looks like this:</p> <pre><code>export PATH=$JAVA_HOME/bin:$PATH\n</code></pre> <p>The reason for adding the <code>bin</code> directory of <code>JAVA_HOME</code> to the <code>PATH</code> is so that <code>java</code> can be run from any folder. Open a PowerShell window and enter the command <code>java -version</code>, if everything works you will see the following output:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Windows PowerShell                                 - \u25a1 x \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502Windows PowerShell                                       \u2502\n\u2502Copyright (C) Microsoft Corporation. All rights reserved.\u2502\n\u2502                                                         \u2502\n\u2502PS C:\\Users\\liaoxuefeng&gt; java -version                   \u2502\n\u2502java version \"23\" ...                                    \u2502\n\u2502Java(TM) SE Runtime Environment                          \u2502\n\u2502Java HotSpot(TM) 64-Bit Server VM                        \u2502\n\u2502                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>If you see a version number that is not <code>23</code>, but <code>15</code>, <code>1.8</code> or something like that, it means that there is more than one JDK on the system and the default JDK is not JDK 23, so you need to mention JDK 23 in front of <code>PATH</code>.</p> <p>If you get an error output that says: \"Unable to recognize the item \"java\" as the name of a cmdlet, function, script file or runnable program.\" :</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Windows PowerShell                                 - \u25a1 x \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502Windows PowerShell                                       \u2502\n\u2502Copyright (C) Microsoft Corporation. All rights reserved.\u2502\n\u2502                                                         \u2502\n\u2502PS C:\\Users\\liaoxuefeng&gt; java -version                   \u2502\n\u2502java : The term 'java' is not recognized as ...          \u2502\n\u2502...                                                      \u2502\n\u2502    + FullyQualifiedErrorId : CommandNotFoundException   \u2502\n\u2502                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>This is because the system cannot find the program <code>java.exe</code> for the Java Virtual Machine, and you need to check the configuration of <code>JAVA_HOME</code> and <code>PATH</code>.</p> <p>You can refer to How to set or change PATH system variables.</p>"},{"location":"20-quick-start/20-dev-env/10-install-jdk/#jdk","title":"JDK","text":"<p>A careful reader can also find many executables in the <code>bin</code> directory of <code>JAVA_HOME</code>:</p> <ul> <li>java: this executable program is actually the JVM. To run a Java program is to start the JVM and then let the JVM execute the specified compiled code;</li> <li>javac: this is the compiler for Java, it is used to compile Java source code files (ending with <code>.java</code> suffix) into Java bytecode files (ending with <code>.class</code> suffix);</li> <li>jar: used to package a set of <code>.class</code> files into a <code>.jar</code> file for easy distribution;</li> <li>javadoc: used to automatically extract comments from Java source code and generate documentation;</li> <li>jdb: Java debugger for the development phase of the runtime debugging .</li> </ul>"},{"location":"20-quick-start/20-dev-env/20-first-program/","title":"First Program","text":""},{"location":"20-quick-start/20-dev-env/20-first-program/#the-first-java-program","title":"The first Java program","text":"<p>Let's write our first Java program.</p> <p>Open a text editor and enter the following code:</p> <pre><code>public class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, world!\");\n    }\n}\n</code></pre> <p>In a Java program, you can always find a similar:</p> <pre><code>public class Hello {\n    ...\n}\n</code></pre> <p>The definition of a class is called a class, here the class name is <code>Hello</code> and is case sensitive, <code>class</code> is used to define a class, <code>public</code> indicates that the class is public, <code>public</code>, <code>class</code> are Java keywords and must be lower case, <code>Hello</code> is the name of the class and by convention the initial letter <code>H</code> is to be capitalized. And in the middle of the braces <code>{}</code> is the definition of the class.</p> <p>Notice that in the class definition, we define a method named <code>main</code>:</p> <pre><code>public static void main(String[] args) {\n        ...\n    }\n</code></pre> <p>Methods are executable blocks of code, a method has method parameters enclosed in <code>()</code> in addition to the method name <code>main</code>, here the <code>main</code> method has one parameter, the type of the parameter is <code>String[]</code>, the parameter name is <code>args</code>, <code>public</code>, <code>static</code> are used to qualify the method, here it means that it is a public static method, <code>void</code> is the return type of the method, and what's in between the braces <code>{}</code> is the code of the method.</p> <p>The code for the method ends each line with <code>;</code>, and here there is only one line of code, which is:</p> <pre><code>System.out.println(\"Hello, world!\");\n</code></pre> <p>It is used to print a string to the screen.</p> <p>Java specifies that <code>public static void main(String[] args)</code>, defined by a class, is the fixed entry method for a Java program, and therefore, Java programs always start execution from the <code>main</code> method.</p> <p>Notice that indentation of Java source code is not required, but with indentation, the formatting looks good and it is easy to see the beginning and end of the code block, indentation is usually 4 spaces or a tab.</p> <p>Finally, when we save the code as a file, the filename must be <code>Hello.java</code>, and the filename should also be case sensitive, as it should be exactly the same as the class name we defined, <code>Hello</code>.</p>"},{"location":"20-quick-start/20-dev-env/20-first-program/#how-to-run-a-java-program","title":"How to run a Java program","text":"<p>Java source code is essentially a text file, we need to first compile <code>Hello.java</code> into a bytecode file <code>Hello.class</code> using <code>javac</code> and then, execute this bytecode file using <code>java</code> command:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Hello.java    \u2502\u25c0\u2500\u2500 source code\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502 compile\n          \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Hello.class    \u2502\u25c0\u2500\u2500 byte code\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502 execute\n          \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Run on JVM    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Thus, the executable <code>javac</code> is the compiler and the executable <code>java</code> is the virtual machine.</p> <p>The first step is to execute the command <code>javac Hello.java</code> in the directory where <code>Hello.java</code> is saved:</p> <pre><code>$ javac Hello.java\n</code></pre> <p>If the source code is correct, there will be no output from the above command and a <code>Hello.class</code> file will be generated in the current directory:</p> <pre><code>$ ls\nHello.class Hello.java\n</code></pre> <p>In the second step, execute <code>Hello.class</code>, using the command <code>java Hello</code> (note that it is not <code>java Hello.class</code>):</p> <pre><code>$ java Hello\nHello, world!\n</code></pre> <p>Note: The parameter <code>Hello</code> passed to the VM is the name of the class we defined, and the VM automatically looks up the corresponding class file and executes it.</p> <p>If you execute <code>java Hello</code> you get an error:</p> <pre><code>$ java Hello\nError: Could not find or load main class Hello\nCaused by: java.lang.ClassNotFoundException: Hello\n</code></pre> <p>A <code>ClassNotFoundException</code> message appears, indicating that there is no <code>Hello.class</code> file in the current directory, please switch to the <code>Hello.class</code> directory and execute <code>java Hello</code>.</p> <p>As some of you may know, it is possible to run <code>java Hello.java</code> directly:</p> <pre><code>$ java Hello.java \nHello, world!\n</code></pre> <p>This is a new feature from Java 11, which allows you to run a single-file source code directly!</p> <p>Note that in real projects, a single Java source code that does not depend on third-party libraries is very rare, so in the vast majority of cases, we can not run a Java source code file directly, the reason is that it needs to depend on other libraries.</p>"},{"location":"20-quick-start/20-dev-env/20-first-program/#summary","title":"Summary","text":"<p>Only one class of type <code>public</code> can be defined for a Java source, and the class name and file name should be identical;</p> <p>Using <code>javac</code> you can compile <code>.java</code> source code into <code>.class</code> bytecode;</p> <p>Use <code>java</code> to run a compiled Java program with the class name as the argument.</p>"},{"location":"20-quick-start/20-dev-env/30-ide/","title":"IDE Setup","text":""},{"location":"20-quick-start/20-dev-env/30-ide/#using-the-ide","title":"Using the IDE","text":"<p>IDE stands for Integrated Development Environment.</p> <p>The advantage of using an IDE is that you can put writing code, organizing the project, compiling, running, debugging, etc. into a single environment to run, which can greatly improve the efficiency of development.</p> <p>IDE improves development efficiency mainly by the following points:</p> <ul> <li>The editor's auto-prompting can greatly improve the speed of knocking out code;</li> <li>Code can be automatically recompiled after modification and run directly;</li> <li>You can easily debug at breakpoints.</li> </ul> <p>Currently, the popular IDEs for Java development are:</p>"},{"location":"20-quick-start/20-dev-env/30-ide/#eclipse","title":"Eclipse","text":"<p>Eclipse is developed by IBM and donated to the open source community of an IDE , but also the most widely used IDE. Eclipse is characterized by its own Java development , and based on the plug-in structure , even if the support for Java development is also realized through the plug-in JDT .</p> <p>In addition to Java development , Eclipse with plug-ins can also be used as a C / C + + development environment , PHP development environment , Rust development environment and so on.</p>"},{"location":"20-quick-start/20-dev-env/30-ide/#intellij-idea","title":"IntelliJ Idea","text":"<p>IntelliJ Idea is a powerful IDE developed by JetBrains, which is divided into free version and commercial paid version. JetBrains IDE platform is also based on IDE platform + language plug-in mode, supports Python JetBrains IDE platform is also based on the IDE platform + language plug-ins model, supporting Python development environment, Ruby development environment, PHP development environment, etc., these development environments are also divided into free and paid version.</p>"},{"location":"20-quick-start/20-dev-env/30-ide/#netbeans","title":"NetBeans","text":"<p>NetBeans is the earliest open source IDE developed by SUN, which is no longer popular due to the small number of users.</p>"},{"location":"20-quick-start/20-dev-env/30-ide/#using-eclipse","title":"Using Eclipse","text":"<p>You can use any IDE for Java learning and development. Without discussing anything about the advantages and disadvantages of IDEs, this tutorial uses Eclipse as the development demo environment for a number of reasons:</p> <ul> <li>Completely free to use;</li> <li>All features fully meet Java development requirements.</li> </ul>"},{"location":"20-quick-start/20-dev-env/30-ide/#install-eclipse","title":"Install Eclipse","text":"<p>The Eclipse distribution provides pre-packaged development environments for Java, JavaEE, C++, PHP, Rust, and more. Download it from here:</p> <p>The version we need to download is Eclipse IDE for Java Developers:</p> <p></p> <p>Depending on whether the operating system is Windows, Mac or Linux, select the corresponding download link from the right.</p> <p>[!NOTICE]\u6ce8\u610f</p> <p>\u6559\u7a0b\u4ece\u5934\u5230\u5c3e\u5e76\u4e0d\u9700\u8981\u7528\u5230Enterprise Java\u7684\u529f\u80fd\uff0c\u6240\u4ee5\u4e0d\u9700\u8981\u4e0b\u8f7dEclipse IDE for Enterprise Java Developers</p>"},{"location":"20-quick-start/20-dev-env/30-ide/#setting-up-eclipse","title":"Setting up Eclipse","text":"<p>After downloading and installing, we start Eclipse and do a basic setup of the IDE environment:</p> <p>Select the menu \"Eclipse/Window\" - \"Preferences\", open the configuration dialog box:</p> <p></p> <p>We need to adjust the following setting items:</p>"},{"location":"20-quick-start/20-dev-env/30-ide/#general-editors-text-editors","title":"General &gt; Editors &gt; Text Editors","text":"<p>Hook \"Show line numbers\" so that the editor will show the line numbers;</p>"},{"location":"20-quick-start/20-dev-env/30-ide/#general-workspace","title":"General &gt; Workspace","text":"<p>Hook \"Refresh using native hooks or polling\", so that Eclipse will automatically refresh the folder changes;</p> <p>For \"Text file encoding\", if Default is not <code>UTF-8</code>, make sure to change it to \"Other: UTF-8\", all text files use <code>UTF-8</code> encoding;</p> <p>For \"New text file line delimiter\", it is recommended to use Unix, which uses <code>\\n</code> for line breaks instead of <code>\\r\\n</code> for Windows.</p> <p></p>"},{"location":"20-quick-start/20-dev-env/30-ide/#java-compiler","title":"Java &gt; Compiler","text":"<p>By setting the \"Compiler compliance level\" to <code>20</code>, all code in this tutorial uses Java 20 syntax and compiles to Java 20.</p> <p>Remove \"Use default compliance settings\" and hook \"Enable preview features for Java 20\" so that we can use the preview features of Java 20. 20 preview features.</p> <p>[!NOTICE]\u6ce8\u610f</p> <p>\u5982\u679cCompiler compliance level\u6ca1\u670922\u8fd9\u4e2a\u9009\u9879\uff0c\u8bf7\u66f4\u65b0\u5230\u6700\u65b0\u7248Eclipse\u3002\u5982\u679c\u66f4\u65b0\u540e\u8fd8\u662f\u6ca1\u670922\uff0c\u6253\u5f00Help - Eclipse Marketplace\uff0c\u641c\u7d22Java 22 Support\u5b89\u88c5\u540e\u91cd\u542f\u5373\u53ef\u3002</p>"},{"location":"20-quick-start/20-dev-env/30-ide/#java-installed-jres","title":"Java &gt; Installed JREs","text":"<p>You should see Java SE 20 in the Installed JREs, and if there are other JREs, you can remove them to ensure that Java SE 20 is the default JRE.</p>"},{"location":"20-quick-start/20-dev-env/30-ide/#eclipse-ide-structure","title":"Eclipse IDE structure","text":"<p>When you open Eclipse, the entire IDE consists of several areas:</p> <p></p> <ul> <li>The editable text area in the center (see 1) is the editor, which is used to edit the source code;</li> <li>Distributed to the left, right and bottom are views:<ul> <li>Package Explorer (see 2) is the Java project view</li> <li>Console (see 3) is the command line output view</li> <li>Outline (see 4) is a view of the structure of the Java source code you are currently editing.</li> </ul> </li> <li>The views can be arbitrarily combined, and then a group of views defined as a Perspective (see 5), Eclipse predefined Java, Debug, and several other Perspective, for rapid switching.</li> </ul>"},{"location":"20-quick-start/20-dev-env/30-ide/#new-java-project","title":"New Java project","text":"<p>In the Eclipse menu select \"File\" - \"New\" - \"Java Project\", fill in <code>HelloWorld</code>, JRE Select <code>Java SE 22</code>:</p> <p></p> <p>Don't check \"Create module-info.java file\" for now, because we will talk about the modularization mechanism later:</p> <p></p> <p>Clicking \"Finish\" creates a Java project named <code>HelloWorld</code>.</p>"},{"location":"20-quick-start/20-dev-env/30-ide/#create-a-new-java-file-and-run-it","title":"Create a new Java file and run it","text":"<p>Expand the <code>HelloWorld</code> project, select the source directory <code>src</code>, right-click, and choose \"New\"-\"Class\" in the popup menu:</p> <p></p> <p>In the dialog box that pops up, put <code>Hello</code> in the <code>Name</code> field:</p> <p></p> <p>Clicking \"Finish\" automatically creates a source file named <code>Hello.java</code> in the <code>src</code> directory. Let's double-click on it to open the source file and fill in the code:</p> <p></p> <p>Save it, then select the file <code>Hello.java</code>, right-click on it, and in the pop-up menu, select \"Run As...\". - \"Java Application\":</p> <p></p> <p>The results of the run can be seen in the <code>Console</code> window:</p> <p></p> <p>If you don't see the <code>Console</code> window in the main interface, check the menu \"Window\" - \"Show View\" - \"Console\". The <code>Console</code> window will be displayed.</p>"},{"location":"20-quick-start/30-basic/","title":"Overview","text":""},{"location":"20-quick-start/30-basic/#java-program-fundamentals","title":"Java program fundamentals","text":"<p>In this section we will cover the basics of Java programs, including:</p> <ul> <li>Basic structure of a Java program</li> <li>Variables and data types</li> <li>Integer operations</li> <li>Floating point operations</li> <li>Boolean operations</li> <li>Characters and strings</li> <li>Array types</li> </ul> <p></p>"},{"location":"20-quick-start/30-basic/10-program-structure/","title":"Program Structure","text":""},{"location":"20-quick-start/30-basic/10-program-structure/#java-program-basic-structure","title":"Java program basic structure","text":"<p>We start by dissecting a complete Java program and what its basic structure is:</p> <pre><code>/**\n * \u53ef\u4ee5\u7528\u6765\u81ea\u52a8\u521b\u5efa\u6587\u6863\u7684\u6ce8\u91ca\n */\npublic class Hello {\n    public static void main(String[] args) {\n        // \u5411\u5c4f\u5e55\u8f93\u51fa\u6587\u672c:\n        System.out.println(\"Hello, world!\");\n        /* \u591a\u884c\u6ce8\u91ca\u5f00\u59cb\n        \u6ce8\u91ca\u5185\u5bb9\n        \u6ce8\u91ca\u7ed3\u675f */\n    }\n} // class\u5b9a\u4e49\u7ed3\u675f\n</code></pre> <p>Because Java is an object-oriented language, the basic unit of a program is a <code>class</code>, and <code>class</code> is the keyword; the name of the <code>class</code> defined here is <code>Hello</code>:</p> <pre><code>public class Hello { // \u7c7b\u540d\u662fHello\n    // ...\n} // class\u5b9a\u4e49\u7ed3\u675f\n</code></pre> <p>Class name requirements:</p> <ul> <li>Class names must begin with a letter followed by a combination of letters, numbers and underscores</li> <li>Customarily begin with a capital letter</li> </ul> <p>Be careful to follow naming conventions and good class naming:</p> <ul> <li>Hello</li> <li>NoteBook</li> <li>VRPlayer</li> </ul> <p>Bad class naming:</p> <ul> <li>hello</li> <li>Good123</li> <li>Note_Book</li> <li>_World</li> </ul> <p>Notice that <code>public</code> is an access modifier indicating that the <code>class</code> is public.</p> <p>Without <code>public</code>, it will compile correctly, but the class will not be executable from the command line.</p> <p>Within <code>class</code>, several methods can be defined:</p> <pre><code>public class Hello {\n    public static void main(String[] args) { // \u65b9\u6cd5\u540d\u662fmain\n        // \u65b9\u6cd5\u4ee3\u7801...\n    } // \u65b9\u6cd5\u5b9a\u4e49\u7ed3\u675f\n}\n</code></pre> <p>A method defines a set of execution statements, and the code inside the method will be executed in sequential order.</p> <p>Here the method name is <code>main</code> and the return value is <code>void</code>, indicating that there is no return value.</p> <p>We notice that <code>public</code> can modify methods in addition to <code>class</code>. And the keyword <code>static</code> is another modifier which denotes a static method, and we will explain the types of methods later, for now, all we need to know is that the methods specified by the Java entry program must be static methods, the method name must be <code>main</code>, and the arguments in parentheses must be String arrays.</p> <p>There are also naming rules for method names, named like <code>class</code>, but with lowercase initial letters:</p> <p>Good way to name it:</p> <ul> <li>main</li> <li>goodMorning</li> <li>playVR</li> </ul> <p>Bad way to name it:</p> <ul> <li>Main</li> <li>good123</li> <li>good_morning</li> <li>_playVR</li> </ul> <p>Inside the method, the statement is the actual code that is executed.Each line of Java must be terminated with a semicolon:</p> <pre><code>public class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, world!\"); // \u8bed\u53e5\n    }\n}\n</code></pre> <p>In a Java program, comments are a kind of text for people to read, not part of the program, so the compiler automatically ignores them.</p> <p>Java has 3 types of comments, the first is a single line comment that begins with a double slash and ends with a double slash until the end of the line:</p> <pre><code>// \u8fd9\u662f\u6ce8\u91ca...\n</code></pre> <p>Multi-line comments, on the other hand, begin with a <code>/*</code> asterisk and end with <code>*/</code> and can have multiple lines:</p> <pre><code>/*\n\u8fd9\u662f\u6ce8\u91ca\nblablabla...\n\u8fd9\u4e5f\u662f\u6ce8\u91ca\n*/\n</code></pre> <p>There is also a special multi-line comment that starts with <code>/**</code> and ends with <code>*/</code>, and if there are multiple lines, each line usually starts with an asterisk:</p> <pre><code>/**\n * \u53ef\u4ee5\u7528\u6765\u81ea\u52a8\u521b\u5efa\u6587\u6863\u7684\u6ce8\u91ca\n * \n * @auther liaoxuefeng\n */\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, world!\");\n    }\n}\n</code></pre> <p>This special multi-line comment needs to be written at the definition of classes and methods and can be used to automatically create documentation.</p> <p>Java programs do not have a clear requirement for the format, a few more spaces or carriage returns do not affect the correctness of the program, but we have to develop good programming habits, pay attention to comply with the Java community agreed coding format.</p> <p>What are the requirements of that agreed coding format? In fact, we have introduced the Eclipse IDE provides a shortcut <code>Ctrl + Shift + F</code> (macOS is <code>\u2318 + \u21e7 + F</code>) to help us quickly format the code, Eclipse is in accordance with the agreed coding format of the code formatting , so just need to look at the formatted code after what looks like on the line. Specific code formatting requirements can be in the Eclipse settings <code>Java</code> - <code>Code Style</code> view.</p>"},{"location":"20-quick-start/30-basic/20-var-type/","title":"Variables and Types","text":""},{"location":"20-quick-start/30-basic/20-var-type/#variables-and-data-types","title":"Variables and data types","text":""},{"location":"20-quick-start/30-basic/20-var-type/#variables","title":"Variables","text":"<p>What is a variable?</p> <p>A variable is the concept of algebra in middle school math, such as a simple equation where x, y are variables:</p> <pre><code>y=x^2+1\n</code></pre> <p>In Java, there are two types of variables: variables of basic types and variables of reference types.</p> <p>We start by discussing variables of basic types.</p> <p>In Java, variables must be defined before they can be used, and when defining a variable, you can give it an initial value. Example:</p> <pre><code>int x = 1;\n</code></pre> <p>The above statement defines a variable of type integer <code>int</code> with name <code>x</code> and initial value <code>1</code>.</p> <p>Not writing an initial value is equivalent to assigning it a default value. The default value is always <code>0</code>.</p> <p>Come see a complete example of defining a variable and then printing the value of the variable:</p> <pre><code>// \u5b9a\u4e49\u5e76\u6253\u5370\u53d8\u91cf\npublic class Main {\n    public static void main(String[] args) {\n        int x = 100; // \u5b9a\u4e49int\u7c7b\u578b\u53d8\u91cfx\uff0c\u5e76\u8d4b\u4e88\u521d\u59cb\u503c100\n        System.out.println(x); // \u6253\u5370\u8be5\u53d8\u91cf\u7684\u503c\n    }\n}\n</code></pre> <p>An important feature of variables is that they can be reassigned. For example, for the variable <code>x</code>, assign the value <code>100</code> and then <code>200</code>, and observe the results of the two printouts:</p> <pre><code>// \u91cd\u65b0\u8d4b\u503c\u53d8\u91cf\npublic class Main {\n    public static void main(String[] args) {\n        int x = 100; // \u5b9a\u4e49int\u7c7b\u578b\u53d8\u91cfx\uff0c\u5e76\u8d4b\u4e88\u521d\u59cb\u503c100\n        System.out.println(x); // \u6253\u5370\u8be5\u53d8\u91cf\u7684\u503c\uff0c\u89c2\u5bdf\u662f\u5426\u4e3a100\n        x = 200; // \u91cd\u65b0\u8d4b\u503c\u4e3a200\n        System.out.println(x); // \u6253\u5370\u8be5\u53d8\u91cf\u7684\u503c\uff0c\u89c2\u5bdf\u662f\u5426\u4e3a200\n    }\n}\n</code></pre> <p>Notice that the first time the variable <code>x</code> is defined, the variable type <code>int</code> needs to be specified, so the statement <code>int x = 100;</code> is used. The second time the variable <code>x</code> is reassigned, the variable <code>x</code> already exists and cannot be redefined, so the variable type <code>int</code> cannot be specified, and the statement <code>x = 200;</code> must be used.</p> <p>Variables can not only be reassigned, but they can also be assigned to other variables. Let's look at an example:</p> <pre><code>// \u53d8\u91cf\u4e4b\u95f4\u7684\u8d4b\u503c\npublic class Main {\n    public static void main(String[] args) {\n        int n = 100; // \u5b9a\u4e49\u53d8\u91cfn\uff0c\u540c\u65f6\u8d4b\u503c\u4e3a100\n        System.out.println(\"n = \" + n); // \u6253\u5370n\u7684\u503c\n\n        n = 200; // \u53d8\u91cfn\u8d4b\u503c\u4e3a200\n        System.out.println(\"n = \" + n); // \u6253\u5370n\u7684\u503c\n\n        int x = n; // \u53d8\u91cfx\u8d4b\u503c\u4e3an\uff08n\u7684\u503c\u4e3a200\uff0c\u56e0\u6b64\u8d4b\u503c\u540ex\u7684\u503c\u4e5f\u662f200\uff09\n        System.out.println(\"x = \" + x); // \u6253\u5370x\u7684\u503c\n\n        x = x + 100; // \u53d8\u91cfx\u8d4b\u503c\u4e3ax+100\uff08x\u7684\u503c\u4e3a200\uff0c\u56e0\u6b64\u8d4b\u503c\u540ex\u7684\u503c\u662f200+100=300\uff09\n        System.out.println(\"x = \" + x); // \u6253\u5370x\u7684\u503c\n        System.out.println(\"n = \" + n); // \u518d\u6b21\u6253\u5370n\u7684\u503c\uff0cn\u5e94\u8be5\u662f200\u8fd8\u662f300\uff1f\n   }\n}\n</code></pre> <p>We analyze the code execution flow line by line:</p> <p>Execute <code>int n = 100;</code>, which defines the variable <code>n</code> and assigns the value <code>100</code>, so the JVM allocates a <code>storage unit</code> in memory for the variable <code>n</code>, filled with the value <code>100</code>:</p> <pre><code>n\n      \u2502\n      \u25bc\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502   \u2502100\u2502   \u2502   \u2502   \u2502   \u2502   \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>When executing <code>n = 200;</code>, the JVM writes <code>200</code> to the storage unit of the variable <code>n</code>, so the original value is overwritten and the value of <code>n</code> is now <code>200</code>:</p> <pre><code>n\n      \u2502\n      \u25bc\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502   \u2502200\u2502   \u2502   \u2502   \u2502   \u2502   \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>Execution of <code>int x = n;</code> defines a new variable <code>x</code> and assigns a value to <code>x</code> at the same time, so the JVM needs to newly allocate a storage unit to the variable <code>x</code> and write the same value as the variable <code>n</code>, with the result that the variable <code>x</code>'s value also changes to <code>200</code>:</p> <pre><code>n x\n      \u2502           \u2502\n      \u25bc           \u25bc\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502   \u2502200\u2502   \u2502   \u2502200\u2502   \u2502   \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>When executing <code>x = x + 100;</code>, the JVM first calculates the value <code>x + 100</code> on the right-hand side of the equation, which results in <code>300</code> (since the value of <code>x</code> is <code>200</code> at this moment), and then, it writes the result <code>300</code> to the storage unit of <code>x</code>, so that the final value of the variable <code>x</code> becomes <code>300</code>:</p> <pre><code>n x\n      \u2502           \u2502\n      \u25bc           \u25bc\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502   \u2502200\u2502   \u2502   \u2502300\u2502   \u2502   \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>As you can see, variables can be assigned repeatedly. Note that the equals sign <code>=</code> is an assignment statement, not equal in the mathematical sense, otherwise it would be impossible to explain <code>x = x + 100</code>.</p>"},{"location":"20-quick-start/30-basic/20-var-type/#basic-data-types","title":"Basic data types","text":"<p>Basic data types are types that the CPU can perform operations on directly.Java defines the following basic data types:</p> <ul> <li>Integer types: byte, short, int, long</li> <li>Floating point types: float, double</li> <li>Character type: char</li> <li>Boolean type: boolean</li> </ul> <p>What are the differences between these basic data types defined by Java? To understand these differences, we must briefly understand the basic structure of computer memory.</p> <p>The smallest storage unit of computer memory is a byte, a byte is an 8-bit binary number, i.e., 8 bits.Its binary representation ranges from <code>00000000</code> to <code>11111111</code>, which translates into decimal 0 to 255, and into hexadecimal <code>00</code> to <code>ff</code>.</p> <p>Memory cells are numbered from 0 and are called memory addresses. Each memory cell can be thought of as a room, and the memory address is the door number.</p> <pre><code>0 1 2 3 4 5 6  ...\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502...\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>A byte is 1byte, 1024 bytes is 1K, 1024K is 1M, 1024M is 1G, 1024G is 1T. the number of bytes in a computer with 4T of RAM is:</p> <pre><code>4T = 4 x 1024G\n   = 4 x 1024 x 1024M\n   = 4 x 1024 x 1024 x 1024K\n   = 4 x 1024 x 1024 x 1024 x 1024\n   = 4398046511104\n</code></pre> <p>Different data types occupy different numbers of bytes. Let's look at the number of bytes occupied by the Java basic data types:</p> <pre><code>\u250c\u2500\u2500\u2500\u2510\n  byte \u2502   \u2502\n       \u2514\u2500\u2500\u2500\u2518\n       \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n short \u2502   \u2502   \u2502\n       \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n       \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n   int \u2502   \u2502   \u2502   \u2502   \u2502\n       \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n       \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n  long \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502\n       \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n       \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n float \u2502   \u2502   \u2502   \u2502   \u2502\n       \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n       \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\ndouble \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502\n       \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n       \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n  char \u2502   \u2502   \u2502\n       \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>A <code>byte</code> is exactly one byte, while <code>long</code> and <code>double</code> take 8 bytes.</p>"},{"location":"20-quick-start/30-basic/20-var-type/#integer","title":"Integer","text":"<p>For integer types, Java defines only signed integers, so the highest bit indicates the sign bit (0 for positive numbers, 1 for negative numbers). The maximum range that various integer types can represent is as follows:</p> <ul> <li>byte: -128 ~ 127</li> <li>short: -32768 ~ 32767</li> <li>int: -2147483648 ~ 2147483647</li> <li>long: -9223372036854775808 ~ 9223372036854775807</li> </ul> <p>Let's look at the example of defining an integer:</p> <pre><code>// \u5b9a\u4e49\u6574\u578b\npublic class Main {\n    public static void main(String[] args) {\n        int i = 2147483647;\n        int i2 = -2147483648;\n        int i3 = 2_000_000_000; // \u52a0\u4e0b\u5212\u7ebf\u66f4\u5bb9\u6613\u8bc6\u522b\n        int i4 = 0xff0000; // \u5341\u516d\u8fdb\u5236\u8868\u793a\u768416711680\n        int i5 = 0b1000000000; // \u4e8c\u8fdb\u5236\u8868\u793a\u7684512\n\n        long n1 = 9000000000000000000L; // long\u578b\u7684\u7ed3\u5c3e\u9700\u8981\u52a0L\n        long n2 = 900; // \u6ca1\u6709\u52a0L\uff0c\u6b64\u5904900\u4e3aint\uff0c\u4f46int\u7c7b\u578b\u53ef\u4ee5\u8d4b\u503c\u7ed9long\n        int i6 = 900L; // \u9519\u8bef\uff1a\u4e0d\u80fd\u628along\u578b\u8d4b\u503c\u7ed9int\n    }\n}\n</code></pre> <p>Special note: The representation of the same number in the different alphabets is identical, e.g. <code>15</code> = <code>0xf</code> = <code>0b1111</code>.</p>"},{"location":"20-quick-start/30-basic/20-var-type/#floating-point","title":"Floating point","text":"<p>Floating-point numbers are decimals because when decimals are expressed in scientific notation, the decimal point can \"float\", e.g., 1234.5 can be expressed as 12.345x10<sup>2</sup>, or 1.2345x10<sup>3</sup>, and are therefore called floating point numbers.</p> <p>The following is an example of defining a floating point number:</p> <pre><code>float f1 = 3.14f;\nfloat f2 = 3.14e38f; // \u79d1\u5b66\u8ba1\u6570\u6cd5\u8868\u793a\u76843.14x10^38\nfloat f3 = 1.0; // \u9519\u8bef\uff1a\u4e0d\u5e26f\u7ed3\u5c3e\u7684\u662fdouble\u7c7b\u578b\uff0c\u4e0d\u80fd\u8d4b\u503c\u7ed9float\n\ndouble d = 1.79e308;\ndouble d2 = -1.79e308;\ndouble d3 = 4.9e-324; // \u79d1\u5b66\u8ba1\u6570\u6cd5\u8868\u793a\u76844.9x10^-324\n</code></pre> <p>For <code>float</code> types, the <code>f</code> suffix is required.</p> <p>Floating point numbers can be represented in a very large range, with <code>float</code> types up to 3.4x10<sup>38</sup> and <code>double</code> types up to 1.79x10<sup>308</sup>.</p>"},{"location":"20-quick-start/30-basic/20-var-type/#boolean-type","title":"Boolean type","text":"<p>The boolean type <code>boolean</code> has only two values, <code>true</code> and <code>false</code>, and booleans are always the result of a relational operation:</p> <pre><code>boolean b1 = true;\nboolean b2 = false;\nboolean isGreater = 5 &gt; 3; // \u8ba1\u7b97\u7ed3\u679c\u4e3atrue\nint age = 12;\nboolean isAdult = age &gt;= 18; // \u8ba1\u7b97\u7ed3\u679c\u4e3afalse\n</code></pre> <p>The Java language does not make provisions for storing boolean types, since theoretically only 1 bit is needed to store a boolean type, but usually the JVM internally represents <code>boolean</code> as a 4-byte integer.</p>"},{"location":"20-quick-start/30-basic/20-var-type/#character-types","title":"Character types","text":"<p>The character type <code>char</code> represents a character.Java's <code>char</code> type can represent a Unicode character in addition to standard ASCII:</p> <pre><code>// \u5b57\u7b26\u7c7b\u578b\npublic class Main {\n    public static void main(String[] args) {\n        char a = 'A';\n        char zh = '\u4e2d';\n        System.out.println(a);\n        System.out.println(zh);\n    }\n}\n</code></pre> <p>Note that the <code>char</code> type uses single quotes <code>'</code> and only one character, to separate it from the double-quoted <code>\"</code> string type.</p>"},{"location":"20-quick-start/30-basic/20-var-type/#reference-types","title":"Reference types","text":"<p>Apart from the basic types of variables mentioned above, the rest are reference types. For example, the most commonly used reference type is the <code>String</code> string:</p> <pre><code>String s = \"hello\";\n</code></pre> <p>Variables of the reference type are similar to pointers in C. They internally store an \"address\" that points to the location of an object in memory, which will be discussed in more detail later when we introduce the concept of classes.</p>"},{"location":"20-quick-start/30-basic/20-var-type/#constants","title":"Constants","text":"<p>When defining a variable with the <code>final</code> modifier, the variable becomes a constant:</p> <pre><code>final double PI = 3.14; // PI\u662f\u4e00\u4e2a\u5e38\u91cf\ndouble r = 5.0;\ndouble area = PI * r * r;\nPI = 300; // compile error!\n</code></pre> <p>Constants cannot be re-assigned after initialization at definition time, and re-assignment will result in a compilation error.</p> <p>Constants are useful for avoiding Magic numbers with meaningful variable names, e.g., instead of writing <code>3.14</code> all over the code, define a constant. If in the future we need to improve the precision of a calculation, we only need to change the definition of the constant, for example, to <code>3.1416</code>, instead of replacing <code>3.14</code> everywhere.</p> <p>To distinguish them from variables, by convention, constant names are usually all capitalized.</p>"},{"location":"20-quick-start/30-basic/20-var-type/#the-var-keyword","title":"The var keyword","text":"<p>There are times when the name of a type is too long and is more cumbersome to write. For example:</p> <pre><code>StringBuilder sb = new StringBuilder();\n</code></pre> <p>This time, if you want to omit the variable type, you can use the <code>var</code> keyword:</p> <pre><code>var sb = new StringBuilder();\n</code></pre> <p>The compiler automatically infers that the variable <code>sb</code> is of type <code>StringBuilder</code> based on the assignment statement. statement to the compiler:</p> <pre><code>var sb = new StringBuilder();\n</code></pre> <p>It will actually become automatic:</p> <pre><code>StringBuilder sb = new StringBuilder();\n</code></pre> <p>Thus, defining a variable using <code>var</code> is simply writing less of the variable type.</p>"},{"location":"20-quick-start/30-basic/20-var-type/#the-scope-of-a-variable","title":"The scope of a variable","text":"<p>In Java, multi-line statements are enclosed in <code>{ ... }</code>. Many control statements, such as conditional judgments and loops, have <code>{ ... }</code> as their own scope, for example:</p> <pre><code>if (...) { // if\u5f00\u59cb\n    ...\n    while (...) { // while \u5f00\u59cb\n        ...\n        if (...) { // if\u5f00\u59cb\n            ...\n        } // if\u7ed3\u675f\n        ...\n    } // while\u7ed3\u675f\n    ...\n} // if\u7ed3\u675f\n</code></pre> <p>As long as these <code>{ ... }</code>, the compiler recognizes the beginning and end of the statement block. Variables that are defined within a statement block have a scope that begins at the point of definition and ends at the end of the statement block. Referring to these variables out of scope, the compiler will report an error. An example:</p> <pre><code>{\n    ...\n    int i = 0; // \u53d8\u91cfi\u4ece\u8fd9\u91cc\u5f00\u59cb\u5b9a\u4e49\n    ...\n    {\n        ...\n        int x = 1; // \u53d8\u91cfx\u4ece\u8fd9\u91cc\u5f00\u59cb\u5b9a\u4e49\n        ...\n        {\n            ...\n            String s = \"hello\"; // \u53d8\u91cfs\u4ece\u8fd9\u91cc\u5f00\u59cb\u5b9a\u4e49\n            ...\n        } // \u53d8\u91cfs\u4f5c\u7528\u57df\u5230\u6b64\u7ed3\u675f\n        ...\n        // \u6ce8\u610f\uff0c\u8fd9\u662f\u4e00\u4e2a\u65b0\u7684\u53d8\u91cfs\uff0c\u5b83\u548c\u4e0a\u9762\u7684\u53d8\u91cf\u540c\u540d\uff0c\n        // \u4f46\u662f\u56e0\u4e3a\u4f5c\u7528\u57df\u4e0d\u540c\uff0c\u5b83\u4eec\u662f\u4e24\u4e2a\u4e0d\u540c\u7684\u53d8\u91cf:\n        String s = \"hi\";\n        ...\n    } // \u53d8\u91cfx\u548cs\u4f5c\u7528\u57df\u5230\u6b64\u7ed3\u675f\n    ...\n} // \u53d8\u91cfi\u4f5c\u7528\u57df\u5230\u6b64\u7ed3\u675f\n</code></pre> <p>When defining variables, follow the principle of scope minimization, try to define variables in the smallest possible scope, and, do not reuse variable names.</p>"},{"location":"20-quick-start/30-basic/20-var-type/#summary","title":"Summary","text":"<p>Java provides two types of variables: basic types and reference types</p> <p>Basic types include integer, floating point, boolean, and character.</p> <p>Variables can be reassigned, and the equal sign is an assignment statement, not an equal sign in the mathematical sense.</p> <p>Constants cannot be reassigned after initialization, and their use facilitates understanding of program intent.</p>"},{"location":"20-quick-start/30-basic/30-integer/","title":"Integer Types","text":""},{"location":"20-quick-start/30-basic/30-integer/#integer-operations","title":"Integer operations","text":"<p>Java's integer arithmetic follows the rule of four and can use any nested parentheses. The rule of four is consistent with elementary math. For example:</p> <pre><code>// \u56db\u5219\u8fd0\u7b97\npublic class Main {\n    public static void main(String[] args) {\n        int i = (100 + 200) * (99 - 88); // 3300\n        int n = 7 * (5 + (i - 9)); // 23072\n        System.out.println(i);\n        System.out.println(n);\n    }\n}\n</code></pre> <p>The numerical representation of integers is not only exact, but integer operations are always exact, even in division, since dividing two integers yields only the integer part of the result:</p> <pre><code>int x = 12345 / 67; // 184\n</code></pre> <p>Use <code>%</code> for the remainder operation:</p> <pre><code>int y = 12345 % 67; // 12345\u00f767\u7684\u4f59\u6570\u662f17\n</code></pre> <p>Special note: Integer division will report an error at runtime when the divisor is 0, but will not report an error when compiled.</p>"},{"location":"20-quick-start/30-basic/30-integer/#overflow","title":"Overflow","text":"<p>Pay special attention to the fact that integers, due to the existence of a range limit, will overflow if the result of the calculation is out of range, and the overflow will not be an error, but will give a strange result:</p> <pre><code>// \u8fd0\u7b97\u6ea2\u51fa\npublic class Main {\n    public static void main(String[] args) {\n        int x = 2147483640;\n        int y = 15;\n        int sum = x + y;\n        System.out.println(sum); // -2147483641\n    }\n}\n</code></pre> <p>To interpret the above result, we convert the integers <code>2147483640</code> and <code>15</code> into binary to do the addition:</p> <pre><code>0111 1111 1111 1111 1111 1111 1111 1000\n+ 0000 0000 0000 0000 0000 0000 0000 1111\n-----------------------------------------\n  1000 0000 0000 0000 0000 0000 0000 0111\n</code></pre> <p>Since the highest bit is calculated as <code>1</code>, the result of the addition becomes a negative number.</p> <p>To solve the above problem, you can replace <code>int</code> with <code>long</code> type, and since <code>long</code> can represent a larger range of integers, the result will not overflow:</p> <pre><code>long x = 2147483640;\nlong y = 15;\nlong sum = x + y;\nSystem.out.println(sum); // 2147483655\n</code></pre> <p>There is also a shorthand operator, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, which are used as follows:</p> <pre><code>n += 100; // 3409, \u76f8\u5f53\u4e8e n = n + 100;\nn -= 100; // 3309, \u76f8\u5f53\u4e8e n = n - 100;\n</code></pre>"},{"location":"20-quick-start/30-basic/30-integer/#self-increasingdecreasing","title":"Self-increasing/decreasing","text":"<p>Java also provides the <code>++</code> operation and the <code>--</code> operation, which can add 1 and subtract 1 to an integer:</p> <pre><code>// \u81ea\u589e/\u81ea\u51cf\u8fd0\u7b97\npublic class Main {\n    public static void main(String[] args) {\n        int n = 3300;\n        n++; // 3301, \u76f8\u5f53\u4e8e n = n + 1;\n        n--; // 3300, \u76f8\u5f53\u4e8e n = n - 1;\n        int y = 100 + (++n); // \u4e0d\u8981\u8fd9\u4e48\u5199\n        System.out.println(y);\n    }\n}\n</code></pre> <p>Note that <code>++</code> written before and after the calculation results are different, <code>++n</code> means first add 1 and then refer to n, <code>n++</code> means first refer to n and then add 1. It is not recommended to mix the <code>++</code> operation into the regular operation, it is easy to confuse yourself.</p>"},{"location":"20-quick-start/30-basic/30-integer/#shift-operations","title":"Shift operations","text":"<p>In computers, integers are always represented in binary form. For example, an integer <code>7</code> of type <code>int</code> is represented in binary using 4 bytes as follows:</p> <pre><code>00000000 0000000 0000000 00000111\n</code></pre> <p>It is possible to perform shift operations on integers. Shifting an integer <code>7</code> by one place gives an integer <code>14</code> and shifting it by two places gives an integer <code>28</code>:</p> <pre><code>int n = 7;       // 00000000 00000000 00000000 00000111 = 7\nint a = n &lt;&lt; 1;  // 00000000 00000000 00000000 00001110 = 14\nint b = n &lt;&lt; 2;  // 00000000 00000000 00000000 00011100 = 28\nint c = n &lt;&lt; 28; // 01110000 00000000 00000000 00000000 = 1879048192\nint d = n &lt;&lt; 29; // 11100000 00000000 00000000 00000000 = -536870912\n</code></pre> <p>On shifting left by 29 bits, the result becomes negative as the highest bit becomes <code>1</code>.</p> <p>Similarly, a right shift of the integer 28 results in the following:</p> <pre><code>int n = 7;       // 00000000 00000000 00000000 00000111 = 7\nint a = n &gt;&gt; 1;  // 00000000 00000000 00000000 00000011 = 3\nint b = n &gt;&gt; 2;  // 00000000 00000000 00000000 00000001 = 1\nint c = n &gt;&gt; 3;  // 00000000 00000000 00000000 00000000 = 0\n</code></pre> <p>If a negative number is shifted right and the <code>1</code> in the highest bit does not move, the result is still a negative number:</p> <pre><code>int n = -536870912;\nint a = n &gt;&gt; 1;  // 11110000 00000000 00000000 00000000 = -268435456\nint b = n &gt;&gt; 2;  // 11111000 00000000 00000000 00000000 = -134217728\nint c = n &gt;&gt; 28; // 11111111 11111111 11111111 11111110 = -2\nint d = n &gt;&gt; 29; // 11111111 11111111 11111111 11111111 = -1\n</code></pre> <p>There is also an unsigned right-shift operation, using <code>&gt;&gt;&gt;</code>, which is characterized by the fact that, regardless of the sign bit, the higher bits are always complemented by <code>0</code> after the right-shift, so a <code>&gt;&gt;&gt;</code> right-shift of a negative number will turn it into a positive number, due to the fact that the <code>1</code> in the highest bit becomes a <code>0</code>:</p> <pre><code>int n = -536870912;\nint a = n &gt;&gt;&gt; 1;  // 01110000 00000000 00000000 00000000 = 1879048192\nint b = n &gt;&gt;&gt; 2;  // 00111000 00000000 00000000 00000000 = 939524096\nint c = n &gt;&gt;&gt; 29; // 00000000 00000000 00000000 00000111 = 7\nint d = n &gt;&gt;&gt; 31; // 00000000 00000000 00000000 00000001 = 1\n</code></pre> <p>When shifting <code>byte</code> and <code>short</code> types, they are first converted to <code>int</code> before being shifted.</p> <p>A closer look reveals that a left shift is actually a constant \u00d72 and a right shift is actually a constant \u00f72.</p>"},{"location":"20-quick-start/30-basic/30-integer/#bitwise-arithmetic","title":"Bitwise arithmetic","text":"<p>Bitwise operations are operations of and, or, not and different or by bit. Let's first look at bitwise operations for a single bit.</p> <p>The rule with operations is that both numbers must be <code>1</code> at the same time for the result to be <code>1</code>:</p> <pre><code>n = 0 &amp; 0; // 0\nn = 0 &amp; 1; // 0\nn = 1 &amp; 0; // 0\nn = 1 &amp; 1; // 1\n</code></pre> <p>The rule for the or operation is that whenever either is <code>1</code>, the result is <code>1</code>:</p> <pre><code>n = 0 | 0; // 0\nn = 0 | 1; // 1\nn = 1 | 0; // 1\nn = 1 | 1; // 1\n</code></pre> <p>The rule for non-arithmetic is that <code>0</code> and <code>1</code> are interchanged:</p> <pre><code>n = ~0; // 1\nn = ~1; // 0\n</code></pre> <p>The rule for the different-or operation is that if two numbers are different, the result is <code>1</code>, otherwise <code>0</code>:</p> <pre><code>n = 0 ^ 0; // 0\nn = 0 ^ 1; // 1\nn = 1 ^ 0; // 1\nn = 1 ^ 1; // 0\n</code></pre> <p>Java does not have a single bit data type. In Java, bitwise operations on two integers are actually aligned by bit and then performed on each bit in turn. Example:</p> <pre><code>// \u4f4d\u8fd0\u7b97\npublic class Main {\n    public static void main(String[] args) {\n        int i = 167776589; // 00001010 00000000 00010001 01001101\n        int n = 167776512; // 00001010 00000000 00010001 00000000\n                         // &amp; -----------------------------------\n                           // 00001010 00000000 00010001 00000000\n        System.out.println(i &amp; n); // 167776512\n    }\n}\n</code></pre> <p>The above bitwise sum operation can actually be viewed as two integer representations of the IP addresses <code>10.0.17.77</code> and <code>10.0.17.0</code>, and by using the sum operation, it is possible to quickly determine whether or not an IP is within a given network segment.</p>"},{"location":"20-quick-start/30-basic/30-integer/#operational-priority","title":"Operational priority","text":"<p>In Java's computational expressions, operations are prioritized in descending order:</p> <ul> <li><code>()</code></li> <li><code>!</code> <code>~</code> <code>++</code> <code>--</code></li> <li><code>*</code> <code>/</code> <code>%</code></li> <li><code>+</code> <code>-</code></li> <li><code>&lt;&lt;</code> <code>&gt;&gt;&gt;</code> <code>&gt;&gt;&gt;&gt;&gt;</code></li> <li><code>&amp;</code></li> <li><code>|</code></li> <li><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code></li> </ul> <p>It doesn't matter if you can't remember, just add the parentheses to make sure the operation is prioritized correctly.</p>"},{"location":"20-quick-start/30-basic/30-integer/#type-auto-raising-and-forced-transformation","title":"Type auto-raising and forced transformation","text":"<p>During an operation, if the two numbers involved are of different types, the result is an integer of the larger type. For example, if <code>short</code> and <code>int</code> are computed, the result is always <code>int</code>, because <code>short</code> is automatically transformed to <code>int</code> first:</p> <pre><code>// \u7c7b\u578b\u81ea\u52a8\u63d0\u5347\u4e0e\u5f3a\u5236\u8f6c\u578b\npublic class Main {\n    public static void main(String[] args) {\n        short s = 1234;\n        int i = 123456;\n        int x = s + i; // s\u81ea\u52a8\u8f6c\u578b\u4e3aint\n        short y = s + i; // \u7f16\u8bd1\u9519\u8bef!\n    }\n}\n</code></pre> <p>It is also possible to force a transformation of the result, i.e., to transform a large range of integers into a small range of integers. Forced transformations use <code>(type)</code>, e.g., forcing an <code>int</code> into a <code>short</code>:</p> <pre><code>int i = 12345;\nshort s = (short) i; // 12345\n</code></pre> <p>Be aware that out-of-range forced transformations give incorrect results due to the fact that the two high bytes of <code>int</code> are simply thrown away during the transformation, retaining only the two low bytes:</p> <pre><code>// \u5f3a\u5236\u8f6c\u578b\npublic class Main {\n    public static void main(String[] args) {\n        int i1 = 1234567;\n        short s1 = (short) i1; // -10617\n        System.out.println(s1);\n        int i2 = 12345678;\n        short s2 = (short) i2; // 24910\n        System.out.println(s2);\n    }\n}\n</code></pre> <p>Therefore, the result of forced transition is likely to be wrong.</p>"},{"location":"20-quick-start/30-basic/30-integer/#exercise","title":"Exercise","text":"<p>Calculating the sum of the first N natural numbers can be based on the formula:</p> <pre><code>\\frac{(1+N)\\times N}2\n</code></pre> <p>Calculate the sum of the first N natural numbers according to the formula:</p> <pre><code>// \u8ba1\u7b97\u524dN\u4e2a\u81ea\u7136\u6570\u7684\u548c\npublic class Main {\n    public static void main(String[] args) {\n        int n = 100;\n        // TODO: sum = 1 + 2 + ... + n\n        int sum = ???;\n        System.out.println(sum);\n        System.out.println(sum == 5050 ? \"\u6d4b\u8bd5\u901a\u8fc7\" : \"\u6d4b\u8bd5\u5931\u8d25\");\n    }\n}\n</code></pre> <p>Download exercise</p>"},{"location":"20-quick-start/30-basic/30-integer/#summary","title":"Summary","text":"<p>The result of integer arithmetic is always exact;</p> <p>The result of the operation is automatically boosted;</p> <p>It is possible to force transformations, but forcing transformations out of scope will give the wrong results;</p> <p>The appropriate range of integers (<code>int</code> or <code>long</code>) should be chosen, and there is no need to use <code>byte</code> and <code>short</code> for integer arithmetic in order to save memory.</p>"},{"location":"20-quick-start/30-basic/40-float/","title":"Floating Point Types","text":""},{"location":"20-quick-start/30-basic/40-float/#floating-point-arithmetic","title":"Floating point arithmetic","text":"<p>Floating-point operations, compared with integer operations, can only perform addition, subtraction, multiplication, and division of these numerical calculations, and cannot do bitwise and shift operations.</p> <p>In computers, although floating point numbers have a large range of representations, they have a very important characteristic, which is that they often cannot be represented exactly.</p> <p>An example:</p> <p>The floating-point number <code>0.1</code> cannot be represented exactly in a computer because <code>0.1</code> in decimal is an infinitely-circular decimal when converted to binary, and it is clear that only an approximation of <code>0.1</code> can be stored, whether <code>float</code> or <code>double</code> is used. However, <code>0.5</code>, a floating point number, can again be represented exactly.</p> <p>Because floating-point numbers often cannot be represented exactly, floating-point arithmetic is subject to error:</p> <pre><code>// \u6d6e\u70b9\u6570\u8fd0\u7b97\u8bef\u5dee\npublic class Main {\n    public static void main(String[] args) {\n        double x = 1.0 / 10;\n        double y = 1 - 9.0 / 10;\n        // \u89c2\u5bdfx\u548cy\u662f\u5426\u76f8\u7b49:\n        System.out.println(x);\n        System.out.println(y);\n    }\n}\n</code></pre> <p>Comparing two floating-point numbers for equality often yields incorrect results because of arithmetic errors in floating-point numbers. The correct method of comparison is to determine whether the absolute value of the difference between two floating-point numbers is less than a very small number:</p> <pre><code>// \u6bd4\u8f83x\u548cy\u662f\u5426\u76f8\u7b49\uff0c\u5148\u8ba1\u7b97\u5176\u5dee\u7684\u7edd\u5bf9\u503c:\ndouble r = Math.abs(x - y);\n// \u518d\u5224\u65ad\u7edd\u5bf9\u503c\u662f\u5426\u8db3\u591f\u5c0f:\nif (r &lt; 0.00001) {\n    // \u53ef\u4ee5\u8ba4\u4e3a\u76f8\u7b49\n} else {\n    // \u4e0d\u76f8\u7b49\n}\n</code></pre> <p>The representation of floating-point numbers in memory is more complex than that of integers. Java's floating-point numbers fully follow the IEEE-754 standard, which is the standard representation of floating-point numbers supported by the vast majority of computer platforms.</p>"},{"location":"20-quick-start/30-basic/40-float/#type-lifting","title":"Type Lifting","text":"<p>If one of the two numbers involved in the operation is an integer, then the integer can be automatically promoted to a floating-point type:</p> <pre><code>// \u7c7b\u578b\u63d0\u5347\npublic class Main {\n    public static void main(String[] args) {\n        int n = 5;\n        double d = 1.2 + 24.0 / n; // 6.0\n        System.out.println(d);\n    }\n}\n</code></pre> <p>Special attention needs to be paid to the fact that in a complex quadratic operation, the operation of two integers does not appear to be automatically lifted. Example:</p> <pre><code>double d = 1.2 + 24 / 5; // \u7ed3\u679c\u4e0d\u662f 6.0 \u800c\u662f 5.2\n</code></pre> <p>The reason the result is <code>5.2</code> is that the compiler calculates the sub-expression <code>24 / 5</code> as two integers, and the result is still the integer <code>4</code>.</p> <p>To fix this calculation, change <code>24 / 5</code> to <code>24.0 / 5</code>. Since <code>24.0</code> is a floating point number, the calculation of division automatically raises <code>5</code> to a floating point number.</p>"},{"location":"20-quick-start/30-basic/40-float/#overflow","title":"Overflow","text":"<p>Integer operations report an error when the divisor is <code>0</code>, while floating-point operations do not report an error when the divisor is <code>0</code>, but return several special values:</p> <ul> <li><code>NaN</code> means Not a Number</li> <li><code>Infinity</code> means infinity.</li> <li><code>-Infinity</code> means negative infinity.</li> </ul> <p>Example:</p> <pre><code>double d1 = 0.0 / 0; // NaN\ndouble d2 = 1.0 / 0; // Infinity\ndouble d3 = -1.0 / 0; // -Infinity\n</code></pre> <p>These three special values are seldom encountered in actual arithmetic, we just need to understand them.</p>"},{"location":"20-quick-start/30-basic/40-float/#forced-transition","title":"Forced transition","text":"<p>It is possible to force the transformation of a floating point number to an integer. When transforming, the fractional part of the floating point number is discarded. If the transformation exceeds the maximum range that the integer can represent, the maximum value of the integer is returned. Example:</p> <pre><code>int n1 = (int) 12.3; // 12\nint n2 = (int) 12.7; // 12\nint n3 = (int) -12.7; // -12\nint n4 = (int) (12.7 + 0.5); // 13\nint n5 = (int) 1.2e20; // 2147483647\n</code></pre> <p>If you want to round, you can add <code>0.5</code> to the floating point number and then force the transformation:</p> <pre><code>// \u56db\u820d\u4e94\u5165\npublic class Main {\n    public static void main(String[] args) {\n        double d = 2.6;\n        int n = (int) (d + 0.5);\n        System.out.println(n);\n    }\n}\n</code></pre>"},{"location":"20-quick-start/30-basic/40-float/#exercise","title":"Exercise","text":"<p>Based on the root formula for the quadratic equation $ax^2+bx+c=0$:</p> <pre><code>\\frac{\\displaystyle-b\\pm\\sqrt{b^2-4ac}}{\\displaystyle2a}\n</code></pre> <p>Calculate two solutions to a quadratic equation:</p> <pre><code>// \u4e00\u5143\u4e8c\u6b21\u65b9\u7a0b\npublic class Main {\n    public static void main(String[] args) {\n        double a = 1.0;\n        double b = 3.0;\n        double c = -4.0;\n        // \u6c42\u5e73\u65b9\u6839\u53ef\u7528 Math.sqrt():\n        // System.out.println(Math.sqrt(2)); ==&gt; 1.414\n        // TODO:\n        double r1 = 0;\n        double r2 = 0;\n        System.out.println(r1);\n        System.out.println(r2);\n        System.out.println(r1 == 1 &amp;&amp; r2 == -4 ? \"\u6d4b\u8bd5\u901a\u8fc7\" : \"\u6d4b\u8bd5\u5931\u8d25\");\n    }\n}\n</code></pre> <p>Download exercise</p>"},{"location":"20-quick-start/30-basic/40-float/#summary","title":"Summary","text":"<p>Floating-point numbers are often impossible to represent precisely, and the results of floating-point arithmetic can be inaccurate;</p> <p>Comparing two floating-point numbers usually compares whether the absolute value of their difference is less than a specific value;</p> <p>Integer and floating-point operations are automatically promoted to floating-point when integer is used;</p> <p>It is possible to force a floating-point type to an integer, but out of range will always return the maximum value of the integer.</p>"},{"location":"20-quick-start/30-basic/50-boolean/","title":"Boolean Type","text":""},{"location":"20-quick-start/30-basic/50-boolean/#boolean","title":"Boolean","text":"<p>For the boolean type <code>boolean</code>, there are always only two values, <code>true</code> and <code>false</code>.</p> <p>Boolean operations are relational operations that include the following categories:</p> <ul> <li>Comparison operators: <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>! =</code></li> <li>The with operation <code>&amp;&amp;</code></li> <li>Or operations <code>||</code></li> <li>Non-operations <code>!</code></li> </ul> <p>Here are some examples:</p> <pre><code>boolean isGreater = 5 &gt; 3; // true\nint age = 12;\nboolean isZero = age == 0; // false\nboolean isNonZero = !isZero; // true\nboolean isAdult = age &gt;= 18; // false\nboolean isTeenager = age &gt;6 &amp;&amp; age &lt;18; // true\n</code></pre> <p>Relational operators are prioritized in descending order:</p> <ul> <li><code>!</code></li> <li><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code></li> <li><code>==</code>, <code>! =</code></li> <li><code>&amp;&amp;</code></li> <li><code>||</code></li> </ul>"},{"location":"20-quick-start/30-basic/50-boolean/#short-circuit-arithmetic","title":"Short-circuit arithmetic","text":"<p>An important feature of Boolean operations is short-circuiting. If a Boolean expression determines the result in advance, subsequent calculations are no longer performed and the result is returned directly.</p> <p>Because <code>false &amp;&amp; x</code> always results in <code>false</code>, regardless of whether <code>x</code> is <code>true</code> or <code>false</code>, the with operation, after determining that the first value is <code>false</code>, does not continue the computation, but simply returns <code>false</code>.</p> <p>We examine the following code:</p> <pre><code>// \u77ed\u8def\u8fd0\u7b97\npublic class Main {\n    public static void main(String[] args) {\n        boolean b = 5 &lt; 3;\n        boolean result = b &amp;&amp; (5 / 0 &gt; 0); // \u6b64\u5904 5 / 0 \u4e0d\u4f1a\u62a5\u9519\n        System.out.println(result);\n    }\n}\n</code></pre> <p>Without the short-circuit operation, the expression following <code>&amp;&amp;</code> would report an error due to a division of <code>0</code>, but in fact the statement does not report an error because the with operation is a short-circuit operator that calculates the result <code>false</code> in advance.</p> <p>If the value of the variable <code>b</code> is <code>true</code>, the expression becomes <code>true &amp;&amp; (5 / 0 &gt; 0)</code>. Since short-circuiting is not possible, this expression is bound to report an error due to a divisor of <code>0</code>, so you can test it yourself.</p> <p>Similarly, for the <code>||</code> operation, as soon as the first value can be determined to be <code>true</code>, subsequent calculations are no longer performed and <code>true</code> is returned directly:</p> <pre><code>boolean result = true || (5 / 0 &gt; 0); // true\n</code></pre>"},{"location":"20-quick-start/30-basic/50-boolean/#ternary-operators","title":"Ternary operators","text":"<p>Java also provides a ternary operator <code>b ? x : y</code>, which returns the result of the computation of one of the two subsequent expressions, depending on the result of the first Boolean expression. Example:</p> <pre><code>// \u4e09\u5143\u8fd0\u7b97\npublic class Main {\n    public static void main(String[] args) {\n        int n = -100;\n        int x = n &gt;= 0 ? n : -n;\n        System.out.println(x);\n    }\n}\n</code></pre> <p>The above statement means to determine whether <code>n &gt;= 0</code> holds, and return <code>n</code> if it is <code>true</code>, otherwise return <code>-n</code>. This is actually an expression to find the absolute value.</p> <p>Notice that the ternary operation <code>b ? x : y</code> will first compute <code>b</code>, and if <code>b</code> is <code>true</code>, then only <code>x</code> is computed, otherwise, only <code>y</code> is computed. Also, the types of <code>x</code> and <code>y</code> must be the same, since the return value is not <code>boolean</code>, but one of <code>x</code> and <code>y</code>.</p>"},{"location":"20-quick-start/30-basic/50-boolean/#exercise","title":"Exercise","text":"<p>Determine if the specified age is an elementary school student (6 to 12 years old):</p> <pre><code>// \u5e03\u5c14\u8fd0\u7b97\npublic class Main {\n    public static void main(String[] args) {\n        int age = 7;\n        // primary student\u7684\u5b9a\u4e49: 6~12\u5c81\n        boolean isPrimaryStudent = ???;\n        System.out.println(isPrimaryStudent ? \"Yes\" : \"No\");\n    }\n}\n</code></pre> <p>Download exercise</p>"},{"location":"20-quick-start/30-basic/50-boolean/#summary","title":"Summary","text":"<p>The operations with and or are short-circuiting operations;</p> <p>The ternary operation <code>b ? x : y</code> must be followed by the same type, and the ternary operation is also a \"short-circuit operation\", which computes only <code>x</code> or <code>y</code>.</p>"},{"location":"20-quick-start/30-basic/60-string/","title":"String Type","text":""},{"location":"20-quick-start/30-basic/60-string/#characters-and-strings","title":"Characters and strings","text":"<p>In Java, characters and strings are two different types.</p>"},{"location":"20-quick-start/30-basic/60-string/#character-types","title":"Character types","text":"<p>The character type <code>char</code> is the basic data type which is an abbreviation for <code>character</code>. A <code>char</code> holds one Unicode character:</p> <pre><code>char c1 = 'A';\nchar c2 = '\u4e2d';\n</code></pre> <p>Because Java always uses Unicode to represent characters in memory, an English character and a Chinese character are both represented by a <code>char</code> type, and they both take up two bytes. To display the Unicode encoding of a character, simply assign the <code>char</code> type directly to the <code>int</code> type:</p> <pre><code>int n1 = 'A'; // \u5b57\u6bcd\u201cA\u201d\u7684Unicodde\u7f16\u7801\u662f65\nint n2 = '\u4e2d'; // \u6c49\u5b57\u201c\u4e2d\u201d\u7684Unicode\u7f16\u7801\u662f20013\n</code></pre> <p>It is also possible to represent a character directly with the escape character <code>\\u</code> + Unicode encoding:</p> <pre><code>// \u6ce8\u610f\u662f\u5341\u516d\u8fdb\u5236:\nchar c3 = '\\u0041'; // 'A'\uff0c\u56e0\u4e3a\u5341\u516d\u8fdb\u52360041 = \u5341\u8fdb\u523665\nchar c4 = '\\u4e2d'; // '\u4e2d'\uff0c\u56e0\u4e3a\u5341\u516d\u8fdb\u52364e2d = \u5341\u8fdb\u523620013\n</code></pre>"},{"location":"20-quick-start/30-basic/60-string/#string-type","title":"String type","text":"<p>Unlike the <code>char</code> type, the string type <code>String</code> is a reference type, and we use double quotes <code>\"...\"</code> to denote a string. A string can store from 0 to any number of characters:</p> <pre><code>String s = \"\"; // \u7a7a\u5b57\u7b26\u4e32\uff0c\u5305\u542b0\u4e2a\u5b57\u7b26\nString s1 = \"A\"; // \u5305\u542b\u4e00\u4e2a\u5b57\u7b26\nString s2 = \"ABC\"; // \u5305\u542b3\u4e2a\u5b57\u7b26\nString s3 = \"\u4e2d\u6587 ABC\"; // \u5305\u542b6\u4e2a\u5b57\u7b26\uff0c\u5176\u4e2d\u6709\u4e00\u4e2a\u7a7a\u683c\n</code></pre> <p>Since strings use double quotes <code>\"...\"</code> to indicate the beginning and the end, what if the string itself happens to contain a <code>\"</code> character? For example, <code>\"abc \"xyz\"</code>, the compiler will not be able to determine whether the middle quote is part of the string or the end of the string. In this case, we need to use the escape character <code>\\</code>:</p> <pre><code>String s = \"abc\\\"xyz\"; // \u5305\u542b7\u4e2a\u5b57\u7b26: a, b, c, \", x, y, z\n</code></pre> <p>Since <code>\\</code> is an escape character, two <code>\\\\</code>s represent one <code>\\</code> character:</p> <pre><code>String s = \"abc\\\\xyz\"; // \u5305\u542b7\u4e2a\u5b57\u7b26: a, b, c, \\, x, y, z\n</code></pre> <p>Common escape characters include:</p> <ul> <li><code>\\\"</code> indicates the character <code>\"</code>.</li> <li><code>\\'</code> indicates the character <code>'</code>.</li> <li><code>\\\\\\</code> indicates the character <code>\\\\</code>.</li> <li><code>\\n</code> indicates a line feed.</li> <li><code>\\r</code> indicates a carriage return.</li> <li><code>\\t</code> for Tab</li> <li><code>\\u=####</code> indicates a Unicode encoded character</li> </ul> <p>Example:</p> <pre><code>String s = \"ABC\\n\\u4e2d\\u6587\"; // \u5305\u542b6\u4e2a\u5b57\u7b26: A, B, C, \u6362\u884c\u7b26, \u4e2d, \u6587\n</code></pre>"},{"location":"20-quick-start/30-basic/60-string/#string-concatenation","title":"String concatenation","text":"<p>Java's compiler takes special care of strings by allowing you to use <code>+</code> to connect any string to other data types, which greatly facilitates string handling. For example:</p> <pre><code>// \u5b57\u7b26\u4e32\u8fde\u63a5\npublic class Main {\n    public static void main(String[] args) {\n        String s1 = \"Hello\";\n        String s2 = \"world\";\n        String s = s1 + \" \" + s2 + \"!\";\n        System.out.println(s); // Hello world!\n    }\n}\n</code></pre> <p>If you concatenate strings and other data types with <code>+</code>, it will automatically transform the other data types to strings first before concatenating them:</p> <pre><code>// \u5b57\u7b26\u4e32\u8fde\u63a5\npublic class Main {\n    public static void main(String[] args) {\n        int age = 25;\n        String s = \"age is \" + age;\n        System.out.println(s); // age is 25\n    }\n}\n</code></pre>"},{"location":"20-quick-start/30-basic/60-string/#multi-line-strings","title":"Multi-line strings","text":"<p>If we want to represent a multi-line string, it would be very inconvenient to concatenate it with a + sign:</p> <pre><code>String s = \"first line \\n\"\n         + \"second line \\n\"\n         + \"end\";\n</code></pre> <p>Starting with Java 13, strings can now be represented by <code>\"\"\"\"\"...\"\"\"</code> to represent multi-line strings (Text Blocks) now. An example:</p> <pre><code>// \u591a\u884c\u5b57\u7b26\u4e32\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"\"\"\n                   SELECT * FROM\n                     users\n                   WHERE id &gt; 100\n                   ORDER BY name DESC\n                   \"\"\";\n        System.out.println(s);\n    }\n}\n</code></pre> <p>The above multi-line string is actually 5 lines with a <code>\\n</code> after the last <code>DESC</code>. If we don't want a <code>\\n</code> at the end of the string, this is how we need to write it:</p> <pre><code>String s = \"\"\" \n           SELECT * FROM\n             users\n           WHERE id &gt; 100\n           ORDER BY name DESC\"\"\";\n</code></pre> <p>It is also important to note that spaces common to the front of multi-line strings are removed, ie:</p> <pre><code>String s = \"\"\"\n...........SELECT * FROM\n........... users\n...........WHERE id &gt; 100\n...........ORDER BY name DESC\n...........\"\"\";\n</code></pre> <p>Spaces marked with <code>.</code> are labeled with spaces that are removed.</p> <p>If a multi-line string has irregular typography, then the removed spaces look like this:</p> <pre><code>String s = \"\"\"\n......... SELECT * FROM\n......... users\n.........WHERE id &gt; 100\n......... ORDER BY name DESC\n.........  \"\"\";\n</code></pre> <p>That is, it is always based on the shortest space at the beginning of the line.</p>"},{"location":"20-quick-start/30-basic/60-string/#irrevocable-properties","title":"Irrevocable properties","text":"<p>An important feature of Java's string, besides being a reference type, is that the string is immutable. Examine the following code:</p> <pre><code>// \u5b57\u7b26\u4e32\u4e0d\u53ef\u53d8\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"hello\";\n        System.out.println(s); // \u663e\u793a hello\n        s = \"world\";\n        System.out.println(s); // \u663e\u793a world\n    }\n}\n</code></pre> <p>Observe the result, did the string <code>s</code> change? Actually, it is not the string that has changed, but the variable <code>s</code> that has changed.</p> <p>When executing <code>String s = \"hello\";</code>, the JVM virtual machine first creates the string <code>\"hello\"</code> and then, points the string variable <code>s</code> to it:</p> <pre><code>s\n      \u2502\n      \u25bc\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502   \u2502  \"hello\"  \u2502   \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>Immediately afterward, when executing <code>s = \"world\";</code>, the JVM virtual machine first creates the string <code>\"world\"</code> and then, points the string variable <code>s</code> to it:</p> <pre><code>s \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502\n                      \u25bc\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502   \u2502  \"hello\"  \u2502   \u2502  \"world\"  \u2502   \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>The original string <code>\"hello\"</code> is still there, we just can't access it through the variable <code>s</code>. Thus, the immutability of a string means that the content of the string is immutable. As for the variable, it can point to the string <code>\"hello\"</code> at one time and to the string <code>\"world\"</code> at another.</p> <p>After understanding the \"pointing\" of a reference type, try to interpret the following code output:</p> <pre><code>// \u5b57\u7b26\u4e32\u4e0d\u53ef\u53d8\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"hello\";\n        String t = s;\n        s = \"world\";\n        System.out.println(t); // t\u662f\"hello\"\u8fd8\u662f\"world\"?\n    }\n}\n</code></pre>"},{"location":"20-quick-start/30-basic/60-string/#the-null-value-null","title":"The null value null","text":"<p>A variable of reference type can point to a null value <code>null</code>, which indicates non-existence, i.e. the variable does not point to any object. Example:</p> <pre><code>String s1 = null; // s1\u662fnull\nString s2 = s1; // s2\u4e5f\u662fnull\nString s3 = \"\"; // s3\u6307\u5411\u7a7a\u5b57\u7b26\u4e32\uff0c\u4e0d\u662fnull\n</code></pre> <p>Note the distinction between the null value <code>null</code> and the empty string <code>\"\"</code>, which is a valid string object that is not equal to <code>null</code>.</p>"},{"location":"20-quick-start/30-basic/60-string/#exercise","title":"Exercise","text":"<p>Please treat a set of int values as the Unicode encoding of a character and then put them together into a string:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        // \u8bf7\u5c06\u4e0b\u9762\u4e00\u7ec4int\u503c\u89c6\u4e3a\u5b57\u7b26\u7684Unicode\u7801\uff0c\u628a\u5b83\u4eec\u62fc\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32\uff1a\n        int a = 72;\n        int b = 105;\n        int c = 65281;\n        // FIXME:\n        String s = a + b + c;\n        System.out.println(s);\n    }\n}\n</code></pre> <p>Download Exercise</p>"},{"location":"20-quick-start/30-basic/60-string/#summary","title":"Summary","text":"<p>Java's character type <code>char</code> is a basic type and the string type <code>String</code> is a reference type;</p> <p>Basic variables \"hold\" a value, while reference variables \"point\" to an object;</p> <p>Variables of reference type can be null <code>null</code>;</p> <p>To distinguish between the null value <code>null</code> and the empty string <code>\"\"</code>.</p>"},{"location":"20-quick-start/30-basic/70-array/","title":"Arrays","text":""},{"location":"20-quick-start/30-basic/70-array/#array-types","title":"Array types","text":"<p>If we have a set of variables of the same type, for example, the grades of 5 students, we can write it like this:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        // 5\u4f4d\u540c\u5b66\u7684\u6210\u7ee9:\n        int n1 = 68;\n        int n2 = 79;\n        int n3 = 91;\n        int n4 = 85;\n        int n5 = 62;\n    }\n}\n</code></pre> <p>But there is no need to define 5 <code>int</code> variables. You can use an array to represent a \"set\" of <code>int</code> types. The code is as follows:</p> <pre><code>// \u6570\u7ec4\npublic class Main {\n    public static void main(String[] args) {\n        // 5\u4f4d\u540c\u5b66\u7684\u6210\u7ee9:\n        int[] ns = new int[5];\n        ns[0] = 68;\n        ns[1] = 79;\n        ns[2] = 91;\n        ns[3] = 85;\n        ns[4] = 62;\n    }\n}\n</code></pre> <p>To define a variable of type array, use the array type <code>type[]', e.g.,</code>int[]<code>. Unlike a single basic type variable, an array variable must be initialized using</code>new int[5]<code>to indicate the creation of an array that can hold five</code>int` elements.</p> <p>Java's arrays have several features:</p> <ul> <li>All elements of an array are initialized to their default values, which are <code>0</code> for integers, <code>0.0</code> for floats, and <code>false</code> for booleans;</li> <li>The size of an array is immutable once it has been created.</li> </ul> <p>To access an element in an array, you need to use an index. Array indexes start at <code>0</code>, for example, an array of 5 elements has an index range of <code>0</code> to <code>4</code>.</p> <p>It is possible to modify an element of an array, using an assignment statement, e.g., <code>ns[1] = 79;</code>.</p> <p>You can use <code>array variable.length</code> to get the array size:</p> <pre><code>// \u6570\u7ec4\npublic class Main {\n    public static void main(String[] args) {\n        // 5\u4f4d\u540c\u5b66\u7684\u6210\u7ee9:\n        int[] ns = new int[5];\n        System.out.println(ns.length); // 5\n    }\n}\n</code></pre> <p>Arrays are reference types, and when using an index to access an array element, the runtime will report an error if the index is out of range:</p> <pre><code>// \u6570\u7ec4\npublic class Main {\n    public static void main(String[] args) {\n        // 5\u4f4d\u540c\u5b66\u7684\u6210\u7ee9:\n        int[] ns = new int[5];\n        int n = 5;\n        System.out.println(ns[n]); // \u7d22\u5f15n\u4e0d\u80fd\u8d85\u51fa\u8303\u56f4\n    }\n}\n</code></pre> <p>It is also possible to specify the initialized elements directly when defining the array, so that you don't have to write out the array size, but rather the compiler automatically imputes the array size. Example:</p> <pre><code>// \u6570\u7ec4\npublic class Main {\n    public static void main(String[] args) {\n        // 5\u4f4d\u540c\u5b66\u7684\u6210\u7ee9:\n        int[] ns = new int[] { 68, 79, 91, 85, 62 };\n        System.out.println(ns.length); // \u7f16\u8bd1\u5668\u81ea\u52a8\u63a8\u7b97\u6570\u7ec4\u5927\u5c0f\u4e3a5\n    }\n}\n</code></pre> <p>It can be further abbreviated as:</p> <pre><code>int[] ns = { 68, 79, 91, 85, 62 };\n</code></pre> <p>Note that arrays are of reference type and the size of the array is immutable. Let's observe the following code:</p> <pre><code>// \u6570\u7ec4\npublic class Main {\n    public static void main(String[] args) {\n        // 5\u4f4d\u540c\u5b66\u7684\u6210\u7ee9:\n        int[] ns;\n        ns = new int[] { 68, 79, 91, 85, 62 };\n        System.out.println(ns.length); // 5\n        ns = new int[] { 1, 2, 3 };\n        System.out.println(ns.length); // 3\n    }\n}\n</code></pre> <p>Did the array size change? It looks like it changed, but it didn't really change at all.</p> <p>For the array <code>ns</code>, the execution <code>ns = new int[] { 68, 79, 91, 85, 62 };</code> points to a 5-element array:</p> <pre><code>ns\n      \u2502\n      \u25bc\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502   \u250268 \u250279 \u250291 \u250285 \u250262 \u2502   \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>When executing <code>ns = new int[] { 1, 2, 3 };</code> it points to a new 3-element array:</p> <pre><code>ns \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502   \u250268 \u250279 \u250291 \u250285 \u250262 \u2502   \u2502 1 \u2502 2 \u2502 3 \u2502   \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>However, the original 5-element array has not changed, it's just that you can't refer to them through the variable <code>ns</code>.</p>"},{"location":"20-quick-start/30-basic/70-array/#array-of-strings","title":"Array of strings","text":"<p>If the array element is not a basic type, but a reference type, what would be the difference in modifying the array element?</p> <p>Strings are reference types, so we start by defining an array of strings:</p> <pre><code>String[] names = {\n    \"ABC\", \"XYZ\", \"zoo\"\n};\n</code></pre> <p>For the array variable <code>names</code> of type <code>String[]</code>, it actually contains 3 elements, but each element points to some string object:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    names \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502   \u2502   \u2502                     \u2502           \u2502\n      \u25bc   \u2502   \u2502                     \u25bc           \u25bc\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2534\u2500\u252c\u2500\u2534\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502   \u2502\u2591\u2591\u2591\u2502\u2591\u2591\u2591\u2502\u2591\u2591\u2591\u2502   \u2502 \"ABC\" \u2502   \u2502 \"XYZ\" \u2502   \u2502 \"zoo\" \u2502   \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u252c\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n      \u2502                 \u25b2\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Assigning a value to <code>names[1]</code>, such as <code>names[1] = \"cat\";</code>, has the following effect:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    names \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n      \u2502   \u2502   \u2502                                 \u2502           \u2502\n      \u25bc   \u2502   \u2502                                 \u25bc           \u25bc\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2534\u2500\u252c\u2500\u2534\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502   \u2502\u2591\u2591\u2591\u2502\u2591\u2591\u2591\u2502\u2591\u2591\u2591\u2502   \u2502 \"ABC\" \u2502   \u2502 \"XYZ\" \u2502   \u2502 \"zoo\" \u2502   \u2502 \"cat\" \u2502   \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u252c\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n      \u2502                 \u25b2\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Notice here that the original string <code>\"XYZ\"</code> pointed to by <code>names[1]</code> has not changed, only the reference to <code>names[1]</code> has been changed from pointing to <code>\"XYZ\"</code> to pointing to <code>\"cat\"</code>, with the result that the string <code>\"XYZ\"</code> can no longer be accessed through <code>names[1]</code>.</p> <p>With a deeper understanding of \"pointing\", try to explain the following code:</p> <pre><code>// \u6570\u7ec4\npublic class Main {\n    public static void main(String[] args) {\n        String[] names = {\"ABC\", \"XYZ\", \"zoo\"};\n        String s = names[1];\n        names[1] = \"cat\";\n        System.out.println(s); // s\u662f\"XYZ\"\u8fd8\u662f\"cat\"?\n    }\n}\n</code></pre>"},{"location":"20-quick-start/30-basic/70-array/#summary","title":"Summary","text":"<p>An array is a collection of the same data type, and once created, an array is immutable in size;</p> <p>Array elements can be accessed by index, but index out of range will report an error;</p> <p>Array elements can be of value type (e.g., <code>int</code>) or reference type (e.g., <code>String</code>), but the array itself is of reference type;</p>"},{"location":"20-quick-start/40-flow/","title":"Overview","text":""},{"location":"20-quick-start/40-flow/#process-control","title":"Process control","text":"<p>In a Java program, the JVM always executes statements ending with a semicolon <code>;</code> sequentially by default. However, in actual code, programs often need to do conditional judgments, loops, so there is a need to have a variety of flow control statements to achieve the program jumps and loops and other functions.</p> <p></p> <p>In this section we will cover <code>if</code> conditional judgment, <code>switch</code> multiple choice and various looping statements.</p>"},{"location":"20-quick-start/40-flow/10-input-output/","title":"Input & Output","text":""},{"location":"20-quick-start/40-flow/10-input-output/#inputs-and-outputs","title":"Inputs and outputs","text":""},{"location":"20-quick-start/40-flow/10-input-output/#output","title":"Output","text":"<p>In the previous code, we always use <code>System.out.println()</code> to output something to the screen.</p> <p><code>println</code> is an abbreviation for print line, which means output with line breaks. Therefore, if you don't want to break lines after output, you can use <code>print()</code>:</p> <pre><code>// \u8f93\u51fa\npublic class Main {\n    public static void main(String[] args) {\n        System.out.print(\"A,\");\n        System.out.print(\"B,\");\n        System.out.print(\"C.\");\n        System.out.println();\n        System.out.println(\"END\");\n    }\n}\n</code></pre> <p>Note the effect of the execution of the above code.</p>"},{"location":"20-quick-start/40-flow/10-input-output/#formatting-output","title":"Formatting output","text":"<p>Java also provides the ability to format output. Why format output? Because computer representations of data are not always suitable for human reading:</p> <pre><code>// \u683c\u5f0f\u5316\u8f93\u51fa\npublic class Main {\n    public static void main(String[] args) {\n        double d = 12900000;\n        System.out.println(d); // 1.29E7\n    }\n}\n</code></pre> <p>If we want to display the data in the format we expect, we need to use the formatted output function. Formatted output uses <code>System.out.printf()</code>, and by using the placeholder <code>%?</code>, <code>printf()</code> can format the arguments that follow into the specified format:</p> <pre><code>// \u683c\u5f0f\u5316\u8f93\u51fa\npublic class Main {\n    public static void main(String[] args) {\n        double d = 3.1415926;\n        System.out.printf(\"%.2f\\n\", d); // \u663e\u793a\u4e24\u4f4d\u5c0f\u65703.14\n        System.out.printf(\"%.4f\\n\", d); // \u663e\u793a4\u4f4d\u5c0f\u65703.1416\n    }\n}\n</code></pre> <p>Java's formatting features provide a variety of placeholders to \"format\" various data types into a specified string:</p> placeholders description %d Formatted output integer %x Format output hexadecimal integer %f Formatted to output a floating point number %e Formatted to output scientific notation floats %s Format string <p>Note that since <code>%</code> represents a placeholder, two consecutive <code>%%</code>s represent a <code>%</code> character itself.</p> <p>The placeholders themselves can also have more detailed formatting parameters. The following example formats an integer into hexadecimal with 0's complementing the 8 bits:</p> <pre><code>// \u683c\u5f0f\u5316\u8f93\u51fa\npublic class Main {\n    public static void main(String[] args) {\n        int n = 12345000;\n        System.out.printf(\"n=%d, hex=%08x\", n, n); // \u6ce8\u610f\uff0c\u4e24\u4e2a%\u5360\u4f4d\u7b26\u5fc5\u987b\u4f20\u5165\u4e24\u4e2a\u6570\n    }\n}\n</code></pre> <p>For detailed formatting parameters, please refer to the JDK documentation java.util.Formatter</p>"},{"location":"20-quick-start/40-flow/10-input-output/#input","title":"Input","text":"<p>Compared to output, Java's input is much more complex.</p> <p>Let's start with an example of reading a string and an integer from the console:</p> <pre><code>import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in); // \u521b\u5efaScanner\u5bf9\u8c61\n        System.out.print(\"Input your name: \"); // \u6253\u5370\u63d0\u793a\n        String name = scanner.nextLine(); // \u8bfb\u53d6\u4e00\u884c\u8f93\u5165\u5e76\u83b7\u53d6\u5b57\u7b26\u4e32\n        System.out.print(\"Input your age: \"); // \u6253\u5370\u63d0\u793a\n        int age = scanner.nextInt(); // \u8bfb\u53d6\u4e00\u884c\u8f93\u5165\u5e76\u83b7\u53d6\u6574\u6570\n        System.out.printf(\"Hi, %s, you are %d\\n\", name, age); // \u683c\u5f0f\u5316\u8f93\u51fa\n    }\n}\n</code></pre> <p>First, we import <code>java.util.Scanner</code> through the <code>import</code> statement, <code>import</code> is a statement to import a class, must be placed at the beginning of the Java source code, later we will explain how to use <code>import</code> in detail in the <code>package</code> of Java.</p> <p>Then, create the <code>Scanner</code> object and pass in <code>System.in</code>. <code>System.out</code> represents the standard output stream, while <code>System.in</code> represents the standard input stream. Reading user input directly using <code>System.in</code> is possible but requires more complex code, whereas passing <code>Scanner</code> simplifies the subsequent code.</p> <p>With the <code>Scanner</code> object, to read a string entered by the user, use <code>scanner.nextLine()</code>, and to read an integer entered by the user, use <code>scanner.nextInt()</code>. <code>Scanner</code> automatically converts data types, so there is no need to convert them manually.</p> <p>To test the input, the user input must be read from the command line, so the process of compilation and execution needs to be followed:</p> <pre><code>$ javac Main.java\n</code></pre> <p>If this program compiles with a warning, you can ignore it for now and explain it in detail later when you learn IO. After successful compilation, execute it:</p> <pre><code>$ java Main\nInput your name: Bob \u25c0\u2500\u2500 \u8f93\u5165 Bob\nInput your age: 12   \u25c0\u2500\u2500 \u8f93\u5165 12\nHi, Bob, you are 12  \u25c0\u2500\u2500 \u8f93\u51fa\n</code></pre> <p>After entering a string and integer respectively as prompted, we get the formatted output.</p>"},{"location":"20-quick-start/40-flow/10-input-output/#exercise","title":"Exercise","text":"<p>Please help Xiaoming's classmates design a program that inputs the last test score (int) and the current test score (int), and then outputs the percentage improvement in the score, retaining two decimal places (e.g., 21.75%).</p> <p>Download exercise</p>"},{"location":"20-quick-start/40-flow/10-input-output/#summary","title":"Summary","text":"<p>The output provided by Java includes <code>System.out.println()</code> / <code>print()</code> / <code>printf()</code>, where <code>printf()</code> formats the output;</p> <p>Java provides Scanner object to facilitate input, read the corresponding type can be used: <code>scanner.nextLine()</code> / <code>nextInt()</code> / <code>nextDouble()</code> / ...</p>"},{"location":"20-quick-start/40-flow/20-if/","title":"If Statement","text":""},{"location":"20-quick-start/40-flow/20-if/#if-conditional-judgment","title":"if conditional judgment","text":"<p>In a Java program, an <code>if</code> statement is needed if you want to decide whether or not to execute a piece of code based on a condition.</p> <p>The basic syntax of an <code>if</code> statement is:</p> <pre><code>if (\u6761\u4ef6) {\n    // \u6761\u4ef6\u6ee1\u8db3\u65f6\u6267\u884c\n}\n</code></pre> <p>Depending on the result of the <code>if</code> calculation (<code>true</code> or <code>false</code>), the JVM decides whether or not to execute the <code>if</code> statement block (i.e., all statements contained in the curly braces {}).</p> <p>Let's look at an example:</p> <pre><code>// \u6761\u4ef6\u5224\u65ad\npublic class Main {\n    public static void main(String[] args) {\n        int n = 70;\n        if (n &gt;= 60) {\n            System.out.println(\"\u53ca\u683c\u4e86\");\n        }\n        System.out.println(\"END\");\n    }\n}\n</code></pre> <p>When the condition <code>n &gt;= 60</code> is calculated as <code>true</code>, the <code>if</code> block is executed and <code>\"Passed\"</code> is printed, otherwise the <code>if</code> block is skipped. Modify the value of <code>n</code> to see the effect of execution.</p> <p>Notice that the <code>if</code> statement contains a block that can contain multiple statements:</p> <pre><code>// \u6761\u4ef6\u5224\u65ad\npublic class Main {\n    public static void main(String[] args) {\n        int n = 70;\n        if (n &gt;= 60) {\n            System.out.println(\"\u53ca\u683c\u4e86\");\n            System.out.println(\"\u606d\u559c\u4f60\");\n        }\n        System.out.println(\"END\");\n    }\n}\n</code></pre> <p>The curly braces {} can be omitted when the <code>if</code> statement block has only one line of statements:</p> <pre><code>// \u6761\u4ef6\u5224\u65ad\npublic class Main {\n    public static void main(String[] args) {\n        int n = 70;\n        if (n &gt;= 60)\n            System.out.println(\"\u53ca\u683c\u4e86\");\n        System.out.println(\"END\");\n    }\n}\n</code></pre> <p>However, omitting the curly braces is not always a good idea. Suppose that at some point it suddenly becomes desirable to add a statement to the <code>if</code> statement block:</p> <pre><code>// \u6761\u4ef6\u5224\u65ad\npublic class Main {\n    public static void main(String[] args) {\n        int n = 50;\n        if (n &gt;= 60)\n            System.out.println(\"\u53ca\u683c\u4e86\");\n            System.out.println(\"\u606d\u559c\u4f60\"); // \u6ce8\u610f\u8fd9\u6761\u8bed\u53e5\u4e0d\u662fif\u8bed\u53e5\u5757\u7684\u4e00\u90e8\u5206\n        System.out.println(\"END\");\n    }\n}\n</code></pre> <p>Due to the use of indented formatting, it is easy to see both lines of a statement as an execution block of an <code>if</code> statement, when in fact only the first line of the statement is an execution block of an <code>if</code>. This is more likely to be a problem when using version control systems like git to automate merges, so ignoring the curly braces is not recommended.</p>"},{"location":"20-quick-start/40-flow/20-if/#else","title":"else","text":"<p>The <code>if</code> statement can also be written with an <code>else { ... }</code>, which will execute the <code>else</code> block of statements when the conditional judgment is <code>false</code>:</p> <pre><code>// \u6761\u4ef6\u5224\u65ad\npublic class Main {\n    public static void main(String[] args) {\n        int n = 70;\n        if (n &gt;= 60) {\n            System.out.println(\"\u53ca\u683c\u4e86\");\n        } else {\n            System.out.println(\"\u6302\u79d1\u4e86\");\n        }\n        System.out.println(\"END\");\n    }\n}\n</code></pre> <p>Modify the value of <code>n</code> in the above code and observe the block of statements executed by the program when the <code>if</code> condition is <code>true</code> or <code>false</code>.</p> <p>Note that <code>else</code> is not required.</p> <p>It is also possible to use multiple <code>if ... else if ...</code> in series. Example:</p> <pre><code>// \u6761\u4ef6\u5224\u65ad\npublic class Main {\n    public static void main(String[] args) {\n        int n = 70;\n        if (n &gt;= 90) {\n            System.out.println(\"\u4f18\u79c0\");\n        } else if (n &gt;= 60) {\n            System.out.println(\"\u53ca\u683c\u4e86\");\n        } else {\n            System.out.println(\"\u6302\u79d1\u4e86\");\n        }\n        System.out.println(\"END\");\n    }\n}\n</code></pre> <p>The effect of the tandem is actually equivalent:</p> <pre><code>if (n &gt;= 90) {\n    // n &gt;= 90\u4e3atrue:\n    System.out.println(\"\u4f18\u79c0\");\n} else {\n    // n &gt;= 90\u4e3afalse:\n    if (n &gt;= 60) {\n        // n &gt;= 60\u4e3atrue:\n        System.out.println(\"\u53ca\u683c\u4e86\");\n    } else {\n        // n &gt;= 60\u4e3afalse:\n        System.out.println(\"\u6302\u79d1\u4e86\");\n    }\n}\n</code></pre> <p>When using multiple <code>if</code>s in series, pay special attention to the order of judgment. Observe the code below:</p> <pre><code>// \u6761\u4ef6\u5224\u65ad\npublic class Main {\n    public static void main(String[] args) {\n        int n = 100;\n        if (n &gt;= 60) {\n            System.out.println(\"\u53ca\u683c\u4e86\");\n        } else if (n &gt;= 90) {\n            System.out.println(\"\u4f18\u79c0\");\n        } else {\n            System.out.println(\"\u6302\u79d1\u4e86\");\n        }\n    }\n}\n</code></pre> <p>Execution reveals that the condition <code>n &gt;= 90</code> is satisfied when <code>n = 100</code>, but the output is not <code>\"excellent\"</code> but <code>\"passed\"</code>. The reason is that when the <code>if</code> statement is executed from top to bottom, it first determines that <code>n &gt;= 60</code> succeeds, and then the subsequent <code>else</code>s are no longer executed, and thus <code>if (n &gt;= 90)</code> does not have a chance to be executed.</p> <p>The correct way to do this is to follow the range of judgments in order from largest to smallest:</p> <pre><code>// \u4ece\u5927\u5230\u5c0f\u4f9d\u6b21\u5224\u65ad\uff1a\nif (n &gt;= 90) {\n    // ...\n} else if (n &gt;= 60) {\n    // ...\n} else {\n    // ...\n}\n</code></pre> <p>Or rewrite it to judge in order from smallest to largest:</p> <pre><code>// \u4ece\u5c0f\u5230\u5927\u4f9d\u6b21\u5224\u65ad\uff1a\nif (n &lt; 60) {\n    // ...\n} else if (n &lt; 90) {\n    // ...\n} else {\n    // ...\n}\n</code></pre> <p>Special attention should also be paid to boundary conditions when using <code>if</code>. For example:</p> <pre><code>// \u6761\u4ef6\u5224\u65ad\npublic class Main {\n    public static void main(String[] args) {\n        int n = 90;\n        if (n &gt; 90) {\n            System.out.println(\"\u4f18\u79c0\");\n        } else if (n &gt;= 60) {\n            System.out.println(\"\u53ca\u683c\u4e86\");\n        } else {\n            System.out.println(\"\u6302\u79d1\u4e86\");\n        }\n    }\n}\n</code></pre> <p>Assuming that we expect a score of 90 or higher to be \"excellent\", the above code outputs \"pass\" because <code>&gt;</code> and <code>&gt;=</code> have different effects.</p> <p>As mentioned earlier floating-point numbers are often not represented precisely in computers, and calculations can be inaccurate, so it is not reliable to use the <code>==</code> judgment for determining the equality of floating-point numbers:</p> <pre><code>// \u6761\u4ef6\u5224\u65ad\npublic class Main {\n    public static void main(String[] args) {\n        double x = 1 - 9.0 / 10;\n        if (x == 0.1) {\n            System.out.println(\"x is 0.1\");\n        } else {\n            System.out.println(\"x is NOT 0.1\");\n        }\n    }\n}\n</code></pre> <p>The correct way to determine this is to use the fact that the difference is less than some critical value:</p> <pre><code>// \u6761\u4ef6\u5224\u65ad\npublic class Main {\n    public static void main(String[] args) {\n        double x = 1 - 9.0 / 10;\n        if (Math.abs(x - 0.1) &lt; 0.00001) {\n            System.out.println(\"x is 0.1\");\n        } else {\n            System.out.println(\"x is NOT 0.1\");\n        }\n    }\n}\n</code></pre>"},{"location":"20-quick-start/40-flow/20-if/#determining-the-equality-of-reference-types","title":"Determining the equality of reference types","text":"<p>In Java, to determine whether variables of value types are equal, you can use the <code>==</code> operator. However, to determine whether variables of reference types are equal, <code>==</code> indicates \"whether the references are equal\", or whether they point to the same object. For example, the following two String types, which have the same content but point to different objects, are judged by <code>==</code>, resulting in <code>false</code>:</p> <pre><code>// \u6761\u4ef6\u5224\u65ad\npublic class Main {\n    public static void main(String[] args) {\n        String s1 = \"hello\";\n        String s2 = \"HELLO\".toLowerCase();\n        System.out.println(s1);\n        System.out.println(s2);\n        if (s1 == s2) {\n            System.out.println(\"s1 == s2\");\n        } else {\n            System.out.println(\"s1 != s2\");\n        }\n    }\n}\n</code></pre> <p>To determine whether the contents of variables of reference types are equal, you must use the <code>equals()</code> method:</p> <pre><code>// \u6761\u4ef6\u5224\u65ad\npublic class Main {\n    public static void main(String[] args) {\n        String s1 = \"hello\";\n        String s2 = \"HELLO\".toLowerCase();\n        System.out.println(s1);\n        System.out.println(s2);\n        if (s1.equals(s2)) {\n            System.out.println(\"s1 equals s2\");\n        } else {\n            System.out.println(\"s1 not equals s2\");\n        }\n    }\n}\n</code></pre> <p>Note: When executing the statement <code>s1.equals(s2)</code>, if the variable <code>s1</code> is <code>null</code>, a <code>NullPointerException</code> is reported:</p> <pre><code>// \u6761\u4ef6\u5224\u65ad\npublic class Main {\n    public static void main(String[] args) {\n        String s1 = null;\n        if (s1.equals(\"hello\")) {\n            System.out.println(\"hello\");\n        }\n    }\n}\n</code></pre> <p>To avoid the <code>NullPointerException</code> error, you can utilize the short-circuit operator <code>&amp;&amp;</code>:</p> <pre><code>// \u6761\u4ef6\u5224\u65ad\npublic class Main {\n    public static void main(String[] args) {\n        String s1 = null;\n        if (s1 != null &amp;&amp; s1.equals(\"hello\")) {\n            System.out.println(\"hello\");\n        }\n    }\n}\n</code></pre> <p>It is also possible to put the object <code>\"hello\"</code>, which must not be <code>null</code>, in front: e.g. <code>if (\"hello\".equals(s)) { ... }</code>.</p>"},{"location":"20-quick-start/40-flow/20-if/#exercise","title":"Exercise","text":"<p>Write a program using <code>if ... else</code> to write a program to calculate the body mass index BMI and print the result.</p> <pre><code>BMI = \u4f53\u91cd(kg) / \u8eab\u9ad8(m)\u7684\u5e73\u65b9\n</code></pre> <p>BMI results:</p> <ul> <li>Hypertonic: less than 18.5</li> <li>Normal: 18.5 ~ 25</li> <li>Overweight: 25 ~ 28</li> <li>Obese: 28 ~ 32</li> <li>Very obese: above 32</li> </ul> <p>Download exercise</p>"},{"location":"20-quick-start/40-flow/20-if/#summary","title":"Summary","text":"<p><code>if ... else</code> can do conditional judgment, <code>else</code> is optional;</p> <p>The omission of the curly brackets <code>{}</code> is not recommended;</p> <p>Multiple <code>if ... else</code> in series should pay special attention to the order of judgment;</p> <p>Be aware of the <code>if</code> boundary condition;</p> <p>Be aware that floating-point number equality judgments cannot be made directly with the <code>==</code> operator;</p> <p>Use <code>equals()</code> for reference types to determine that the contents are equal, taking care to avoid <code>NullPointerException</code>.</p>"},{"location":"20-quick-start/40-flow/30-switch/","title":"Switch Statement","text":""},{"location":"20-quick-start/40-flow/30-switch/#switch-multiple-choices","title":"switch multiple choices","text":"<p>In addition to the <code>if</code> statement, there is also a conditional judgment that goes to separate branches depending on the result of a certain expression.</p> <p>For example, in a game, let the user choose options:</p> <ol> <li>Single-player mode</li> <li>Multiplayer mode</li> <li>Exit game</li> </ol> <p>This is where the <code>switch</code> statement comes in handy.</p> <p>The <code>switch</code> statement jumps to the matching <code>case</code> result based on the result of the <code>switch (expression)</code> computation, and then continues to execute subsequent statements until it encounters <code>break</code> to end execution.</p> <p>Let's look at an example:</p> <pre><code>// switch\npublic class Main {\n    public static void main(String[] args) {\n        int option = 1;\n        switch (option) {\n        case 1:\n            System.out.println(\"Selected 1\");\n            break;\n        case 2:\n            System.out.println(\"Selected 2\");\n            break;\n        case 3:\n            System.out.println(\"Selected 3\");\n            break;\n        }\n    }\n}\n</code></pre> <p>Modify the values of <code>option</code> to <code>1</code>, <code>2</code> and <code>3</code> and observe the execution results.</p> <p>If the value of <code>option</code> does not match any <code>case</code>, for example <code>option = 99</code>, then the <code>switch</code> statement will not execute any statements. In this case, you can add a <code>default</code> to the <code>switch</code> statement to execute the <code>default</code> when no <code>case</code> is matched:</p> <pre><code>// switch\npublic class Main {\n    public static void main(String[] args) {\n        int option = 99;\n        switch (option) {\n        case 1:\n            System.out.println(\"Selected 1\");\n            break;\n        case 2:\n            System.out.println(\"Selected 2\");\n            break;\n        case 3:\n            System.out.println(\"Selected 3\");\n            break;\n        default:\n            System.out.println(\"Selected other\");\n            break;\n        }\n    }\n}\n</code></pre> <p>If the <code>switch</code> statement is translated into an <code>if</code> statement, then the above code is equivalent:</p> <pre><code>if (option == 1) {\n    System.out.println(\"Selected 1\");\n} else if (option == 2) {\n    System.out.println(\"Selected 2\");\n} else if (option == 3) {\n    System.out.println(\"Selected 3\");\n} else {\n    System.out.println(\"Selected other\");\n}\n</code></pre> <p>In contrast to <code>if ... else if</code> statements, it is clearer to use the <code>switch</code> structure for multiple <code>==</code> judgments.</p> <p>Also note that the above \"translations\" only work if the <code>break</code> statement is written correctly for each <code>case</code> in the <code>switch</code> statement.</p> <p>When using <code>switch</code>, note that the <code>case</code> statement does not have the parentheses <code>{}</code>, and that the <code>case</code> statement is \"penetrating\" and omitting <code>break</code> will lead to unexpected results:</p> <pre><code>// switch\npublic class Main {\n    public static void main(String[] args) {\n        int option = 2;\n        switch (option) {\n        case 1:\n            System.out.println(\"Selected 1\");\n        case 2:\n            System.out.println(\"Selected 2\");\n        case 3:\n            System.out.println(\"Selected 3\");\n        default:\n            System.out.println(\"Selected other\");\n        }\n    }\n}\n</code></pre> <p>When <code>option = 2</code>, <code>\"Selected 2\"</code>, <code>\"Selected 3\"</code>, and <code>\"Selected other\"</code> will be output in order, the reason being that starting from the match to <code>case 2</code>, the subsequent statements will be executed in their entirety until a <code>break</code> statement is encountered. So don't forget to write <code>break</code> at any time.</p> <p>If there are several <code>case</code> statements executing the same set of statement blocks, you can write it this way:</p> <pre><code>// switch\npublic class Main {\n    public static void main(String[] args) {\n        int option = 2;\n        switch (option) {\n        case 1:\n            System.out.println(\"Selected 1\");\n            break;\n        case 2:\n        case 3:\n            System.out.println(\"Selected 2, 3\");\n            break;\n        default:\n            System.out.println(\"Selected other\");\n            break;\n        }\n    }\n}\n</code></pre> <p>When using <code>switch</code> statements, the order of the <code>cases</code> does not affect the program logic as long as a <code>break</code> is guaranteed:</p> <pre><code>switch (option) {\ncase 3:\n    ...\n    break;\ncase 2:\n    ...\n    break;\ncase 1:\n    ...\n    break;\n}\n</code></pre> <p>However, it is still recommended that they be arranged in natural order for ease of reading.</p> <p>The <code>switch</code> statement can also match strings. String matching compares \"equal content\". For example:</p> <pre><code>// switch\npublic class Main {\n    public static void main(String[] args) {\n        String fruit = \"apple\";\n        switch (fruit) {\n        case \"apple\":\n            System.out.println(\"Selected apple\");\n            break;\n        case \"pear\":\n            System.out.println(\"Selected pear\");\n            break;\n        case \"mango\":\n            System.out.println(\"Selected mango\");\n            break;\n        default:\n            System.out.println(\"No fruit selected\");\n            break;\n        }\n    }\n}\n</code></pre> <p>The <code>switch</code> statement can also use enumerated types, which we explain later.</p>"},{"location":"20-quick-start/40-flow/30-switch/#compilation-check","title":"Compilation check","text":"<p>When using the IDE, you can automatically check for missed <code>break</code> statements and <code>default</code> statements by turning on the IDE's compile check.</p> <p>In Eclipse, select <code>Preferences</code> - <code>Java</code> - <code>Compiler</code> - <code>Errors/Warnings</code> - <code>Potential programming problems</code> and mark the following checks as Warning:</p> <ul> <li>'switch' is missing 'default' case: warn when a <code>default</code> statement is missing;</li> <li>'switch' case fall-through: warn when a <code>case</code> is missing a <code>break</code>.</li> </ul> <p>In Idea, select <code>Preferences</code> - <code>Editor</code> - <code>Inspections</code> - <code>Java</code> - <code>Control flow issues</code> and mark the following check as Warning:</p> <ul> <li>'switch' statement without 'default' branch: warn when a `default' statement is missing;</li> <li>Fallthrough in 'switch' statement: warn when <code>break' is missing from a</code>case'.</li> </ul> <p>When there is a problem with a <code>switch</code> statement, you can get a warning alert in the IDE.</p> <p></p>"},{"location":"20-quick-start/40-flow/30-switch/#switch-expressions","title":"Switch expressions","text":"<p>When using <code>switch</code>, omitting <code>break</code> can cause serious logical errors that are not easily detected in the source code. Starting in Java 12, the <code>switch</code> statement was upgraded to a more concise expression syntax that uses a Pattern Matching-like approach to ensure that only one path will be executed, and does not require a <code>break</code> statement:</p> <pre><code>// switch\npublic class Main {\n    public static void main(String[] args) {\n        String fruit = \"apple\";\n        switch (fruit) {\n        case \"apple\" -&gt; System.out.println(\"Selected apple\");\n        case \"pear\" -&gt; System.out.println(\"Selected pear\");\n        case \"mango\" -&gt; {\n            System.out.println(\"Selected mango\");\n            System.out.println(\"Good choice!\");\n        }\n        default -&gt; System.out.println(\"No fruit selected\");\n        }\n    }\n}\n</code></pre> <p>Note that the new syntax uses <code>-&gt;</code> and needs to be enclosed in <code>{}</code> if there are multiple statements. Don't write <code>break</code> statements, because the new syntax will only execute matching statements, without penetration effects.</p> <p>Very often, we may also use a <code>switch</code> statement to assign a value to a variable. For example:</p> <pre><code>int opt;\nswitch (fruit) {\ncase \"apple\":\n    opt = 1;\n    break;\ncase \"pear\":\ncase \"mango\":\n    opt = 2;\n    break;\ndefault:\n    opt = 0;\n    break;\n}\n</code></pre> <p>With the new <code>switch</code> syntax, not only do you not need <code>break</code>, but you can also return the value directly. Rewrite the above code as follows:</p> <pre><code>// switch\npublic class Main {\n    public static void main(String[] args) {\n        String fruit = \"apple\";\n        int opt = switch (fruit) {\n            case \"apple\" -&gt; 1;\n            case \"pear\", \"mango\" -&gt; 2;\n            default -&gt; 0;\n        }; // \u6ce8\u610f\u8d4b\u503c\u8bed\u53e5\u8981\u4ee5;\u7ed3\u675f\n        System.out.println(\"opt = \" + opt);\n    }\n}\n</code></pre> <p>This results in cleaner code.</p>"},{"location":"20-quick-start/40-flow/30-switch/#yield","title":"yield","text":"<p>Most of the time, inside <code>switch</code> expressions, we return simple values.</p> <p>However, if complex statements are needed, we can also write many statements, put them into <code>{...}</code>, and then, using <code>yield</code>, return a value as the return value of the <code>switch</code> statement:</p> <pre><code>// yield\npublic class Main {\n    public static void main(String[] args) {\n        String fruit = \"orange\";\n        int opt = switch (fruit) {\n            case \"apple\" -&gt; 1;\n            case \"pear\", \"mango\" -&gt; 2;\n            default -&gt; {\n                int code = fruit.hashCode();\n                yield code; // switch\u8bed\u53e5\u8fd4\u56de\u503c\n            }\n        };\n        System.out.println(\"opt = \" + opt);\n    }\n}\n</code></pre>"},{"location":"20-quick-start/40-flow/30-switch/#exercise","title":"Exercise","text":"<p>Implement a simple rock, paper, scissors game using <code>switch</code>.</p> <p>Download exercise</p>"},{"location":"20-quick-start/40-flow/30-switch/#summary","title":"Summary","text":"<p>The <code>switch</code> statement can make multiple choices and then execute the code that follows the matching <code>case</code> statement;</p> <p>The result of a <code>switch</code> calculation must be an integer, string, or enumeration type;</p> <p>Be careful never to leave out <code>break</code>, it is recommended to turn on the <code>fall-through</code> warning;</p> <p>Always write <code>default</code> and suggest turning on the <code>missing default</code> warning;</p> <p>Starting with Java 14, <code>switch</code> statements are officially upgraded to expressions, eliminating the need for <code>break</code> and allowing the use of <code>yield</code> return values.</p>"},{"location":"20-quick-start/40-flow/40-while/","title":"While Loop","text":""},{"location":"20-quick-start/40-flow/40-while/#while-loop","title":"while loop","text":"<p>A loop statement is a statement that allows the computer to do a loop calculation based on a condition, continuing the loop when the condition is met and exiting the loop when the condition is not met.</p> <p>For example, calculate the sum from 1 to 100:</p> <pre><code>1 + 2 + 3 + 4 + \u2026 + 100 = ?\n</code></pre> <p>In addition to using the series formula, it is entirely possible to let the computer to do 100 times the cycle of accumulation. Because the computer is characterized by a very fast speed of calculation, we let the computer cycle 100 million times also use less than 1 second, so many calculations of the task, the human go to sort of can not be counted, but the computer counts, using the cycle of this simple and brutal method can quickly get the results.</p> <p>We'll start by looking at the <code>while</code> conditional loop provided by Java. Its basic usage is:</p> <pre><code>while (\u6761\u4ef6\u8868\u8fbe\u5f0f) {\n    \u5faa\u73af\u8bed\u53e5\n}\n// \u7ee7\u7eed\u6267\u884c\u540e\u7eed\u4ee3\u7801\n</code></pre> <p>The <code>while</code> loop begins each loop by determining whether the condition holds. If the result is <code>true</code>, the statement inside the loop is executed, and if the result is <code>false</code>, the loop jumps to the end of the <code>while</code> loop and continues on.</p> <p>We use a while loop to accumulate 1 to 100, which can be written like this:</p> <pre><code>// while\npublic class Main {\n    public static void main(String[] args) {\n        int sum = 0; // \u7d2f\u52a0\u7684\u548c\uff0c\u521d\u59cb\u5316\u4e3a0\n        int n = 1;\n        while (n &lt;= 100) { // \u5faa\u73af\u6761\u4ef6\u662fn &lt;= 100\n            sum = sum + n; // \u628an\u7d2f\u52a0\u5230sum\u4e2d\n            n ++; // n\u81ea\u8eab\u52a01\n        }\n        System.out.println(sum); // 5050\n    }\n}\n</code></pre> <p>Notice that the <code>while</code> loop determines the loop condition before looping, so it is possible to loop without doing anything at all once.</p> <p>Special attention should be paid to boundary conditions for looping conditional judgments, as well as for the handling of self-incrementing variables. Think about why the following code does not get the correct result:</p> <pre><code>// while\npublic class Main {\n    public static void main(String[] args) {\n        int sum = 0;\n        int n = 0;\n        while (n &lt;= 100) {\n            n ++;\n            sum = sum + n;\n        }\n        System.out.println(sum);\n    }\n}\n</code></pre> <p>If the loop condition is always satisfied, then the loop becomes a dead loop. A dead loop will result in 100% CPU usage and the user will feel that the computer is running slowly, so avoid writing dead loop code.</p> <p>If the logic of the loop condition is written in a faulty way, it can also cause unexpected results:</p> <pre><code>// while\npublic class Main {\n    public static void main(String[] args) {\n        int sum = 0;\n        int n = 1;\n        while (n &gt; 0) {\n            sum = sum + n;\n            n ++;\n        }\n        System.out.println(n); // -2147483648\n        System.out.println(sum);\n    }\n}\n</code></pre> <p>On the surface, the above <code>while</code> loop is a dead loop, but Java's <code>int</code> type has a maximum value, and when it reaches the maximum value, adding 1 will make it negative, and as a result, the <code>while</code> loop exits unexpectedly.</p>"},{"location":"20-quick-start/40-flow/40-while/#exercise","title":"Exercise","text":"<p>Use <code>while</code> to compute the sum from <code>m</code> to <code>n</code>:</p> <pre><code>// while\npublic class Main {\n    public static void main(String[] args) {\n        int sum = 0;\n        int m = 20;\n        int n = 100;\n        // \u4f7f\u7528while\u8ba1\u7b97M+...+N:\n        while (false) {\n        }\n        System.out.println(sum);\n    }\n}\n</code></pre> <p>Download exercise</p>"},{"location":"20-quick-start/40-flow/40-while/#summary","title":"Summary","text":"<p>The <code>while</code> loop first determines whether the loop condition is satisfied before executing the loop statement;</p> <p>The <code>while</code> loop may not execute once;</p> <p>Write loops with loop conditions in mind and avoid dead loops.</p>"},{"location":"20-quick-start/40-flow/50-do-while/","title":"Do-While Loop","text":""},{"location":"20-quick-start/40-flow/50-do-while/#do-while-loop","title":"do while loop","text":"<p>In Java, a <code>while</code> loop is a loop that first determines the loop condition and then executes the loop. The other type of <code>do while</code> loop is to execute the loop first, then judge the condition, continue the loop when the condition is satisfied, and exit when the condition is not satisfied. Its usage is:</p> <pre><code>do {\n    \u6267\u884c\u5faa\u73af\u8bed\u53e5\n} while (\u6761\u4ef6\u8868\u8fbe\u5f0f);\n</code></pre> <p>As you can see, the <code>do while</code> loop will loop at least once.</p> <p>Let's rewrite the summation of 1 to 100 in a <code>do while</code> loop:</p> <pre><code>// do-while\npublic class Main {\n    public static void main(String[] args) {\n        int sum = 0;\n        int n = 1;\n        do {\n            sum = sum + n;\n            n ++;\n        } while (n &lt;= 100);\n        System.out.println(sum);\n    }\n}\n</code></pre> <p>When using <code>do while</code> loops, the same care should be taken with the loop conditions.</p>"},{"location":"20-quick-start/40-flow/50-do-while/#exercise","title":"Exercise","text":"<p>Use a <code>do while</code> loop to calculate the sum from <code>m</code> to <code>n</code>.</p> <pre><code>// do while\npublic class Main {\n    public static void main(String[] args) {\n        int sum = 0;\n        int m = 20;\n        int n = 100;\n        // \u4f7f\u7528do while\u8ba1\u7b97M+...+N:\n        do {\n        } while (false);\n        System.out.println(sum);\n    }\n}\n</code></pre> <p>Download exercise</p>"},{"location":"20-quick-start/40-flow/50-do-while/#summary","title":"Summary","text":"<p><code>do while</code> executes the loop first and then judges the condition;</p> <p>The <code>do while</code> loop will execute at least once.</p>"},{"location":"20-quick-start/40-flow/60-for/","title":"For Loop","text":""},{"location":"20-quick-start/40-flow/60-for/#for-loop","title":"for loop","text":"<p>Apart from <code>while</code> and <code>do while</code> loops, the most widely used in Java is the <code>for</code> loop.</p> <p>The <code>for</code> loop is very powerful in that it uses a counter to implement the loop. The <code>for</code> loop initializes the counter and then, before each loop, detects the loop condition and updates the counter after each loop. The counter variable is usually named <code>i</code>.</p> <p>Let's rewrite the 1 to 100 summation in a <code>for</code> loop:</p> <pre><code>// for\npublic class Main {\n    public static void main(String[] args) {\n        int sum = 0;\n        for (int i=1; i&lt;=100; i++) {\n            sum = sum + i;\n        }\n        System.out.println(sum);\n    }\n}\n</code></pre> <p>Before the <code>for</code> loop is executed, the initialization statement <code>int i=1</code> is executed, which defines the counter variable <code>i</code> and assigns it an initial value of <code>1</code>, then the loop condition <code>i&lt;=100</code> is checked before the loop, and the loop is automatically executed after the loop <code>i++</code>, so the <code>for</code> loop puts the code for updating the counter in unison, compared to the <code>while</code> loop. There is no need to update the variable <code>i</code> inside the body of the <code>for</code> loop.</p> <p>Thus, the <code>for</code> loop is used:</p> <pre><code>for (\u521d\u59cb\u6761\u4ef6; \u5faa\u73af\u68c0\u6d4b\u6761\u4ef6; \u5faa\u73af\u540e\u66f4\u65b0\u8ba1\u6570\u5668) {\n    // \u6267\u884c\u8bed\u53e5\n}\n</code></pre> <p>If we want to sum all the elements of an integer array, we can do this with a <code>for</code> loop:</p> <pre><code>// for\npublic class Main {\n    public static void main(String[] args) {\n        int[] ns = { 1, 4, 9, 16, 25 };\n        int sum = 0;\n        for (int i=0; i&lt;ns.length; i++) {\n            System.out.println(\"i = \" + i + \", ns[i] = \" + ns[i]);\n            sum = sum + ns[i];\n        }\n        System.out.println(\"sum = \" + sum);\n    }\n}\n</code></pre> <p>The loop condition of the above code is <code>i&lt;ns.length</code>. Since the length of the <code>ns</code> array is <code>5</code>, when the value of <code>i</code> is updated to <code>5</code> after looping <code>5</code> times, the looping condition is not satisfied and the <code>for</code> loop ends.</p> <p>[!TIP]\u601d\u8003</p> <p>\u5982\u679c\u628a\u5faa\u73af\u6761\u4ef6\u6539\u4e3ai&lt;=ns.length\uff0c\u4f1a\u51fa\u73b0\u4ec0\u4e48\u95ee\u9898\uff1f</p> <p>Note that the initialization counter for <code>for</code> loops is always executed, and that <code>for</code> loops may also loop 0 times.</p> <p>When using a <code>for</code> loop, never modify the counter inside the loop body! Modifying the counter inside the loop body often leads to inexplicable logic errors. For the following code:</p> <pre><code>// for\npublic class Main {\n    public static void main(String[] args) {\n        int[] ns = { 1, 4, 9, 16, 25 };\n        for (int i=0; i&lt;ns.length; i++) {\n            System.out.println(ns[i]);\n            i = i + 1;\n        }\n    }\n}\n</code></pre> <p>Although no error is reported, only half of the array elements are printed because the <code>i = i + 1</code> inside the loop causes the counter variable to actually add <code>2</code> each time it loops (since the <code>for</code> loop also automatically executes <code>i++</code>). Therefore, do not modify the value of the counter in the <code>for</code> loop. The initialization of the counter, the judgment condition, and the update condition after each loop can be placed uniformly in the <code>for()</code> statement at a glance.</p> <p>If you wish to access only the array elements with even index numbers, you should rewrite the <code>for</code> loop as:</p> <pre><code>int[] ns = { 1, 4, 9, 16, 25 };\nfor (int i=0; i&lt;ns.length; i=i+2) {\n    System.out.println(ns[i]);\n}\n</code></pre> <p>This is accomplished by updating the counter with the statement <code>i=i+2</code>, thus avoiding the need to modify the variable <code>i</code> inside the loop.</p> <p>When using a <code>for</code> loop, the counter variable <code>i</code> should be defined in the <code>for</code> loop as much as possible:</p> <pre><code>int[] ns = { 1, 4, 9, 16, 25 };\nfor (int i=0; i&lt;ns.length; i++) {\n    System.out.println(ns[i]);\n}\n// \u65e0\u6cd5\u8bbf\u95eei\nint n = i; // compile error!\n</code></pre> <p>If the variable <code>i</code> is defined outside the <code>for</code> loop:</p> <pre><code>int[] ns = { 1, 4, 9, 16, 25 };\nint i;\nfor (i=0; i&lt;ns.length; i++) {\n    System.out.println(ns[i]);\n}\n// \u4ecd\u7136\u53ef\u4ee5\u4f7f\u7528i\nint n = i;\n</code></pre> <p>Then, after exiting the <code>for</code> loop, the variable <code>i</code> can still be accessed, which breaks the principle that variables should be minimized for access.</p>"},{"location":"20-quick-start/40-flow/60-for/#flexible-use-of-for-loops","title":"Flexible use of for loops","text":"<p>The <code>for</code> loop can also be missing the initialization statement, the loop condition, and the update statement for each loop, for example:</p> <pre><code>// \u4e0d\u8bbe\u7f6e\u7ed3\u675f\u6761\u4ef6:\nfor (int i=0; ; i++) {\n    ...\n}\n</code></pre> <pre><code>// \u4e0d\u8bbe\u7f6e\u7ed3\u675f\u6761\u4ef6\u548c\u66f4\u65b0\u8bed\u53e5:\nfor (int i=0; ;) {\n    ...\n}\n</code></pre> <pre><code>// \u4ec0\u4e48\u90fd\u4e0d\u8bbe\u7f6e:\nfor (;;) {\n    ...\n}\n</code></pre> <p>This is not usually recommended, but there are cases where it is possible to omit certain statements from a <code>for</code> loop.</p>"},{"location":"20-quick-start/40-flow/60-for/#for-each-loop","title":"for each loop","text":"<p>The <code>for</code> loop is often used to iterate through arrays because the counter allows you to access each element of the array by index:</p> <pre><code>int[] ns = { 1, 4, 9, 16, 25 };\nfor (int i=0; i&lt;ns.length; i++) {\n    System.out.println(ns[i]);\n}\n</code></pre> <p>However, many times what we actually really want to access is the value of each element of the array.Java also provides another <code>for each</code> loop that makes it simpler to iterate through the array:</p> <pre><code>// for each\npublic class Main {\n    public static void main(String[] args) {\n        int[] ns = { 1, 4, 9, 16, 25 };\n        for (int n : ns) {\n            System.out.println(n);\n        }\n    }\n}\n</code></pre> <p>Compared to a <code>for</code> loop, a <code>for each</code> loop's variable n is no longer a counter, but corresponds directly to each element of the array. The <code>for each</code> loop is also more concise. However, the <code>for each</code> loop cannot specify the order of traversal, nor can it get the index of the array.</p> <p>In addition to arrays, the <code>for each</code> loop can iterate over all \"iterable\" data types, including <code>List</code>, <code>Map</code>, and so on, which will be described later.</p>"},{"location":"20-quick-start/40-flow/60-for/#exercise-1","title":"Exercise 1","text":"<p>Given an array, output each element in reverse order using a <code>for</code> loop:</p> <pre><code>// for\npublic class Main {\n    public static void main(String[] args) {\n        int[] ns = { 1, 4, 9, 16, 25 };\n        for (int i=?; ???; ???) {\n            System.out.println(ns[i]);\n        }\n    }\n}\n</code></pre>"},{"location":"20-quick-start/40-flow/60-for/#exercise-2","title":"Exercise 2","text":"<p>Sums each element of an array using a <code>for each</code> loop:</p> <pre><code>// for each\npublic class Main {\n    public static void main(String[] args) {\n        int[] ns = { 1, 4, 9, 16, 25 };\n        int sum = 0;\n        for (???) {\n            // TODO\n        }\n        System.out.println(sum); // 55\n    }\n}\n</code></pre>"},{"location":"20-quick-start/40-flow/60-for/#exercise-3","title":"Exercise 3","text":"<p>The circumference \u03c0 can be calculated using the formula:</p> <pre><code>\\frac{\\mathrm\\pi}4=1-\\frac13+\\frac15-\\frac17+\\frac19-\\dots\n</code></pre> <p>Calculate \u03c0 using a <code>for</code> loop:</p> <pre><code>// for\npublic class Main {\n    public static void main(String[] args) {\n        double pi = 0;\n        for (???) {\n            // TODO\n        }\n        System.out.println(pi);\n    }\n}\n</code></pre> <p>Download Exercise</p>"},{"location":"20-quick-start/40-flow/60-for/#summary","title":"Summary","text":"<p>The <code>for</code> loop allows complex loops through counters;</p> <p>The <code>for each</code> loop can directly iterate through each element of the array;</p> <p>Best practice: the counter variable is defined inside the <code>for</code> loop and the counter is not modified inside the loop body;</p>"},{"location":"20-quick-start/40-flow/70-break-continue/","title":"Break and Continue","text":""},{"location":"20-quick-start/40-flow/70-break-continue/#break-and-continue","title":"break and continue","text":"<p>Two special statements that can be used in either a <code>while</code> loop or a <code>for</code> loop are the <code>break</code> statement and the <code>continue</code> statement.</p>"},{"location":"20-quick-start/40-flow/70-break-continue/#break","title":"Break","text":"<p>During a loop, you can use the <code>break</code> statement to jump out of the current loop. Let's look at an example:</p> <pre><code>// break\npublic class Main {\n    public static void main(String[] args) {\n        int sum = 0;\n        for (int i=1; ; i++) {\n            sum = sum + i;\n            if (i == 100) {\n                break;\n            }\n        }\n        System.out.println(sum);\n    }\n}\n</code></pre> <p>When calculating from 1 to 100 using a <code>for</code> loop, we do not set a test condition in <code>for()</code> for the loop to exit. However, inside the loop, we use <code>if</code> to determine that if <code>i==100</code>, we exit the loop by <code>break</code>.</p> <p>For this reason, the <code>break</code> statement is usually used in conjunction with an <code>if</code> statement. In particular, note that the <code>break</code> statement always jumps out of its own level of the loop. For example:</p> <pre><code>// break\npublic class Main {\n    public static void main(String[] args) {\n        for (int i=1; i&lt;=10; i++) {\n            System.out.println(\"i = \" + i);\n            for (int j=1; j&lt;=10; j++) {\n                System.out.println(\"j = \" + j);\n                if (j &gt;= i) {\n                    break;\n                }\n            }\n            // break\u8df3\u5230\u8fd9\u91cc\n            System.out.println(\"breaked\");\n        }\n    }\n}\n</code></pre> <p>The code above is two <code>for</code> loops nested together. Because the <code>break</code> statement is in the inner <code>for</code> loop, it will jump out of the inner <code>for</code> loop, but not out of the outer <code>for</code> loop.</p>"},{"location":"20-quick-start/40-flow/70-break-continue/#continue","title":"continue","text":"<p><code>break</code> jumps out of the current loop, i.e. the whole loop is not executed. <code>continue</code>, on the other hand, ends the current loop early and continues directly to the next loop. Let's look at an example:</p> <pre><code>// continue\npublic class Main {\n    public static void main(String[] args) {\n        int sum = 0;\n        for (int i=1; i&lt;=10; i++) {\n            System.out.println(\"begin i = \" + i);\n            if (i % 2 == 0) {\n                continue; // continue\u8bed\u53e5\u4f1a\u7ed3\u675f\u672c\u6b21\u5faa\u73af\n            }\n            sum = sum + i;\n            System.out.println(\"end i = \" + i);\n        }\n        System.out.println(sum); // 25\n    }\n}\n</code></pre> <p>Notice the effect of the <code>continue</code> statement. When <code>i</code> is odd, the entire loop is executed in its entirety, so <code>begin i=1</code> and <code>end i=1</code> are printed. When <code>i</code> is even, the <code>continue</code> statement ends the loop early, so <code>begin i=2</code> is printed but not <code>end i=2</code>.</p> <p>In multi-level nested loops, the <code>continue</code> statement also ends the current loop it is in.</p>"},{"location":"20-quick-start/40-flow/70-break-continue/#summary","title":"Summary","text":"<p>The <code>break</code> statement jumps out of the current loop;</p> <p>The <code>break</code> statement is often used in conjunction with <code>if</code> to end the entire loop early when a condition is met;</p> <p>The <code>break</code> statement always jumps out of the nearest layer of the loop;</p> <p>The <code>continue</code> statement ends this loop early;</p> <p>The <code>continue</code> statement is usually used in conjunction with <code>if</code> to end this loop early when a condition is met.</p>"},{"location":"20-quick-start/50-array-op/","title":"Overview","text":""},{"location":"20-quick-start/50-array-op/#array-manipulation","title":"Array manipulation","text":"<p>In this section we will cover operations on arrays, including:</p> <ul> <li>Iterate;</li> <li>Sorting.</li> </ul> <p>and the concept of multidimensional arrays.</p> <p></p>"},{"location":"20-quick-start/50-array-op/10-loop/","title":"Looping Arrays","text":""},{"location":"20-quick-start/50-array-op/10-loop/#traverse-the-array","title":"Traverse the array","text":"<p>We were introduced to arrays as a data type in Java Program Fundamentals. With arrays, we also need to manipulate it. And one of the most common operations on arrays is traversal.</p> <p>An array can be traversed with a <code>for</code> loop. Since each element of an array can be accessed by index, traversing an array can be accomplished using the standard <code>for</code> loop:</p> <pre><code>// \u904d\u5386\u6570\u7ec4\npublic class Main {\n    public static void main(String[] args) {\n        int[] ns = { 1, 4, 9, 16, 25 };\n        for (int i=0; i&lt;ns.length; i++) {\n            int n = ns[i];\n            System.out.println(n);\n        }\n    }\n}\n</code></pre> <p>To implement a <code>for</code> loop traversal, the initial condition is <code>i=0</code>, because the index always starts at <code>0</code>, and the condition to continue the loop is <code>i&lt;ns.length</code>, because when <code>i=ns.length</code>, <code>i</code> is out of the indexed range (the indexed range is <code>0</code> ~ <code>ns.length-1</code>), and after each loop, <code>i++</code>.</p> <p>The second way is to use a <code>for each</code> loop that directly iterates over each element of the array:</p> <pre><code>// \u904d\u5386\u6570\u7ec4\npublic class Main {\n    public static void main(String[] args) {\n        int[] ns = { 1, 4, 9, 16, 25 };\n        for (int n : ns) {\n            System.out.println(n);\n        }\n    }\n}\n</code></pre> <p>Note: In the <code>for (int n : ns)</code> loop, the variable <code>n</code> gets the elements of the <code>ns</code> array directly, not the index.</p> <p>Obviously a <code>for each</code> loop is more concise. However, the <code>for each</code> loop can't get the index of the array, so which <code>for</code> loop to use depends on our needs.</p>"},{"location":"20-quick-start/50-array-op/10-loop/#print-the-contents-of-an-array","title":"Print the contents of an array","text":"<p>Printing the array variable directly gives you the reference address of the array in the JVM:</p> <pre><code>int[] ns = { 1, 1, 2, 3, 5, 8 };\nSystem.out.println(ns); // \u7c7b\u4f3c [I@7852e922\n</code></pre> <p>This doesn't make much sense, since we want the contents of the elements of the array to be printed. So use a <code>for each</code> loop to print it:</p> <pre><code>int[] ns = { 1, 1, 2, 3, 5, 8 };\nfor (int n : ns) {\n    System.out.print(n + \", \");\n}\n</code></pre> <p>Printing using <code>for each</code> loops is also cumbersome. Luckily, the Java standard library provides <code>Arrays.toString()</code> to quickly print the contents of an array:</p> <pre><code>// \u904d\u5386\u6570\u7ec4\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] ns = { 1, 1, 2, 3, 5, 8 };\n        System.out.println(Arrays.toString(ns));\n    }\n}\n</code></pre>"},{"location":"20-quick-start/50-array-op/10-loop/#exercise","title":"Exercise","text":"<p>Please iterate through the array in reverse order and print each element:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        int[] ns = { 1, 4, 9, 16, 25 };\n        // \u5012\u5e8f\u6253\u5370\u6570\u7ec4\u5143\u7d20:\n        for (???) {\n            System.out.println(???);\n        }\n    }\n}\n</code></pre> <p>Download exercise</p>"},{"location":"20-quick-start/50-array-op/10-loop/#summary","title":"Summary","text":"<p>Iterating through an array can be done using a <code>for</code> loop, which accesses the array index, and a <code>for each</code> loop, which iterates directly over each array element, but does not get the index;</p> <p>Use <code>Arrays.toString()</code> to quickly get the contents of an array.</p>"},{"location":"20-quick-start/50-array-op/20-sort/","title":"Sorting Arrays","text":""},{"location":"20-quick-start/50-array-op/20-sort/#array-sorting","title":"Array sorting","text":"<p>Sorting an array is a very basic requirement in a program. Commonly used sorting algorithms are bubble sort, insertion sort and quick sort.</p> <p>Let's look at how to sort an integer array from smallest to largest using the bubble sort algorithm:</p> <pre><code>// \u5192\u6ce1\u6392\u5e8f\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] ns = { 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 };\n        // \u6392\u5e8f\u524d:\n        System.out.println(Arrays.toString(ns));\n        for (int i = 0; i &lt; ns.length - 1; i++) {\n            for (int j = 0; j &lt; ns.length - i - 1; j++) {\n                if (ns[j] &gt; ns[j+1]) {\n                    // \u4ea4\u6362ns[j]\u548cns[j+1]:\n                    int tmp = ns[j];\n                    ns[j] = ns[j+1];\n                    ns[j+1] = tmp;\n                }\n            }\n        }\n        // \u6392\u5e8f\u540e:\n        System.out.println(Arrays.toString(ns));\n    }\n}\n</code></pre> <p>The characteristic of bubble sort is that after each cycle, the largest number is exchanged at the end, so that the next cycle \"shaves off\" the last number, and each cycle is one place ahead of the end of the previous cycle.</p> <p>Also, notice that exchanging the values of two variables must be done with the help of a temporary variable. It is wrong to write it like this:</p> <pre><code>int x = 1;\nint y = 2;\n\nx = y; // x\u73b0\u5728\u662f2\ny = x; // y\u73b0\u5728\u8fd8\u662f2\n</code></pre> <p>The correct way to write it is:</p> <pre><code>int x = 1;\nint y = 2;\n\nint t = x; // \u628ax\u7684\u503c\u4fdd\u5b58\u5728\u4e34\u65f6\u53d8\u91cft\u4e2d, t\u73b0\u5728\u662f1\nx = y; // x\u73b0\u5728\u662f2\ny = t; // y\u73b0\u5728\u662ft\u7684\u503c1\n</code></pre> <p>In fact, Java's standard library has built-in sorting functionality, we just need to call <code>Arrays.sort()</code> provided by the JDK to sort:</p> <pre><code>// \u6392\u5e8f\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] ns = { 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 };\n        Arrays.sort(ns);\n        System.out.println(Arrays.toString(ns));\n    }\n}\n</code></pre> <p>It is important to note that sorting an array actually modifies the array itself. For example, the array before sorting is:</p> <pre><code>int[] ns = { 9, 3, 6, 5 };\n</code></pre> <p>In memory, this integer array is represented as follows:</p> <pre><code>\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\nns\u2500\u2500\u2500\u25b6\u2502 9 \u2502 3 \u2502 6 \u2502 5 \u2502\n      \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>When we call <code>Arrays.sort(ns);</code>, this integer array becomes in memory:</p> <pre><code>\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\nns\u2500\u2500\u2500\u25b6\u2502 3 \u2502 5 \u2502 6 \u2502 9 \u2502\n      \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>That is, the contents of the array pointed to by the variable <code>ns</code> have been changed.</p> <p>If you sort an array of strings. for example:</p> <pre><code>String[] ns = { \"banana\", \"apple\", \"pear\" };\n</code></pre> <p>Before sorting, this array is represented in memory as follows:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n               \u250c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n               \u2502   \u2502                      \u25bc           \u25bc\n         \u250c\u2500\u2500\u2500\u252c\u2500\u2534\u2500\u252c\u2500\u2534\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\nns \u2500\u2500\u2500\u2500\u2500\u25b6\u2502\u2591\u2591\u2591\u2502\u2591\u2591\u2591\u2502\u2591\u2591\u2591\u2502   \u2502\"banana\"\u2502   \u2502\"apple\"\u2502   \u2502\"pear\"\u2502   \u2502\n         \u2514\u2500\u252c\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n           \u2502                 \u25b2\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>After calling <code>Arrays.sort(ns);</code> sort, this array is represented in memory as follows:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n               \u250c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                       \u2502\n               \u2502   \u2502          \u25bc                       \u25bc\n         \u250c\u2500\u2500\u2500\u252c\u2500\u2534\u2500\u252c\u2500\u2534\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\nns \u2500\u2500\u2500\u2500\u2500\u25b6\u2502\u2591\u2591\u2591\u2502\u2591\u2591\u2591\u2502\u2591\u2591\u2591\u2502   \u2502\"banana\"\u2502   \u2502\"apple\"\u2502   \u2502\"pear\"\u2502   \u2502\n         \u2514\u2500\u252c\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n           \u2502                              \u25b2\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>None of the original 3 strings changed in memory, but each element of the <code>ns</code> array pointed to a change.</p>"},{"location":"20-quick-start/50-array-op/20-sort/#exercise","title":"Exercise","text":"<p>Think about how to implement a descending sort of an array:</p> <pre><code>// \u964d\u5e8f\u6392\u5e8f\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] ns = { 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 };\n        // \u6392\u5e8f\u524d:\n        System.out.println(Arrays.toString(ns));\n        // TODO:\n        // \u6392\u5e8f\u540e:\n        System.out.println(Arrays.toString(ns));\n        if (Arrays.toString(ns).equals(\"[96, 89, 73, 65, 50, 36, 28, 18, 12, 8]\")) {\n            System.out.println(\"\u6d4b\u8bd5\u6210\u529f\");\n        } else {\n            System.out.println(\"\u6d4b\u8bd5\u5931\u8d25\");\n        }\n    }\n}\n</code></pre> <p>Download exercise</p>"},{"location":"20-quick-start/50-array-op/20-sort/#summary","title":"Summary","text":"<p>Commonly used sorting algorithms are bubble sort, insertion sort and quick sort;</p> <p>Bubble sort uses a two-level <code>for</code> loop to implement the sort;</p> <p>Swapping the values of two variables requires the help of a temporary variable;</p> <p>Sorting can be done directly using <code>Arrays.sort()</code> provided by the Java standard library;</p> <p>Sorting an array directly modifies the array itself.</p>"},{"location":"20-quick-start/50-array-op/30-multi-dim/","title":"Multidimensional Arrays","text":""},{"location":"20-quick-start/50-array-op/30-multi-dim/#multidimensional-arrays","title":"Multidimensional arrays","text":""},{"location":"20-quick-start/50-array-op/30-multi-dim/#a-two-dimensional-array","title":"A two-dimensional array","text":"<p>A two-dimensional array is an array of arrays. Define a two-dimensional array as follows:</p> <pre><code>// \u4e8c\u7ef4\u6570\u7ec4\npublic class Main {\n    public static void main(String[] args) {\n        int[][] ns = {\n            { 1, 2, 3, 4 },\n            { 5, 6, 7, 8 },\n            { 9, 10, 11, 12 }\n        };\n        System.out.println(ns.length); // 3\n    }\n}\n</code></pre> <p>Since <code>ns</code> contains 3 arrays, <code>ns.length</code> is <code>3</code>. In fact <code>ns</code> has the following structure in memory:</p> <pre><code>\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n         \u250c\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u25b6\u2502 1 \u2502 2 \u2502 3 \u2502 4 \u2502\nns \u2500\u2500\u2500\u2500\u2500\u25b6\u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n         \u251c\u2500\u2500\u2500\u2524      \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n         \u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 5 \u2502 6 \u2502 7 \u2502 8 \u2502\n         \u251c\u2500\u2500\u2500\u2524      \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n         \u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n         \u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u25b6\u2502 9 \u250210 \u250211 \u250212 \u2502\n                    \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>If we define an ordinary array <code>arr0</code> and assign <code>ns[0]</code> to it:</p> <pre><code>// \u4e8c\u7ef4\u6570\u7ec4\npublic class Main {\n    public static void main(String[] args) {\n        int[][] ns = {\n            { 1, 2, 3, 4 },\n            { 5, 6, 7, 8 },\n            { 9, 10, 11, 12 }\n        };\n        int[] arr0 = ns[0];\n        System.out.println(arr0.length); // 4\n    }\n}\n</code></pre> <p>In effect <code>arr0</code> takes the 0th element of the <code>ns</code> array. Since each element of the <code>ns</code> array is also an array, the array that <code>arr0</code> points to is <code>{ 1, 2, 3, 4 }</code>. In memory, the structure is as follows:</p> <pre><code>arr0 \u2500\u2500\u2500\u2500\u2500\u2510\n                      \u25bc\n                    \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n         \u250c\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u25b6\u2502 1 \u2502 2 \u2502 3 \u2502 4 \u2502\nns \u2500\u2500\u2500\u2500\u2500\u25b6\u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n         \u251c\u2500\u2500\u2500\u2524      \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n         \u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 5 \u2502 6 \u2502 7 \u2502 8 \u2502\n         \u251c\u2500\u2500\u2500\u2524      \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n         \u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n         \u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u25b6\u2502 9 \u250210 \u250211 \u250212 \u2502\n                    \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>Accessing an element of a two-dimensional array requires the use of <code>array[row][col]</code>, for example:</p> <pre><code>System.out.println(ns[1][2]); // 7\n</code></pre> <p>The length of each array element of a two-dimensional array is not required to be the same; for example, an <code>ns</code> array can be defined this way:</p> <pre><code>int[][] ns = {\n    { 1, 2, 3, 4 },\n    { 5, 6 },\n    { 7, 8, 9 }\n};\n</code></pre> <p>The structure of this two-dimensional array in memory is as follows:</p> <pre><code>\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n         \u250c\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u25b6\u2502 1 \u2502 2 \u2502 3 \u2502 4 \u2502\nns \u2500\u2500\u2500\u2500\u2500\u25b6\u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n         \u251c\u2500\u2500\u2500\u2524      \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n         \u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 5 \u2502 6 \u2502\n         \u251c\u2500\u2500\u2500\u2524      \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n         \u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n         \u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u25b6\u2502 7 \u2502 8 \u2502 9 \u2502\n                    \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>To print a two-dimensional array, use a two-level nested for loop:</p> <pre><code>for (int[] arr : ns) {\n    for (int n : arr) {\n        System.out.print(n);\n        System.out.print(', ');\n    }\n    System.out.println();\n}\n</code></pre> <p>Or use <code>Arrays.deepToString()</code> from the Java standard library:</p> <pre><code>// \u4e8c\u7ef4\u6570\u7ec4\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] ns = {\n            { 1, 2, 3, 4 },\n            { 5, 6 },\n            { 7, 8, 9 }\n        };\n        System.out.println(Arrays.deepToString(ns));\n    }\n}\n</code></pre>"},{"location":"20-quick-start/50-array-op/30-multi-dim/#three-dimensional-arrays","title":"Three-dimensional arrays","text":"<p>A three-dimensional array is an array of two-dimensional arrays. A three-dimensional array can be defined this way:</p> <pre><code>int[][][] ns = {\n    {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    },\n    {\n        {10, 11},\n        {12, 13}\n    },\n    {\n        {14, 15, 16},\n        {17, 18}\n    }\n};\n</code></pre> <p>Its structure in memory is as follows:</p> <pre><code>\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n                   \u250c\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u25b6\u2502 1 \u2502 2 \u2502 3 \u2502\n               \u250c\u2500\u2500\u25b6\u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n               \u2502   \u251c\u2500\u2500\u2500\u2524      \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n               \u2502   \u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 4 \u2502 5 \u2502 6 \u2502\n               \u2502   \u251c\u2500\u2500\u2500\u2524      \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n               \u2502   \u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n        \u250c\u2500\u2500\u2500\u2510  \u2502   \u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u25b6\u2502 7 \u2502 8 \u2502 9 \u2502\nns \u2500\u2500\u2500\u2500\u25b6\u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2518              \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n        \u251c\u2500\u2500\u2500\u2524      \u250c\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n        \u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u250210 \u250211 \u2502\n        \u251c\u2500\u2500\u2500\u2524      \u251c\u2500\u2500\u2500\u2524      \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n        \u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2510   \u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n        \u2514\u2500\u2500\u2500\u2518  \u2502   \u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u25b6\u250212 \u250213 \u2502\n               \u2502              \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n               \u2502   \u250c\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n               \u2514\u2500\u2500\u25b6\u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u250214 \u250215 \u250216 \u2502\n                   \u251c\u2500\u2500\u2500\u2524      \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n                   \u2502\u2591\u2591\u2591\u2502\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n                   \u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u25b6\u250217 \u250218 \u2502\n                              \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>If we want to access an element of a three-dimensional array, for example, <code>ns[2][0][1]</code>, we just need to follow the localization to find the corresponding final element <code>15</code>.</p> <p>Theoretically, we can define arbitrary N-dimensional arrays. However, in practice, higher dimensional arrays are seldom used, except for two-dimensional arrays which are still useful at some point.</p>"},{"location":"20-quick-start/50-array-op/30-multi-dim/#exercise","title":"Exercise","text":"<p>Using a two-dimensional array you can represent the grades of a group of students in each subject, calculate the average score of all the students:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        // \u7528\u4e8c\u7ef4\u6570\u7ec4\u8868\u793a\u7684\u5b66\u751f\u6210\u7ee9:\n        int[][] scores = {\n                { 82, 90, 91 }, // \u5b66\u751f\u7532\u7684\u8bed\u6570\u82f1\u6210\u7ee9\n                { 68, 72, 64 }, // \u5b66\u751f\u4e59\u7684\u8bed\u6570\u82f1\u6210\u7ee9\n                { 95, 91, 89 }, // ...\n                { 67, 52, 60 },\n                { 79, 81, 85 },\n        };\n        // TODO:\n        double average = 0;\n        System.out.println(average);\n        if (Math.abs(average - 77.733333) &lt; 0.000001) {\n            System.out.println(\"\u6d4b\u8bd5\u6210\u529f\");\n        } else {\n            System.out.println(\"\u6d4b\u8bd5\u5931\u8d25\");\n        }\n    }\n}\n</code></pre> <p>Download exercise</p>"},{"location":"20-quick-start/50-array-op/30-multi-dim/#summary","title":"Summary","text":"<p>A two-dimensional array is an array of arrays, and a three-dimensional array is an array of two-dimensional arrays;</p> <p>Each array element of a multidimensional array is not required to be the same length;</p> <p>Printing multidimensional arrays can be done using <code>Arrays.deepToString()</code>;</p> <p>The most common multidimensional arrays are two-dimensional arrays, and accessing an element of a two-dimensional array uses <code>array[row][col]</code>.</p>"},{"location":"20-quick-start/50-array-op/40-args/","title":"Command Line Arguments","text":""},{"location":"20-quick-start/50-array-op/40-args/#command-line-arguments","title":"Command line arguments","text":"<p>The entry point to a Java program is the <code>main</code> method, and the <code>main</code> method can take a command-line argument, which is a <code>String[]</code> array.</p> <p>This command line argument is taken by the JVM as user input and passed to the <code>main</code> method:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        for (String arg : args) {\n            System.out.println(arg);\n        }\n    }\n}\n</code></pre> <p>We can use the received command line arguments to execute different code depending on the arguments. For example, implement a <code>-version</code> parameter that prints the program version number:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        for (String arg : args) {\n            if (\"-version\".equals(arg)) {\n                System.out.println(\"v 1.0\");\n                break;\n            }\n        }\n    }\n}\n</code></pre> <p>This program above must be executed at the command line, so let's compile it first:</p> <pre><code>$ javac Main.java\n</code></pre> <p>Then, when executed, pass it a <code>-version</code> parameter:</p> <pre><code>$ java Main -version\nv 1.0\n</code></pre> <p>This allows the program to respond differently depending on the incoming command line arguments.</p>"},{"location":"20-quick-start/50-array-op/40-args/#summary","title":"Summary","text":"<p>The type of the command line argument is a <code>String[]</code> array;</p> <p>Command line arguments are received by the JVM as user input and passed to the <code>main</code> method;</p> <p>How to parse command line arguments needs to be implemented by the program itself.</p>"},{"location":"30-oop/","title":"Index","text":""},{"location":"30-oop/#object-oriented-programming","title":"Object-oriented programming","text":"<p>Java is an object-oriented programming language. Object-Oriented Programming, in English, is Object-Oriented Programming, or OOP for short.</p> <p>So what is object-oriented programming?</p> <p>Different from object-oriented programming is process-oriented programming. Procedure-oriented programming, is breaking down the model into a step-by-step process. For example, if your boss tells you to write a TODO task, you must follow these steps step by step:</p> <ol> <li>reading documents;</li> <li>writing the TODO;</li> <li>saving the file.</li> </ol> <p></p> <p>And with object-oriented programming, as the name suggests, you have to have an object in the first place:</p> <p></p> <p>Once you have an object, you can interact with it:</p> <pre><code>GirlFriend gf = new GirlFriend();\ngf.name = \"Alice\";\ngf.send(\"flowers\");\n</code></pre> <p>Object-oriented programming, therefore, is a programming method that maps the real world to a computer model by means of objects.</p> <p>In this chapter, we will discuss:</p> <p>Basic object-oriented concepts, including:</p> <ul> <li>Class</li> <li>Instance</li> <li>Methods</li> </ul> <p>Object-oriented implementations, including:</p> <ul> <li>Inheritance</li> <li>Polymorphism</li> </ul> <p>The Java language itself provides mechanisms, including:</p> <ul> <li>package</li> <li>classpath</li> <li>jar</li> </ul> <p>and the core classes provided by the Java Standard Library, including:</p> <ul> <li>String</li> <li>Packaged types</li> <li>JavaBean</li> <li>Enumerations</li> <li>Common utility classes</li> </ul> <p>By the end of this chapter, it is entirely possible to understand and master the basic ideas of object orientation, but there is no guarantee that you will be able to find objects.</p> <p></p>"},{"location":"30-oop/10-basic/","title":"Overview","text":""},{"location":"30-oop/10-basic/#object-oriented-fundamentals","title":"Object-oriented fundamentals","text":"<p>Object-oriented programming, a programming method that maps the real world to a computer model by means of objects.</p> <p>In the real world, we define the abstract concept of \"human being\", and the concrete human being is a specific person such as \"Xiaoming\", \"Xiaohong\", \"Xiaojun\" and so on. \"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\" and other concrete people. Therefore, \"person\" can be defined as a class, and concrete people are instances:</p> Real World Computer Modeling Java code People Classes / class class Person { } Xiao Ming Instances / ming Person ming = new Person() Instances / hong Person hong = new Person() Instances / jun Person jun = new Person() <p>Similarly, the \"book\" is an abstraction, so it is the class, while \"Java Core Technology\", \"Java Programming Ideas\", \"Java Study Notes\" are examples:</p> Real World Computer Modeling Java code Book Classes / class class Book { } Java Core Technology Examples / book1 Book book1 = new Book() Java Programming Ideas Examples / book2 Book book2 = new Book() Java Learning Notes Examples / book3 Book book3 = new Book()"},{"location":"30-oop/10-basic/#class-and-instance","title":"class and instance","text":"<p>So, once you understand the concepts of class and instance, you basically understand what object-oriented programming is.</p> <p>A class is an object template that defines how instances are created, and as such, the class itself is a data type:</p> <p></p> <p>Whereas instance is an object instance, instance is an instance created according to class, multiple instances can be created, each of the same type, but the respective properties may not be the same:</p> <p></p>"},{"location":"30-oop/10-basic/#define-class","title":"Define class","text":"<p>In Java, creating a class, for example, naming the class <code>Person</code>, is defining a <code>class</code>:</p> <pre><code>class Person {\n    public String name;\n    public int age;\n}\n</code></pre> <p>A <code>class</code> can contain multiple fields (<code>fields</code>) which are used to characterize a class. In the <code>Person</code> class above, we defined two fields, one of type <code>String</code> named <code>name</code> and one of type <code>int</code> named <code>age</code>. Thus, with <code>class</code>, data encapsulation is achieved by bringing together a set of data into a single object.</p> <p><code>public</code> is used to qualify a field, which indicates that the field can be accessed externally.</p> <p>Let's look at another definition of the <code>Book</code> class:</p> <pre><code>class Book {\n    public String name;\n    public String author;\n    public String isbn;\n    public double price;\n}\n</code></pre> <p>Indicate the individual fields of the <code>Book</code> class.</p>"},{"location":"30-oop/10-basic/#creating-instances","title":"Creating instances","text":"<p>Defining a class only defines the object template, and to create a real object instance based on the object template, you must use the new operator.</p> <p>The new operator creates an instance, and then we need to define a variable of reference type to point to this instance:</p> <pre><code>Person ming = new Person();\n</code></pre> <p>The above code creates an instance of type Person and points to it via the variable <code>ming</code>.</p> <p>Note the distinction that <code>Person ming</code> defines the variable <code>ming</code> of type <code>Person</code>, while <code>new Person()</code> creates an instance of <code>Person</code>.</p> <p>With a variable pointing to this instance, we can manipulate the instance through this variable. Accessing instance variables can be done with <code>variable. Field</code>, for example:</p> <pre><code>ming.name = \"Xiao Ming\"; // \u5bf9\u5b57\u6bb5name\u8d4b\u503c\nming.age = 12; // \u5bf9\u5b57\u6bb5age\u8d4b\u503c\nSystem.out.println(ming.name); // \u8bbf\u95ee\u5b57\u6bb5name\n\nPerson hong = new Person();\nhong.name = \"Xiao Hong\";\nhong.age = 15;\n</code></pre> <p>The above two variables point to two different instances and their structure in memory is as follows:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nming \u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502Person instance   \u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n            \u2502name = \"Xiao Ming\"\u2502\n            \u2502age = 12          \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nhong \u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502Person instance   \u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n            \u2502name = \"Xiao Hong\"\u2502\n            \u2502age = 15          \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The two <code>instances</code> have the <code>name</code> and <code>age</code> fields defined by the <code>class</code>, and each has a separate copy of the data that does not interfere with each other.</p> <p>[!NOTICE]\u6ce8\u610f</p> <p>\u4e00\u4e2aJava\u6e90\u6587\u4ef6\u53ef\u4ee5\u5305\u542b\u591a\u4e2a\u7c7b\u7684\u5b9a\u4e49\uff0c\u4f46\u53ea\u80fd\u5b9a\u4e49\u4e00\u4e2apublic\u7c7b\uff0c\u4e14public\u7c7b\u540d\u5fc5\u987b\u4e0e\u6587\u4ef6\u540d\u4e00\u81f4\u3002\u5982\u679c\u8981\u5b9a\u4e49\u591a\u4e2apublic\u7c7b\uff0c\u5fc5\u987b\u62c6\u5230\u591a\u4e2aJava\u6e90\u6587\u4ef6\u4e2d\u3002</p>"},{"location":"30-oop/10-basic/#exercise","title":"Exercise","text":"<p>Please define a City class that has the following fields.</p> <ul> <li>name: name, type String</li> <li>latitude: latitude, type double</li> <li>longitude: longitude, type double</li> </ul> <p>Instantiate several Cities and assign values, then print.</p> <pre><code>// City\npublic class Main {\n    public static void main(String[] args) {\n        City bj = new City();\n        bj.name = \"Beijing\";\n        bj.latitude = 39.903;\n        bj.longitude = 116.401;\n        System.out.println(bj.name);\n        System.out.println(\"location: \" + bj.latitude + \", \" + bj.longitude);\n    }\n}\n\nclass City {\n    ???\n}\n</code></pre>"},{"location":"30-oop/10-basic/#summary","title":"Summary","text":"<p>In OOP, <code>class</code> and <code>instance</code> are the relationship between <code>template</code> and <code>instance</code>;</p> <p>To define <code>class</code> is to define a data type, and the corresponding <code>instance</code> is an instance of that data type;</p> <p>A <code>field</code> defined by a <code>class</code> will have its own <code>field</code> in each <code>instance</code> and will not interfere with each other;</p> <p>Create a new <code>instance</code> with the <code>new</code> operator and point to it with a variable to refer to the <code>instance</code> through the variable;</p> <p>Access to instance fields is <code>variable name. Field name</code>;</p> <p>Variables that point to <code>instance</code> are reference variables.</p>"},{"location":"30-oop/10-basic/10-method/","title":"Method","text":""},{"location":"30-oop/10-basic/10-method/#methods","title":"Methods","text":"<p>A <code>class</code> can contain more than one <code>field</code>, for example, we define two <code>fields</code> for the <code>Person</code> class:</p> <pre><code>class Person {\n    public String name;\n    public int age;\n}\n</code></pre> <p>However, exposing <code>field</code> directly to the outside with <code>public</code> may break encapsulation. For example, the code could be written like this:</p> <pre><code>Person ming = new Person();\nming.name = \"Xiao Ming\";\nming.age = -99; // age\u8bbe\u7f6e\u4e3a\u8d1f\u6570\n</code></pre> <p>Obviously, direct manipulation of <code>field</code> is likely to cause logical confusion. To prevent external code from accessing <code>field</code> directly, we can modify <code>field</code> with <code>private</code> to deny external access:</p> <pre><code>class Person {\n    private String name;\n    private int age;\n}\n</code></pre> <p>Try what effect <code>field</code> with the <code>private</code> modifier has:</p> <pre><code>// private field\npublic class Main {\n    public static void main(String[] args) {\n        Person ming = new Person();\n        ming.name = \"Xiao Ming\"; // \u5bf9\u5b57\u6bb5name\u8d4b\u503c\n        ming.age = 12; // \u5bf9\u5b57\u6bb5age\u8d4b\u503c\n    }\n}\n\nclass Person {\n    private String name;\n    private int age;\n}\n</code></pre> <p>Is it a compilation error? Remove the assignment statement that accesses <code>field</code> and it will compile fine.</p> <p></p> <p>Changing <code>field</code> from <code>public</code> to <code>private</code> prevents external code from accessing these <code>fields</code>, so what is the point of defining these <code>fields</code>? How can we assign a value to it? How can we read its value?</p> <p>So we need to use methods (<code>method</code>) to allow external code to modify <code>field</code> indirectly:</p> <pre><code>// private field\npublic class Main {\n    public static void main(String[] args) {\n        Person ming = new Person();\n        ming.setName(\"Xiao Ming\"); // \u8bbe\u7f6ename\n        ming.setAge(12); // \u8bbe\u7f6eage\n        System.out.println(ming.getName() + \", \" + ming.getAge());\n    }\n}\n\nclass Person {\n    private String name;\n    private int age;\n\n    public String getName() {\n        return this.name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return this.age;\n    }\n\n    public void setAge(int age) {\n        if (age &lt; 0 || age &gt; 100) {\n            throw new IllegalArgumentException(\"invalid age value\");\n        }\n        this.age = age;\n    }\n}\n</code></pre> <p>Although external code cannot modify the <code>private</code> field directly, external code can call the methods <code>setName()</code> and <code>setAge()</code> to modify the <code>private</code> field indirectly. Inside the methods, we then have the opportunity to check that the parameters are correct. For example, <code>setAge()</code> checks the incoming parameters, which are out of range and directly reports an error. This way, the external code doesn't have any chance to set <code>age</code> to an unreasonable value.</p> <p>The same checks can be made for the <code>setName()</code> method, e.g., disallowing <code>null</code> and empty strings from being passed in:</p> <pre><code>public void setName(String name) {\n    if (name == null || name.isBlank()) {\n        throw new IllegalArgumentException(\"invalid name\");\n    }\n    this.name = name.strip(); // \u53bb\u6389\u9996\u5c3e\u7a7a\u683c\n}\n</code></pre> <p>Similarly, external code cannot read the <code>private</code> field directly, but it can indirectly get the value of the <code>private</code> field through <code>getName()</code> and <code>getAge()</code>.</p> <p>So, by defining methods, a class exposes an interface to external code for some operations, while, at the same time, internally ensuring logical consistency itself.</p> <p>The syntax for calling a method is <code>Instance variable. Method name (parameters);</code>. A method call is a statement, so don't forget to add <code>;</code> to the end. For example: <code>ming.setName(\"Xiao Ming\");</code>.</p>"},{"location":"30-oop/10-basic/10-method/#define-the-method","title":"Define the method","text":"<p>As you can see from the code above, the syntax for defining a method is:</p> <pre><code>\u4fee\u9970\u7b26 \u65b9\u6cd5\u8fd4\u56de\u7c7b\u578b \u65b9\u6cd5\u540d(\u65b9\u6cd5\u53c2\u6570\u5217\u8868) {\n    \u82e5\u5e72\u65b9\u6cd5\u8bed\u53e5;\n    return \u65b9\u6cd5\u8fd4\u56de\u503c;\n}\n</code></pre> <p>Method return values are implemented via the <code>return</code> statement; <code>return</code> can be omitted if there is no return value and the return type is set to <code>void</code>.</p>"},{"location":"30-oop/10-basic/10-method/#private-methods","title":"Private methods","text":"<p>There are <code>public</code> methods, and naturally there are <code>private</code> methods. Like <code>private</code> fields, <code>private</code> methods do not allow external calls, so what is the point of defining <code>private</code> methods?</p> <p>The rationale for defining <code>private</code> methods is that it is possible for internal methods to call <code>private</code> methods. Example:</p> <pre><code>// private method\npublic class Main {\n    public static void main(String[] args) {\n        Person ming = new Person();\n        ming.setBirth(2008);\n        System.out.println(ming.getAge());\n    }\n}\n\nclass Person {\n    private String name;\n    private int birth;\n\n    public void setBirth(int birth) {\n        this.birth = birth;\n    }\n\n    public int getAge() {\n        return calcAge(2019); // \u8c03\u7528private\u65b9\u6cd5\n    }\n\n    // private\u65b9\u6cd5:\n    private int calcAge(int currentYear) {\n        return currentYear - this.birth;\n    }\n}\n</code></pre> <p>Observing the above code, <code>calcAge()</code> is a <code>private</code> method which cannot be called by external code, however, the internal method <code>getAge()</code> can call it.</p> <p>In addition, we note that this <code>Person</code> class only defines the <code>birth</code> field, not the <code>age</code> field, and that when getting the <code>age</code>, the method <code>getAge()</code> returns a value calculated in real time, not a value stored in a field. This suggests that methods can encapsulate the external interface of a class, and the caller does not need to know or care whether the <code>Person</code> instance has an <code>age</code> field internally or not.</p>"},{"location":"30-oop/10-basic/10-method/#this-variable","title":"this variable","text":"<p>Inside the method, an implicit variable <code>this</code> can be used, which always points to the current instance. Thus, the fields of the current instance can be accessed through <code>this.field</code>.</p> <p>If there are no naming conflicts, <code>this</code> can be omitted. Example:</p> <pre><code>class Person {\n    private String name;\n\n    public String getName() {\n        return name; // \u76f8\u5f53\u4e8ethis.name\n    }\n}\n</code></pre> <p>However, if there are local variables and fields that are renamed, then the local variables have higher priority and <code>this</code> must be added:</p> <pre><code>class Person {\n    private String name;\n\n    public void setName(String name) {\n        this.name = name; // \u524d\u9762\u7684this\u4e0d\u53ef\u5c11\uff0c\u5c11\u4e86\u5c31\u53d8\u6210\u5c40\u90e8\u53d8\u91cfname\u4e86\n    }\n}\n</code></pre>"},{"location":"30-oop/10-basic/10-method/#method-parameters","title":"Method parameters","text":"<p>Methods can contain 0 or any number of parameters. Method parameters are used to receive the values of variables passed to the method. When calling a method, the parameters must be passed one by one in strict accordance with their definitions. Example:</p> <pre><code>class Person {\n    ...\n    public void setNameAndAge(String name, int age) {\n        ...\n    }\n}\n</code></pre> <p>This <code>setNameAndAge()</code> method must be called with two parameters, and the first parameter must be a <code>String</code> and the second parameter must be an <code>int</code>:</p> <pre><code>Person ming = new Person();\nming.setNameAndAge(\"Xiao Ming\"); // \u7f16\u8bd1\u9519\u8bef\uff1a\u53c2\u6570\u4e2a\u6570\u4e0d\u5bf9\nming.setNameAndAge(12, \"Xiao Ming\"); // \u7f16\u8bd1\u9519\u8bef\uff1a\u53c2\u6570\u7c7b\u578b\u4e0d\u5bf9\n</code></pre>"},{"location":"30-oop/10-basic/10-method/#variable-parameters","title":"Variable parameters","text":"<p>Variable parameters are defined with <code>Type ...</code> is defined, and variable parameters are equivalent to array types:</p> <pre><code>class Group {\n    private String[] names;\n\n    public void setNames(String... names) {\n        this.names = names;\n    }\n}\n</code></pre> <p>The <code>setNames()</code> above defines a variable parameter. When called, it can be written like this:</p> <pre><code>Group g = new Group();\ng.setNames(\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"); // \u4f20\u51653\u4e2aString\ng.setNames(\"Xiao Ming\", \"Xiao Hong\"); // \u4f20\u51652\u4e2aString\ng.setNames(\"Xiao Ming\"); // \u4f20\u51651\u4e2aString\ng.setNames(); // \u4f20\u51650\u4e2aString\n</code></pre> <p>It is perfectly possible to rewrite variable parameters as <code>String[]</code> types:</p> <pre><code>class Group {\n    private String[] names;\n\n    public void setNames(String[] names) {\n        this.names = names;\n    }\n}\n</code></pre> <p>However, the caller needs to construct <code>String[]</code> by itself first, which is more cumbersome. Example:</p> <pre><code>Group g = new Group();\ng.setNames(new String[] {\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"}); // \u4f20\u51651\u4e2aString[]\n</code></pre> <p>Another issue is that the caller can pass in <code>null</code>:</p> <pre><code>Group g = new Group();\ng.setNames(null);\n</code></pre> <p>Variable parameters, on the other hand, guarantee that <code>null</code> cannot be passed in, since the actual value received when passing in 0 parameters is an empty array instead of <code>null</code>.</p>"},{"location":"30-oop/10-basic/10-method/#parameter-binding","title":"Parameter binding","text":"<p>When the caller passes parameters to an instance method, the values passed at the time of the call are bound one by one by the position of the parameters.</p> <p>So what is parameter binding?</p> <p>We start by observing the passing of a basic type parameter:</p> <pre><code>// \u57fa\u672c\u7c7b\u578b\u53c2\u6570\u7ed1\u5b9a\npublic class Main {\n    public static void main(String[] args) {\n        Person p = new Person();\n        int n = 15; // n\u7684\u503c\u4e3a15\n        p.setAge(n); // \u4f20\u5165n\u7684\u503c\n        System.out.println(p.getAge()); // 15\n        n = 20; // n\u7684\u503c\u6539\u4e3a20\n        System.out.println(p.getAge()); // 15\u8fd8\u662f20?\n    }\n}\n\nclass Person {\n    private int age;\n\n    public int getAge() {\n        return this.age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n</code></pre> <p>Running the code, it is clear from the results that modifying the external local variable <code>n</code> does not affect the <code>age</code> field of the instance <code>p</code>, because the parameter obtained by the <code>setAge()</code> method, replicates the value of <code>n</code>, and therefore, <code>p.age</code> and the local variable <code>n</code> do not affect each other.</p> <p>Conclusion: The passing of a basic type parameter is a copy of the caller's value. Subsequent modifications by each side do not affect each other.</p> <p>Let's look at another example of passing a reference parameter:</p> <pre><code>// \u5f15\u7528\u7c7b\u578b\u53c2\u6570\u7ed1\u5b9a\npublic class Main {\n    public static void main(String[] args) {\n        Person p = new Person();\n        String[] fullname = new String[] { \"Homer\", \"Simpson\" };\n        p.setName(fullname); // \u4f20\u5165fullname\u6570\u7ec4\n        System.out.println(p.getName()); // \"Homer Simpson\"\n        fullname[0] = \"Bart\"; // fullname\u6570\u7ec4\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u4fee\u6539\u4e3a\"Bart\"\n        System.out.println(p.getName()); // \"Homer Simpson\"\u8fd8\u662f\"Bart Simpson\"?\n    }\n}\n\nclass Person {\n    private String[] name;\n\n    public String getName() {\n        return this.name[0] + \" \" + this.name[1];\n    }\n\n    public void setName(String[] name) {\n        this.name = name;\n    }\n}\n</code></pre> <p>Notice that the argument to <code>setName()</code> is now an array. At first, passing the <code>fullname</code> array in, and then, modifying the contents of the <code>fullname</code> array, it turns out that the field <code>p.name</code> of the instance <code>p</code> has also been modified!</p> <p>[!NOTICE]\u7ed3\u8bba</p> <p>\u5f15\u7528\u7c7b\u578b\u53c2\u6570\u7684\u4f20\u9012\uff0c\u8c03\u7528\u65b9\u7684\u53d8\u91cf\uff0c\u548c\u63a5\u6536\u65b9\u7684\u53c2\u6570\u53d8\u91cf\uff0c\u6307\u5411\u7684\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\u3002\u53cc\u65b9\u4efb\u610f\u4e00\u65b9\u5bf9\u8fd9\u4e2a\u5bf9\u8c61\u7684\u4fee\u6539\uff0c\u90fd\u4f1a\u5f71\u54cd\u5bf9\u65b9\uff08\u56e0\u4e3a\u6307\u5411\u540c\u4e00\u4e2a\u5bf9\u8c61\u561b\uff09\u3002</p> <p>With the above conclusion in mind, let's look at another example:</p> <pre><code>// \u5f15\u7528\u7c7b\u578b\u53c2\u6570\u7ed1\u5b9a\npublic class Main {\n    public static void main(String[] args) {\n        Person p = new Person();\n        String bob = \"Bob\";\n        p.setName(bob); // \u4f20\u5165bob\u53d8\u91cf\n        System.out.println(p.getName()); // \"Bob\"\n        bob = \"Alice\"; // bob\u6539\u540d\u4e3aAlice\n        System.out.println(p.getName()); // \"Bob\"\u8fd8\u662f\"Alice\"?\n    }\n}\n\nclass Person {\n    private String name;\n\n    public String getName() {\n        return this.name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n</code></pre> <p>Don't doubt the mechanism of quoted parameter binding, try to explain why the above code outputs <code>\"Bob\"</code> twice.</p>"},{"location":"30-oop/10-basic/10-method/#exercise","title":"Exercise","text":"<p>Add <code>getAge</code>/<code>setAge</code> methods to the <code>Person</code> class:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        Person ming = new Person();\n        ming.setName(\"\u5c0f\u660e\");\n        ming.setAge(12);\n        System.out.println(ming.getAge());\n    }\n}\n\nclass Person {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n</code></pre> <p>Download exercise</p>"},{"location":"30-oop/10-basic/10-method/#summary","title":"Summary","text":"<ul> <li>Methods allow external code to securely access instance fields;</li> <li>methods are a set of executable statements and can execute arbitrary logic;</li> <li>methods internally return when they encounter a return, void means that they do not return any value (note that this is different from returning null);</li> <li>External code manipulates instances through public methods, and internal code can call private methods;</li> <li>Understanding parameter binding for methods.</li> </ul>"},{"location":"30-oop/10-basic/100-scope/","title":"Scope","text":""},{"location":"30-oop/10-basic/100-scope/#scope","title":"Scope","text":"<p>In Java, we often see the modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. In Java, these modifiers can be used to limit the access scope.</p>"},{"location":"30-oop/10-basic/100-scope/#public","title":"public","text":"<p>A <code>class</code>, <code>interface</code> defined as <code>public</code> can be accessed by any other class:</p> <pre><code>package abc;\n\npublic class Hello {\n    public void hi() {\n    }\n}\n</code></pre> <p>The <code>Hello</code> above is <code>public</code> and, therefore, can be accessed by classes in other packages:</p> <pre><code>package xyz;\n\nclass Main {\n    void foo() {\n        // Main\u53ef\u4ee5\u8bbf\u95eeHello\n        Hello h = new Hello();\n    }\n}\n</code></pre> <p>A <code>field</code>, <code>method</code> defined as <code>public</code> can be accessed by other classes, provided there is access to <code>class</code> first:</p> <pre><code>package abc;\n\npublic class Hello {\n    public void hi() {\n    }\n}\n</code></pre> <p>The <code>hi()</code> method above is <code>public</code> and can be called by other classes, provided that the <code>Hello</code> class is accessible first:</p> <pre><code>package xyz;\n\nclass Main {\n    void foo() {\n        Hello h = new Hello();\n        h.hi();\n    }\n}\n</code></pre>"},{"location":"30-oop/10-basic/100-scope/#private","title":"Private","text":"<p>A <code>field</code>, <code>method</code> defined as <code>private</code> cannot be accessed by other classes:</p> <pre><code>package abc;\n\npublic class Hello {\n    // \u4e0d\u80fd\u88ab\u5176\u4ed6\u7c7b\u8c03\u7528:\n    private void hi() {\n    }\n\n    public void hello() {\n        this.hi();\n    }\n}\n</code></pre> <p>In fact, precisely <code>private</code> access is restricted to the interior of the <code>class</code> and is irrelevant to the order in which the methods are declared. It is recommended to put <code>private</code> methods later, because <code>public</code> methods define the functionality that the class provides externally, and when reading the code, you should focus on <code>public</code> methods first:</p> <pre><code>package abc;\n\npublic class Hello {\n    public void hello() {\n        this.hi();\n    }\n\n    private void hi() {\n    }\n}\n</code></pre> <p>Since Java supports nested classes, if a nested class is also defined inside a class, the nested class has access to <code>private</code>:</p> <pre><code>// private\npublic class Main {\n    public static void main(String[] args) {\n        Inner i = new Inner();\n        i.hi();\n    }\n\n    // private\u65b9\u6cd5:\n    private static void hello() {\n        System.out.println(\"private hello!\");\n    }\n\n    // \u9759\u6001\u5185\u90e8\u7c7b:\n    static class Inner {\n        public void hi() {\n            Main.hello();\n        }\n    }\n}\n</code></pre> <p>A <code>class</code> defined inside a <code>class</code> is called a nested class, and Java supports several kinds of nested classes.</p>"},{"location":"30-oop/10-basic/100-scope/#protected","title":"protected","text":"<p><code>protected</code> acts on inheritance relationships. Fields and methods defined as <code>protected</code> can be accessed by subclasses, as well as subclasses of subclasses:</p> <pre><code>package abc;\n\npublic class Hello {\n    // protected\u65b9\u6cd5:\n    protected void hi() {\n    }\n}\n</code></pre> <p>The <code>protected</code> method above can be accessed by inherited classes:</p> <pre><code>package xyz;\n\nclass Main extends Hello {\n    void foo() {\n        // \u53ef\u4ee5\u8bbf\u95eeprotected\u65b9\u6cd5:\n        hi();\n    }\n}\n</code></pre>"},{"location":"30-oop/10-basic/100-scope/#package","title":"package","text":"<p>Finally, package scope means that a class is allowed to access the same <code>package</code>'s <code>class</code> without the <code>public</code>, <code>private</code> modifiers, as well as fields and methods without the <code>public</code>, <code>protected</code>, and <code>private</code> modifiers.</p> <pre><code>package abc;\n// package\u6743\u9650\u7684\u7c7b:\nclass Hello {\n    // package\u6743\u9650\u7684\u65b9\u6cd5:\n    void hi() {\n    }\n}\n</code></pre> <p>Access to <code>class</code>, <code>field</code> and <code>method</code> with <code>package</code> permissions, as long as they are in the same package:</p> <pre><code>package abc;\n\nclass Main {\n    void foo() {\n        // \u53ef\u4ee5\u8bbf\u95eepackage\u6743\u9650\u7684\u7c7b:\n        Hello h = new Hello();\n        // \u53ef\u4ee5\u8c03\u7528package\u6743\u9650\u7684\u65b9\u6cd5:\n        h.hi();\n    }\n}\n</code></pre> <p>Note that package names must be identical, packages have no parent-child relationship, <code>com.apache</code> and <code>com.apache.abc</code> are different packages.</p>"},{"location":"30-oop/10-basic/100-scope/#local-variables","title":"Local variables","text":"<p>Variables defined inside a method are called local variables, and the local variable scope begins at the variable declaration and ends at the corresponding block. Method parameters are also local variables.</p> <pre><code>package abc;\n\npublic class Hello {\n    void hi(String name) { // 1\n        String s = name.toLowerCase(); // 2\n        int len = s.length(); // 3\n        if (len &lt; 10) { // 4\n            int p = 10 - len; // 5\n            for (int i=0; i&lt;10; i++) { // 6\n                System.out.println(); // 7\n            } // 8\n        } // 9\n    } // 10\n}\n</code></pre> <p>Let's observe the <code>hi()</code> method code above:</p> <ul> <li>The method parameter name is a local variable whose scope is the entire method, i.e., 1 ~ 10;</li> <li>The variable s is scoped from the point of definition to the end of the method, i.e. 2 ~ 10;</li> <li>The scope of the variable len is from the definition to the end of the method, i.e. 3 ~ 10;</li> <li>The scope of variable p is from the definition to the end of the if block, i.e. 5 ~ 9;</li> <li>The scope of variable i is the for loop, i.e. 6 ~ 8.</li> </ul> <p>When using local variables, you should keep the scope of local variables as small as possible and delay declaring local variables as long as possible.</p>"},{"location":"30-oop/10-basic/100-scope/#final","title":"final","text":"<p>Java also provides a <code>final</code> modifier. <code>final</code> does not conflict with access rights; it serves many purposes.</p> <p>Modifying <code>class</code> with <code>final</code> prevents it from being inherited:</p> <pre><code>package abc;\n\n// \u65e0\u6cd5\u88ab\u7ee7\u627f:\npublic final class Hello {\n    private int n = 0;\n    protected void hi(int t) {\n        long i = t;\n    }\n}\n</code></pre> <p>Modifying <code>method</code> with <code>final</code> prevents it from being overridden by subclasses:</p> <pre><code>package abc;\n\npublic class Hello {\n    // \u65e0\u6cd5\u88ab\u8986\u5199:\n    protected final void hi() {\n    }\n}\n</code></pre> <p>Modifying <code>field</code> with <code>final</code> prevents it from being reassigned:</p> <pre><code>package abc;\n\npublic class Hello {\n    private final int n = 0;\n    protected void hi() {\n        this.n = 1; // error!\n    }\n}\n</code></pre> <p>Modifying a local variable with <code>final</code> prevents it from being reassigned:</p> <pre><code>package abc;\n\npublic class Hello {\n    protected void hi(final int t) {\n        t = 1; // error!\n    }\n}\n</code></pre>"},{"location":"30-oop/10-basic/100-scope/#best-practices","title":"Best practices","text":"<p>If you're not sure if <code>public</code> is needed, don't declare it as <code>public</code>, i.e. expose as few external fields and methods as possible.</p> <p>Defining methods with <code>package</code> permissions helps with testing because test code can access <code>package</code> permission methods of the tested class as long as the test class and the tested class are located on the same <code>package</code>.</p> <p>A <code>.java</code> file can contain only one <code>public</code> class, but can contain multiple non-<code>public</code> classes. If there is a <code>public</code> class, the file name must be the same as the name of the <code>public</code> class.</p>"},{"location":"30-oop/10-basic/100-scope/#summary","title":"Summary","text":"<p>Java's built-in access permissions include <code>public</code>, <code>protected</code>, <code>private</code>, and <code>package</code> permissions;</p> <p>Variables defined by Java inside a method are local variables, and the scope of a local variable begins with the variable declaration and ends with a block;</p> <p>The <code>final</code> modifier is not an access permission; it can modify <code>class</code>, <code>field</code>, and <code>method</code>;</p> <p>A <code>.java</code> file can contain only one <code>public</code> class, but can contain multiple non-<code>public</code> classes.</p>"},{"location":"30-oop/10-basic/110-inner-class/","title":"Inner Class","text":""},{"location":"30-oop/10-basic/110-inner-class/#internal-classes","title":"Internal classes","text":"<p>In Java programs, usually, we organize different classes under different packages, and for the classes under a package, they are at the same level and have no parent-child relationship:</p> <pre><code>java.lang\n\u251c\u2500\u2500 Math\n\u251c\u2500\u2500 Runnable\n\u251c\u2500\u2500 String\n\u2514\u2500\u2500 ...\n</code></pre> <p>There is also a class that is defined inside another class, so it is called the internal class (Nested Class).Java's internal classes are divided into several types, usually not used much, but it is necessary to understand how they are used.</p>"},{"location":"30-oop/10-basic/110-inner-class/#inner-class","title":"Inner Class","text":"<p>If a class is defined inside another class, that class is an Inner Class:</p> <pre><code>class Outer {\n    class Inner {\n        // \u5b9a\u4e49\u4e86\u4e00\u4e2aInner Class\n    }\n}\n</code></pre> <p>The above definition of <code>Outer</code> is an ordinary class, and <code>Inner</code> is an Inner Class, it has a big difference with the ordinary class, that is, Inner Class instances can not exist alone, must be dependent on an instance of Outer Class. Sample code is as follows:</p> <pre><code>// inner class\npublic class Main {\n    public static void main(String[] args) {\n        Outer outer = new Outer(\"Nested\"); // \u5b9e\u4f8b\u5316\u4e00\u4e2aOuter\n        Outer.Inner inner = outer.new Inner(); // \u5b9e\u4f8b\u5316\u4e00\u4e2aInner\n        inner.hello();\n    }\n}\n\nclass Outer {\n    private String name;\n\n    Outer(String name) {\n        this.name = name;\n    }\n\n    class Inner {\n        void hello() {\n            System.out.println(\"Hello, \" + Outer.this.name);\n        }\n    }\n}\n</code></pre> <p>Observing the above code, to instantiate an <code>Inner</code>, we must first create an instance of <code>Outer</code> and then, call <code>new</code> on the <code>Outer</code> instance to create the <code>Inner</code> instance:</p> <pre><code>Outer.Inner inner = outer.new Inner();\n</code></pre> <p>This is because the Inner Class, in addition to having a <code>this</code> pointing to itself, implicitly holds an Outer Class instance, which can be accessed with <code>Outer.this</code>. So, instantiating an Inner Class cannot be detached from the Outer instance.</p> <p>Inner Class has an extra \"privilege\" compared to normal Class, except that it can refer to Outer instances, that is, it can modify the <code>private</code> field of Outer Class, because the scope of Inner Class is inside Outer Class, so it can access the <code>private</code> field and methods of Outer Class. Because Inner Class is scoped inside Outer Class, it can access <code>private</code> fields and methods of Outer Class.</p> <p>Looking at the <code>.class</code> file compiled by the Java compiler you can see that the <code>Outer</code> class is compiled as <code>Outer.class</code> and the <code>Inner</code> class is compiled as <code>Outer$Inner.class</code>.</p>"},{"location":"30-oop/10-basic/110-inner-class/#anonymous-class","title":"Anonymous Class","text":"<p>There is another way to define Inner Class, it does not need to explicitly define this Class in Outer Class, but inside the method, through the anonymous class (Anonymous Class) to define. The example code is as follows:</p> <pre><code>// Anonymous Class\npublic class Main {\n    public static void main(String[] args) {\n        Outer outer = new Outer(\"Nested\");\n        outer.asyncHello();\n    }\n}\n\nclass Outer {\n    private String name;\n\n    Outer(String name) {\n        this.name = name;\n    }\n\n    void asyncHello() {\n        Runnable r = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"Hello, \" + Outer.this.name);\n            }\n        };\n        new Thread(r).start();\n    }\n}\n</code></pre> <p>Observing the <code>asyncHello()</code> method, we instantiate a <code>Runnable</code> inside the method. <code>Runnable</code> itself is an interface, and interfaces can't be instantiated, so here you are actually defining an anonymous class that implements the <code>Runnable</code> interface and instantiating that anonymous class via <code>new</code>, which then transforms to <code>Runnable</code>. You have to instantiate the anonymous class when you define it, and defining an anonymous class is written as follows:</p> <pre><code>Runnable r = new Runnable() {\n    // \u5b9e\u73b0\u5fc5\u8981\u7684\u62bd\u8c61\u65b9\u6cd5...\n};\n</code></pre> <p>Anonymous Classes, like Inner Classes, have access to the <code>private</code> fields and methods of Outer Classes. The reason why we define an anonymous class is because we usually don't care about the class name here, and we can write a lot less code than if we define the Inner Class directly.</p> <p>Looking at the <code>.class</code> file compiled by the Java compiler you can see that the <code>Outer</code> class is compiled as <code>Outer.class</code> and the anonymous class is compiled as <code>Outer$1.class</code>. If there is more than one anonymous class, the Java compiler names each anonymous class <code>Outer$1</code>, <code>Outer$2</code>, <code>Outer$3</code> in turn ......</p> <p>In addition to interfaces, anonymous classes are perfectly capable of inheriting from normal classes. Observe the following code:</p> <pre><code>// Anonymous Class\nimport java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        HashMap&lt;String, String&gt; map1 = new HashMap&lt;&gt;();\n        HashMap&lt;String, String&gt; map2 = new HashMap&lt;&gt;() {}; // \u533f\u540d\u7c7b!\n        HashMap&lt;String, String&gt; map3 = new HashMap&lt;&gt;() {\n            {\n                put(\"A\", \"1\");\n                put(\"B\", \"2\");\n            }\n        };\n        System.out.println(map3.get(\"A\"));\n    }\n}\n</code></pre> <p><code>map1</code> is a normal <code>HashMap</code> instance, but <code>map2</code> is an anonymous class instance, except that the anonymous class inherits from <code>HashMap</code>. <code>map3</code> is also an instance of an anonymous class that inherits from <code>HashMap</code> and adds a <code>static</code> block to initialize the data. Observing the compilation output reveals two anonymous class files, <code>Main$1.class</code> and <code>Main$2.class</code>.</p>"},{"location":"30-oop/10-basic/110-inner-class/#static-nested-class","title":"Static Nested Class","text":"<p>The last type of inner class is similar to Inner Class but uses the <code>static</code> modifier and is called Static Nested Class:</p> <pre><code>// Static Nested Class\npublic class Main {\n    public static void main(String[] args) {\n        Outer.StaticNested sn = new Outer.StaticNested();\n        sn.hello();\n    }\n}\n\nclass Outer {\n    private static String NAME = \"OUTER\";\n\n    private String name;\n\n    Outer(String name) {\n        this.name = name;\n    }\n\n    static class StaticNested {\n        void hello() {\n            System.out.println(\"Hello, \" + Outer.NAME);\n        }\n    }\n}\n</code></pre> <p>An inner class modified with <code>static</code> is very different from an Inner Class in that it is no longer dependent on an instance of <code>Outer</code>, but is a completely separate class, and therefore cannot reference <code>Outer.this</code>, but it does have access to <code>private</code> static fields and static methods of <code>Outer</code>. If you move <code>StaticNested</code> outside of <code>Outer</code>, you lose access to <code>private</code>.</p>"},{"location":"30-oop/10-basic/110-inner-class/#summary","title":"Summary","text":"<p>Java's internal classes can be categorized into Inner Class, Anonymous Class and Static Nested Class;</p> <p>Inner Class and Anonymous Class are essentially the same, both must be dependent on an instance of Outer Class, i.e., implicitly hold an instance of <code>Outer.this</code> and have <code>private</code> access to Outer Class;</p> <p>Static Nested Class is a standalone class, but has the <code>private</code> access of Outer Class.</p>"},{"location":"30-oop/10-basic/120-classpath-jar/","title":"Classpath & JAR","text":""},{"location":"30-oop/10-basic/120-classpath-jar/#classpath-and-jar","title":"classpath and jar","text":"<p>In Java, we often hear about <code>classpath</code>. There are a lot of articles on the web about <code>how to set the classpath</code>, but most of the settings are not reliable.</p> <p>What exactly is <code>classpath</code>?</p> <p><code>classpath</code> is an environment variable used by the JVM to instruct the JVM how to search for <code>class</code>.</p> <p>Because Java is a compiled language, the source code file is <code>.java</code>, and the compiled <code>.class</code> file is the actual bytecode that can be executed by the JVM. Therefore, the JVM needs to know where to search for the corresponding <code>Hello.class</code> file if it wants to load an <code>abc.xyz.Hello</code> class.</p> <p>So, <code>classpath</code> is a collection of directories that sets a search path related to the operating system. For example, on Windows, directories separated by <code>;</code> and with spaces enclosed in <code>\"\"</code> might look like this:</p> <pre><code>C:\\work\\project1\\bin;C:\\shared;\"D:\\My Documents\\project1\\bin\"\n</code></pre> <p>On a Linux system, separated by <code>:</code>, it might look like this:</p> <pre><code>/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin\n</code></pre> <p>Now let's assume that the <code>classpath</code> is <code>. ;C:\\work\\project1\\bin;C:\\shared</code>, and when the JVM loads the class <code>abc.xyz.Hello</code>, it looks for it in turn:</p> <ul> <li>\\abc\\xyz\\Hello.class <li>C:\\work\\project1\\bin\\abc\\xyz\\Hello.class</li> <li>C:\\shared\\abc\\xyz\\Hello.class</li> <p>Notice that <code>.</code> represents the current directory. If the JVM finds the corresponding <code>class</code> file under a certain path, it doesn't search further back. If it doesn't find it in any of the paths, it reports an error.</p> <p>There are two ways to set <code>classpath</code>:</p> <p>Setting the <code>classpath</code> environment variable in the system environment variable is not recommended;</p> <p>Setting the <code>classpath</code> variable when starting the JVM is recommended.</p> <p>We strongly don't recommend setting <code>classpath</code> in the system environment variable, as that will pollute the entire system environment. Setting the <code>classpath</code> when starting the JVM is the recommended practice. This actually means passing the <code>-classpath</code> parameter to the <code>java</code> command:</p> <pre><code>java -classpath .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello\n</code></pre> <p>Or use the <code>-cp</code> shorthand:</p> <pre><code>java -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello\n</code></pre> <p>No system environment variables are set and no <code>-cp</code> parameter is passed in, then the JVM default <code>classpath</code> is <code>.</code>, which is the current directory:</p> <pre><code>java abc.xyz.Hello\n</code></pre> <p>The above command tells the JVM to search for <code>Hello.class</code> only in the current directory.</p> <p>To run a Java program in the IDE, the <code>-cp</code> parameter automatically passed in by the IDE is the <code>bin</code> directory of the current project and the introduced jar package.</p> <p>Often, in <code>class</code>s we write ourselves, we refer to <code>class</code>s from the core Java library, e.g. <code>String</code>, <code>ArrayList</code>, etc. Where should we find these <code>class</code>s?</p> <p>There are a lot of \"how to set classpath\" articles that will tell you to put the JVM's own <code>rt.jar</code> into the <code>classpath</code>, but in fact, there's no need to tell the JVM how to look for the <code>class</code> in the core Java libraries, and how can the JVM be so stupid as to not know where its own core libraries are! How can the JVM be so stupid that it doesn't even know where its core libraries are?</p> <p>[!WARNING]\u6ce8\u610f</p> <p>\u4e0d\u8981\u628a\u4efb\u4f55Java\u6838\u5fc3\u5e93\u6dfb\u52a0\u5230classpath\u4e2d\uff01JVM\u6839\u672c\u4e0d\u4f9d\u8d56classpath\u52a0\u8f7d\u6838\u5fc3\u5e93\uff01</p> <p>Better yet, don't set <code>classpath</code>! The default current directory <code>.</code> is sufficient for the vast majority of cases.</p> <p>Assuming we have a compiled <code>Hello.class</code> with package name <code>com.example</code> and current directory <code>C:\\work</code>, the directory structure must be as follows:</p> <pre><code>C:\\work\n\u2514\u2500 com\n   \u2514\u2500 example\n      \u2514\u2500 Hello.class\n</code></pre> <p>To run this <code>Hello.class</code> you must use the following command in the current directory:</p> <pre><code>C:\\work&gt; java -cp . com.example.Hello\n</code></pre> <p>The JVM looks for <code>com.example.Hello</code> in the current directory based on the classpath setting of <code>.</code> in the current directory for <code>com.example.Hello</code>, i.e. the actual search file must be located in <code>com/example/Hello.class</code>. If the specified <code>.class</code> file does not exist, or if the directory structure and package name do not match, an error will be reported.</p>"},{"location":"30-oop/10-basic/120-classpath-jar/#jar-package","title":"jar package","text":"<p>Having a lot of <code>.class</code> files scattered in various levels of directories is certainly not easy to manage. It would be much easier if the directories could be packaged into a single file.</p> <p>The jar package is used to do this, and it takes the directory hierarchy of the <code>package</code> organization, as well as all the files in each directory (including <code>.class</code> files and others) and breaks them into a single jar file, which makes it much simpler to either back up or send to a client.</p> <p>A jar package is actually a compressed file in zip format, and a jar package is equivalent to a directory. If we want to execute the <code>class</code> of a jar package, we can put the jar package in the <code>classpath</code>:</p> <pre><code>java -cp ./hello.jar abc.xyz.Hello\n</code></pre> <p>This way the JVM will automatically go searching for a class in the <code>hello.jar</code> file.</p> <p>So here's the question: how do you create jar packages?</p> <p>Because the jar package is a zip package, so, directly in Explorer, find the correct directory, right-click, in the pop-up shortcut menu, select \"Send to\", \"zipped\" folder \"to make a zip file. Then, change the extension from <code>.zip</code> to <code>.jar</code> and a jar package is created.</p> <p>Suppose the directory structure of the compiled output looks like this:</p> <pre><code>package_sample\n\u2514\u2500 bin\n   \u251c\u2500 hong\n   \u2502  \u2514\u2500 Person.class\n   \u2502  ming\n   \u2502  \u2514\u2500 Person.class\n   \u2514\u2500 mr\n      \u2514\u2500 jun\n         \u2514\u2500 Arrays.class\n</code></pre> <p>The first directory in the jar package should not be <code>bin</code>, but <code>hong</code>, <code>ming</code>, <code>mr</code>. If you look at it in Windows Explorer, it should look like this:</p> <p></p> <p>If it looks like this:</p> <p></p> <p>The <code>hello.zip</code> above contains the <code>bin</code> directory, which means that the packaging was typed incorrectly, and the JVM still can't look up the correct <code>class</code> from the jar package, because the <code>hong.Person</code> must be stored as <code>hong/Person.class</code>, not <code>bin/hong/Person.class</code>.</p> <p>The jar package can also contain a special <code>/META-INF/MANIFEST.MF</code> file. <code>MANIFEST.MF</code> is plain text and can be specified with <code>Main-Class</code> and other information. the JVM automatically reads this <code>MANIFEST.MF</code> file, and if the <code>Main-Class</code> is present, we don't have to specify the name of the startup class on the If <code>Main-Class</code> exists, we don't have to specify the startup class name on the command line, but use a more convenient command:</p> <pre><code>java -jar hello.jar\n</code></pre> <p>In large projects, it is not possible to manually write <code>MANIFEST.MF</code> files and then manually create jar packages. the Java community provides a large number of open source build tools, such as [Maven] (... /... /... /maven/index.html), which can create jar packages very easily.</p>"},{"location":"30-oop/10-basic/120-classpath-jar/#summary","title":"Summary","text":"<p>The JVM determines the path and order in which it searches for <code>class</code> through the environment variable <code>classpath</code>;</p> <p>It is strongly recommended not to set the **system environment variable <code>classpath</code> and it is recommended to always pass it in via the <code>-cp</code> command;</p> <p>A jar package is essentially a zip format, the equivalent of a directory, and can contain many <code>.class</code> files for easy downloading and use;</p> <p>The <code>MANIFEST.MF</code> file can provide information about the jar package, such as <code>Main-Class</code>, so that the jar package can be run directly.</p>"},{"location":"30-oop/10-basic/130-class-version/","title":"Class Version","text":""},{"location":"30-oop/10-basic/130-class-version/#class-version","title":"class version","text":"<p>In Java development, many children's shoes are often confused by various versions of the JDK, this section we will explain in detail the Java program compiled class file version of the problem.</p> <p>By Java 8, Java 11, and Java 17, we usually mean the version of the JDK, which is the version of the JVM, or more specifically, the version of the program <code>java.exe</code>:</p> <pre><code>$ java -version\njava version \"17\" 2021-09-14 LTS\n</code></pre> <p>And each version of the JVM, it can be executed by a different version of the class file. For example, Java 11 corresponds to class file version 55, while Java 17 corresponds to class file version 61.</p> <p>If you compile a Java program with Java 11, the output class file version is 55 by default, and this class can run on both Java 11 and Java 17, because Java 17 supports class file version 61, which means \"up to version 61 is supported. \".</p> <p>If you compile a Java program with Java 17, the output class file version is 61 by default, which will run on Java 17, Java 18, but not on Java 11, which supports class versions up to 55. If you run it with a JVM lower than Java 17, you will get an <code>UnsupportedClassVersionError</code> with a similar error message:</p> <pre><code>java.lang.UnsupportedClassVersionError: Xxx has been compiled by a more recent version of the Java Runtime...\n</code></pre> <p>As soon as you see <code>UnsupportedClassVersionError</code> it means that the current version of the class file to be loaded exceeds the capacity of the JVM and a higher version of the JVM must be used in order to run.</p> <p>Let's say you save a Word file with Word 2013, this file can also be opened on Word 2016. But on the flip side, save a Word file with Word 2016 and it won't open with Word 2013.</p> <p>But wait, with Word 2016 can also save a file formatted as Word 2013, so that the saved Word file can be opened with a lower version of Word 2013, but only if the save must explicitly specify the file format compatible with Word 2013.</p> <p>Similarly, corresponding to the JVM class file, we can also compile a Java program with Java 17, specifying that the output class version should be compatible with Java 11 (i.e., class version 55), so that the compiled class file can be run in a Java &gt;= 11 environment.</p> <p>There are two ways to specify the compilation output, one is to set it on the <code>javac</code> command line with the parameter <code>--release</code>:</p> <pre><code>$ javac --release 11 Main.java\n</code></pre> <p>The <code>--release 11</code> parameter indicates that the source code is Java 11 compatible and the output version of the compiled class is Java 11 compatible, i.e., class version 55.</p> <p>The second way is to specify the source version with the argument <code>-source</code> and the output class version with the argument <code>-target</code>:</p> <pre><code>$ javac --source 9 --target 11 Main.java\n</code></pre> <p>If the above command is compiled with the Java 17 JDK, it will treat the source as Java 9 compliant and output the class as Java 11 compliant. Note that the <code>--release</code> parameter and the <code>--source --target</code> parameter can only be set to one or the other, not both.</p> <p>However, there are some potential problems with specifying a version that is lower than the current JDK version. For example, we compile <code>Hello.java</code> with Java 17, with the parameters <code>-source 9</code> and <code>-target 11</code>:</p> <pre><code>public class Hello {\n    public static void hello(String name) {\n        System.out.println(\"hello\".indent(4));\n    }\n}\n</code></pre> <p>Running <code>Hello</code> with a JVM lower than Java 11 gets a <code>LinkageError</code> because the <code>Hello.class</code> file cannot be loaded, and running <code>Hello</code> with Java 11 gets a <code>NoSuchMethodError</code> because the <code>String.indent()</code> method was added from Java 12, and the <code>String</code> version of Java 11 doesn't have an <code>indent()</code> method at all.</p> <p>[!NOTICE]\u6ce8\u610f</p> <p>\u5982\u679c\u4f7f\u7528--release 11\u5219\u4f1a\u5728\u7f16\u8bd1\u65f6\u68c0\u67e5\u8be5\u65b9\u6cd5\u662f\u5426\u5728Java 11\u4e2d\u5b58\u5728\u3002</p> <p>Therefore, if the version of the JVM at runtime is Java 11, it is also better to use Java 11 at compile time, rather than compiling with a higher version of the JDK to output a lower version of the class.</p> <p>If you use <code>javac</code> to compile without specifying any version parameter, it is equivalent to compiling with <code>--release current version</code>, i.e., both the source and output versions are current.</p> <p>During the development phase, multiple versions of the JDK can be installed at the same time, and the version of the JDK currently in use can be switched by the <code>JAVA_HOME</code> environment variable.</p>"},{"location":"30-oop/10-basic/130-class-version/#source-code-version","title":"Source code version","text":"<p>When writing source code, we usually preset a source version. When compiling, if the source version is specified with <code>-source</code> or <code>-release</code>, the specified source version checking syntax is used.</p> <p>For example, source versions with lambda expressions must be at least 8 to compile, source versions with the <code>var</code> keyword must be at least 10 to compile, source versions with <code>switch</code> expressions must be at least 12 to compile, and the <code>--enable-preview</code> parameter needs to be enabled for versions 12 and 13.</p>"},{"location":"30-oop/10-basic/130-class-version/#summary","title":"Summary","text":"<p>Higher versions of the JDK can compile and output class files compatible with lower versions, but note that lower versions of the JDK may not have classes and methods added by higher versions of the JDK, resulting in runtime errors.</p> <p>Use whichever JDK version you use at runtime, and try to compile the source code with the same version of the JDK at compile time.</p>"},{"location":"30-oop/10-basic/140-module/","title":"Module","text":""},{"location":"30-oop/10-basic/140-module/#modules","title":"Modules","text":"<p>Starting with Java 9, the JDK has introduced modules (Module).</p> <p>What are modules? It starts with versions prior to Java 9.</p> <p>As we know, <code>.class</code> file is the smallest executable file seen by the JVM, and a large program needs to write a lot of Class and generate a bunch of <code>.class</code> files, which is very unmanageable, so the <code>jar</code> file is a container for <code>class</code> files.</p> <p>Prior to Java 9, a large Java program would generate its own jar file, while referencing dependent third-party jar files, and the Java standard library that comes with the JVM is actually stored in the form of a jar file called <code>rt.jar</code>, which is more than 60M in total.</p> <p>If you are developing your own program, you need a bunch of third-party jar packages in addition to an <code>app.jar</code> of your own to run a Java program, and in general, the command line writes like this:</p> <pre><code>java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main\n</code></pre> <p>[!WARNING]\u6ce8\u610f</p> <p>JVM\u81ea\u5e26\u7684\u6807\u51c6\u5e93rt.jar\u4e0d\u8981\u5199\u5230classpath\u4e2d\uff0c\u5199\u4e86\u53cd\u800c\u4f1a\u5e72\u6270JVM\u7684\u6b63\u5e38\u8fd0\u884c\u3002</p> <p>If you leave out a jar that is required at runtime, it is highly likely that a <code>ClassNotFoundException</code> will be thrown at runtime.</p> <p>So, a jar is just a container for classes, it doesn't care about dependencies between classes.</p> <p>Modules have been introduced since Java 9, mainly to solve the problem of \"dependencies\". If <code>a.jar</code> must depend on another <code>b.jar</code> in order to run, then we should add some description to <code>a.jar</code>, so that the program can automatically locate <code>b.jar</code> when compiling and running, this kind of class container with \"dependency\" is a module.</p> <p>In a sign of Java's commitment to modularity, starting with Java 9, the original Java standard library has been split from a single, huge <code>rt.jar</code> into dozens of modules, identified by the <code>.jmod</code> extension, which can be found in the <code>$JAVA_HOME/jmods</code> directory:</p> <ul> <li>java.base.jmod</li> <li>java.compiler.jmod</li> <li>java.datatransfer.jmod</li> <li>java.desktop.jmod</li> <li>...</li> </ul> <p>Each of these <code>.jmod</code> files is a module, and the module name is the file name. For example, the file corresponding to the module <code>java.base</code> is <code>java.base.jmod</code>. Dependencies between modules are written to the <code>module-info.class</code> file within the module. All modules depend directly or indirectly on <code>java.base</code>, only <code>java.base</code> module does not depend on any module, it can be regarded as the \"root module\", as if all classes are inherited directly or indirectly from <code>Object</code>.</p> <p>Packaging a bunch of classes into a jar is just a packaging process, while packaging a bunch of classes into a module requires not only packaging, but also writing dependencies, and can also contain binary code (usually JNI extensions). In addition, modules support multiple versions, that is, in the same module can provide different versions for different JVMs.</p>"},{"location":"30-oop/10-basic/140-module/#writing-modules","title":"Writing modules","text":"<p>So, how should we write modules? Or take a concrete example. First of all, creating a module is exactly the same as the original creation of a Java project, take the <code>oop-module</code> project as an example, it has the following directory structure:</p> <pre><code>oop-module\n\u251c\u2500\u2500 bin\n\u251c\u2500\u2500 build.sh\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 com\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 itranswarp\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 sample\n    \u2502\u00a0\u00a0         \u251c\u2500\u2500 Greeting.java\n    \u2502\u00a0\u00a0         \u2514\u2500\u2500 Main.java\n    \u2514\u2500\u2500 module-info.java\n</code></pre> <p>The <code>bin</code> directory holds the compiled class files, the <code>src</code> directory holds the source code, which is stored according to the directory structure of the package name, and just under the <code>src</code> directory, there is an extra file <code>module-info.java</code>, which is the description file of the module. In this module, it looks like this:</p> <pre><code>module hello.world {\n    requires java.base; // \u53ef\u4e0d\u5199\uff0c\u4efb\u4f55\u6a21\u5757\u90fd\u4f1a\u81ea\u52a8\u5f15\u5165java.base\n    requires java.xml;\n}\n</code></pre> <p>Where <code>module</code> is the keyword, followed by <code>hello.world</code> is the name of the module, which follows the package naming convention. The <code>requires xxx;</code> in parentheses indicates other module names that this module needs to reference. In addition to <code>java.base</code> which can be automatically introduced, here we introduce a <code>java.xml</code> module.</p> <p>The introduced module can be used only when we have declared dependencies using the module. For example, <code>Main.java</code> code is as follows:</p> <pre><code>package com.itranswarp.sample;\n\n// \u5fc5\u987b\u5f15\u5165java.xml\u6a21\u5757\u540e\u624d\u80fd\u4f7f\u7528\u5176\u4e2d\u7684\u7c7b:\nimport javax.xml.XMLConstants;\n\npublic class Main {\n    public static void main(String[] args) {\n        Greeting g = new Greeting();\n        System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));\n    }\n}\n</code></pre> <p>If you remove <code>requires java.xml;</code> from <code>module-info.java</code>, the compilation will report an error. As you can see, the important role of modules is to declare dependencies.</p> <p>Below, we compile and create the module using the command line tools provided by the JDK.</p> <p>First, we switch our working directory to <code>oop-module</code> and compile all the <code>.java</code> files in the current directory and store them in the <code>bin</code> directory with the following command:</p> <pre><code>$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java\n</code></pre> <p>If the compilation is successful, the project structure is now as follows:</p> <pre><code>oop-module\n\u251c\u2500\u2500 bin\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 com\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 itranswarp\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 sample\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 Greeting.class\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 Main.class\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 module-info.class\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 com\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 itranswarp\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 sample\n    \u2502\u00a0\u00a0         \u251c\u2500\u2500 Greeting.java\n    \u2502\u00a0\u00a0         \u2514\u2500\u2500 Main.java\n    \u2514\u2500\u2500 module-info.java\n</code></pre> <p>Notice that <code>module-info.java</code> in the <code>src</code> directory is compiled to <code>module-info.class</code> in the <code>bin</code> directory.</p> <p>Next, we need to package all the class files in the bin directory into a jar first, and while doing so, take care to pass in the <code>-main-class</code> parameter so that the jar package can locate the class where the <code>main</code> method is on its own:</p> <pre><code>$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .\n</code></pre> <p>Now we've got the <code>hello.jar</code> jar package in the current directory, which is no different from a regular jar package, and you can run it directly with the command <code>java -jar hello.jar</code>. But our goal is to create modules, so go ahead and use the <code>jmod</code> command that comes with the JDK to convert a jar package into a module:</p> <pre><code>$ jmod create --class-path hello.jar hello.jmod\n</code></pre> <p>So, in the current directory we get the module file <code>hello.jmod</code> again, which is the legendary module that is finally packaged!</p>"},{"location":"30-oop/10-basic/140-module/#run-the-module","title":"Run the module","text":"<p>To run a jar, we use the <code>java -jar xxx.jar</code> command. To run a module, we just specify the module name. Try:</p> <pre><code>$ java --module-path hello.jmod --module hello.world\n</code></pre> <p>It turned out to be a mistake:</p> <pre><code>Error occurred during initialization of boot layer\njava.lang.module.FindException: JMOD format not supported at execution time: hello.jmod\n</code></pre> <p>The reason is that <code>.jmod</code> cannot be put into <code>-module-path</code>. Replace it with <code>.jar</code> and you'll be fine:</p> <pre><code>$ java --module-path hello.jar --module hello.world\nHello, xml!\n</code></pre> <p>So what's the use of <code>hello.jmod</code> that we worked so hard to create? The answer is that we can use it to package the JRE.</p>"},{"location":"30-oop/10-basic/140-module/#package-the-jre","title":"Package the JRE","text":"<p>As mentioned earlier, in order to support modularity, Java 9 first took the lead in splitting its one gigantic <code>rt.jar</code> into dozens of <code>.jmod</code> modules, the reason being that, when running a Java program, there aren't really that many JDK modules that we use. Modules that you don't need can be deleted.</p> <p>In the past, to publish a Java application, to run it, you must download a complete JRE, and then run the jar package. The full JRE is a huge chunk, more than 100 M. How to slim down the JRE?</p> <p>Now that the JRE's own standard library has been split into modules, only the modules used by the program need to be brought along, and the rest can be trimmed away. How to cut the JRE? Instead of removing some of the modules from the JRE installed on your system, you can make a copy of the JRE, but only with the modules you need. To do this, the JDK provides the <code>jlink</code> command. The command is as follows:</p> <pre><code>$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/\n</code></pre> <p>We specify our own module <code>hello.jmod</code> in the <code>-module-path</code> parameter, and then, in the <code>--add-modules</code> parameter, we specify the three modules we use <code>java.base</code>, <code>java.xml</code> and <code>hello.world</code>, separated by <code>,</code>. Finally, the output directory is specified in the <code>--output</code> parameter.</p> <p>Now, in the current directory, we can find the <code>jre</code> directory, which is a complete JRE with our own <code>hello.jmod</code> module. try running this JRE directly:</p> <pre><code>$ jre/bin/java --module hello.world\nHello, xml!\n</code></pre> <p>To distribute our own Java applications, we just need to make a package of the <code>jre</code> directory and send it to the other party, and the other party can directly run the above commands, without having to download and install the JDK or know how to configure our own modules, which greatly facilitates distribution and deployment.</p>"},{"location":"30-oop/10-basic/140-module/#access-rights","title":"Access rights","text":"<p>As we said earlier, Java's class access rights are divided into public, protected, private and the default package access rights. After the introduction of the module, the rules of these access rights should be slightly adjusted.</p> <p>To be precise, these access rights for classes are only valid within a module, module to module, e.g., for module a to have access to a certain class in module b, the necessary condition is that module b explicitly exports packages that can be accessed.</p> <p>As an example: the module <code>hello.world</code> that we wrote uses a class <code>javax.xml.XMLConstants</code> from module <code>java.xml</code>, and we are able to use this class directly because of a number of exports declared in <code>module-info.java</code> of module <code>java.xml</code>:</p> <pre><code>module java.xml {\n    exports java.xml;\n    exports javax.xml.catalog;\n    exports javax.xml.datatype;\n    ...\n}\n</code></pre> <p>External code is only allowed access if it declares an exported package. In other words, if external code wants to access the <code>com.itranswarp.sample.Greeting</code> class in our <code>hello.world</code> module, we must export it:</p> <pre><code>module hello.world {\n    exports com.itranswarp.sample;\n\n    requires java.base;\n    requires java.xml;\n}\n</code></pre> <p>Thus, the module further isolates access to the code.</p>"},{"location":"30-oop/10-basic/140-module/#exercise","title":"Exercise","text":"<p>Please download and practice how to package modules and JREs.</p> <p>Download Exercise</p>"},{"location":"30-oop/10-basic/140-module/#summary","title":"Summary","text":"<p>The purpose of modules introduced in Java 9 is to manage dependencies;</p> <p>JREs can be packaged on demand using modules;</p> <p>Access to classes is further restricted using modules.</p>"},{"location":"30-oop/10-basic/20-constructor/","title":"Constructor","text":""},{"location":"30-oop/10-basic/20-constructor/#constructor","title":"Constructor","text":"<p>When creating an instance, we often need to initialize the fields of this instance at the same time, for example:</p> <pre><code>Person ming = new Person();\nming.setName(\"\u5c0f\u660e\");\nming.setAge(12);\n</code></pre> <p>It takes 3 lines of code to initialize an object instance, and, if you forget to call <code>setName()</code> or <code>setAge()</code>, the state inside this instance is incorrect.</p> <p>Is it possible to initialize all internal fields to the appropriate values as soon as the object instance is created?</p> <p>Totally.</p> <p>This is where we need constructor methods.</p> <p>When creating an instance, the instance is actually initialized by a constructor method. We'll start by defining a constructor method that can be initialized by passing in <code>name</code> and <code>age</code> at once when creating an instance of <code>Person</code>:</p> <pre><code>// \u6784\u9020\u65b9\u6cd5\npublic class Main {\n    public static void main(String[] args) {\n        Person p = new Person(\"Xiao Ming\", 15);\n        System.out.println(p.getName());\n        System.out.println(p.getAge());\n    }\n}\n\nclass Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n\n    public int getAge() {\n        return this.age;\n    }\n}\n</code></pre> <p>Since constructor methods are so special, the name of the constructor method is the class name. There is no restriction on the parameters of a constructor method, and inside the method, arbitrary statements can be written. However, in contrast to normal methods, constructor methods have no return value (and no <code>void</code>), and to call a constructor method, you must use the <code>new</code> operator.</p>"},{"location":"30-oop/10-basic/20-constructor/#default-constructor","title":"Default constructor","text":"<p>Does any <code>class</code> have a constructor method? Yes.</p> <p>So why can we call <code>new Person()</code> when we didn't write a constructor for the <code>Person</code> class earlier?</p> <p>The reason for this is that if a class doesn't define a constructor method, the compiler automatically generates a default constructor method for us, which has no parameters and no execution statement, something like this:</p> <pre><code>class Person {\n    public Person() {\n    }\n}\n</code></pre> <p>In particular, note that if we customize a constructor method, then the compiler no longer automatically creates the default constructor method:</p> <pre><code>// \u6784\u9020\u65b9\u6cd5\npublic class Main {\n    public static void main(String[] args) {\n        Person p = new Person(); // \u7f16\u8bd1\u9519\u8bef:\u627e\u4e0d\u5230\u8fd9\u4e2a\u6784\u9020\u65b9\u6cd5\n    }\n}\n\nclass Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n\n    public int getAge() {\n        return this.age;\n    }\n}\n</code></pre> <p>If you want to be able to use the constructor with parameters but also want to keep the constructor without parameters, then you can only define both constructors:</p> <pre><code>// \u6784\u9020\u65b9\u6cd5\npublic class Main {\n    public static void main(String[] args) {\n        Person p1 = new Person(\"Xiao Ming\", 15); // \u65e2\u53ef\u4ee5\u8c03\u7528\u5e26\u53c2\u6570\u7684\u6784\u9020\u65b9\u6cd5\n        Person p2 = new Person(); // \u4e5f\u53ef\u4ee5\u8c03\u7528\u65e0\u53c2\u6570\u6784\u9020\u65b9\u6cd5\n    }\n}\n\nclass Person {\n    private String name;\n    private int age;\n\n    public Person() {\n    }\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n\n    public int getAge() {\n        return this.age;\n    }\n}\n</code></pre> <p>When fields are not initialized in the constructor method, fields of reference types default to <code>null</code>, fields of numeric types use default values, <code>int</code> types default to <code>0</code>, and boolean types default to <code>false</code>:</p> <pre><code>class Person {\n    private String name; // \u9ed8\u8ba4\u521d\u59cb\u5316\u4e3anull\n    private int age; // \u9ed8\u8ba4\u521d\u59cb\u5316\u4e3a0\n\n    public Person() {\n    }\n}\n</code></pre> <p>Fields can also be initialized directly:</p> <pre><code>class Person {\n    private String name = \"Unamed\";\n    private int age = 10;\n}\n</code></pre> <p>So here's the problem: both initializing the field and initializing the field in the constructor method:</p> <pre><code>class Person {\n    private String name = \"Unamed\";\n    private int age = 10;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n</code></pre> <p>When we create an object, <code>new Person(\"Xiao Ming\", 12)</code> gets an instance of the object, what are the initial values of the fields?</p> <p>In Java, object instances are initialized in the following order when they are created:</p> <ol> <li>Initialize the fields first, e.g., <code>int age = 10;</code> means that the field is initialized to <code>10</code>, <code>double salary;</code> means that the field is initialized to <code>0</code> by default, and <code>String s;</code> means that the field of reference type is initialized to <code>null</code> by default;</li> <li>Execute the code of the constructor method for initialization.</li> </ol> <p>Therefore, the code of the constructor method is run later, so the field values of <code>new Person(\"Xiao Ming\", 12)</code> are ultimately determined by the code of the constructor method.</p>"},{"location":"30-oop/10-basic/20-constructor/#multiple-constructors","title":"Multiple constructors","text":"<p>Multiple constructor methods can be defined, and when invoked via the <code>new</code> operator, the compiler automatically distinguishes them by the number, position, and type of the constructor's arguments:</p> <pre><code>class Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public Person(String name) {\n        this.name = name;\n        this.age = 12;\n    }\n\n    public Person() {\n    }\n}\n</code></pre> <p>If you call <code>new Person(\"Xiao Ming\", 20);</code>, it will automatically match to the constructor <code>public Person(String, int)</code>.</p> <p>If you call <code>new Person(\"Xiao Ming\");</code>, it will automatically match to the constructor <code>public Person(String)</code>.</p> <p>If <code>new Person();</code> is called, it will automatically match to the constructor <code>public Person()</code>.</p> <p>A constructor method can call other constructor methods; this is done to facilitate code reuse. The syntax for calling other constructor methods is <code>this(...)</code>:</p> <pre><code>class Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public Person(String name) {\n        this(name, 18); // \u8c03\u7528\u53e6\u4e00\u4e2a\u6784\u9020\u65b9\u6cd5Person(String, int)\n    }\n\n    public Person() {\n        this(\"Unnamed\"); // \u8c03\u7528\u53e6\u4e00\u4e2a\u6784\u9020\u65b9\u6cd5Person(String)\n    }\n}\n</code></pre>"},{"location":"30-oop/10-basic/20-constructor/#exercise","title":"Exercise","text":"<p>Please add <code>(String, int)</code> constructor to <code>Person</code> class:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        // TODO: \u7ed9Person\u589e\u52a0\u6784\u9020\u65b9\u6cd5:\n        Person ming = new Person(\"\u5c0f\u660e\", 12);\n        System.out.println(ming.getName());\n        System.out.println(ming.getAge());\n    }\n}\n\nclass Person {\n    private String name;\n    private int age;\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n</code></pre> <p>Download exercise</p>"},{"location":"30-oop/10-basic/20-constructor/#summary","title":"Summary","text":"<p>Instances are created with the <code>new</code> operator by calling their corresponding constructor methods, which are used to initialize the instance;</p> <p>When no constructor is defined, the compiler automatically creates a default parameterless constructor;</p> <p>Multiple constructor methods can be defined, and the compiler automatically determines them based on the parameters;</p> <p>It is possible to call another constructor method inside a constructor method, which facilitates code reuse.</p>"},{"location":"30-oop/10-basic/30-overload/","title":"Overload","text":""},{"location":"30-oop/10-basic/30-overload/#method-overloading","title":"Method overloading","text":"<p>In a class, we can define more than one method. If there is a set of methods, which are all similar in function and differ only in their parameters, then the set of method names can be made into _same_methods. For example, in the <code>Hello</code> class, define multiple <code>hello()</code> methods:</p> <pre><code>class Hello {\n    public void hello() {\n        System.out.println(\"Hello, world!\");\n    }\n\n    public void hello(String name) {\n        System.out.println(\"Hello, \" + name + \"!\");\n    }\n\n    public void hello(String name, int age) {\n        if (age &lt; 18) {\n            System.out.println(\"Hi, \" + name + \"!\");\n        } else {\n            System.out.println(\"Hello, \" + name + \"!\");\n        }\n    }\n}\n</code></pre> <p>Such methods with the same name, but with different arguments for each, are called method overloads (<code>Overload</code>).</p> <p>Note: The return value types of method overloads are usually the same.</p> <p>The purpose of method overloading is that methods with similar functionality use the same name and are easier to remember and, therefore, simpler to call.</p> <p>As an example, the <code>String</code> class provides several overloaded methods, <code>indexOf()</code>, to find substrings:</p> <ul> <li><code>int indexOf(int ch)</code>: lookup based on the Unicode code of the character;</li> <li><code>int indexOf(String str)</code>: lookup based on string;</li> <li><code>int indexOf(int ch, int fromIndex)</code>: lookup based on character, but specify start position;</li> <li><code>int indexOf(String str, int fromIndex)</code>: lookup by string, but specify start position.</li> </ul> <p>Try it:</p> <pre><code>// String.indexOf()\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"Test string\";\n        int n1 = s.indexOf('t');\n        int n2 = s.indexOf(\"st\");\n        int n3 = s.indexOf(\"st\", 4);\n        System.out.println(n1);\n        System.out.println(n2);\n        System.out.println(n3);\n    }\n}\n</code></pre>"},{"location":"30-oop/10-basic/30-overload/#exercise","title":"Exercise","text":"<p>Add overloaded method <code>setName(String, String)</code> to <code>Person</code>:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        Person ming = new Person();\n        Person hong = new Person();\n        ming.setName(\"Xiao Ming\");\n        // TODO: \u7ed9Person\u589e\u52a0\u91cd\u8f7d\u65b9\u6cd5setName(String, String):\n        hong.setName(\"Xiao\", \"Hong\");\n        System.out.println(ming.getName());\n        System.out.println(hong.getName());\n    }\n}\n\nclass Person {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n</code></pre> <p>Download Exercise</p>"},{"location":"30-oop/10-basic/30-overload/#summary","title":"Summary","text":"<p>Method overloading is when multiple methods have the same method name, but each has different parameters;</p> <p>Overloaded methods should accomplish similar functionality, cf. <code>indexOf()</code> for <code>String</code>;</p> <p>Overloaded methods should have the same return value type.</p>"},{"location":"30-oop/10-basic/40-inherit/","title":"Inherit","text":""},{"location":"30-oop/10-basic/40-inherit/#inheritance","title":"Inheritance","text":"<p>In the previous sections, we have defined the <code>Person</code> class:</p> <pre><code>class Person {\n    private String name;\n    private int age;\n\n    public String getName() {...}\n    public void setName(String name) {...}\n    public int getAge() {...}\n    public void setAge(int age) {...}\n}\n</code></pre> <p>Now, suppose you need to define a <code>Student</code> class with the following fields:</p> <pre><code>class Student {\n    private String name;\n    private int age;\n    private int score;\n\n    public String getName() {...}\n    public void setName(String name) {...}\n    public int getAge() {...}\n    public void setAge(int age) {...}\n    public int getScore() { \u2026 }\n    public void setScore(int score) { \u2026 }\n}\n</code></pre> <p>A closer look reveals that the <code>Student</code> class contains the fields and methods already present in the <code>Person</code> class, except for an extra <code>score</code> field and the corresponding <code>getScore()</code> and <code>setScore()</code> methods.</p> <p>Can you not write duplicate code in <code>Student</code>?</p> <p>This is when inheritance comes in handy.</p> <p>Inheritance is a very powerful mechanism in object-oriented programming that allows for reusing code in the first place. When we let <code>Student</code> inherit from <code>Person</code>, <code>Student</code> gets all the functionality of <code>Person</code>, and we only need to write the additional functionality for <code>Student</code>.</p> <p>Java uses the <code>extends</code> keyword to implement inheritance:</p> <pre><code>class Person {\n    private String name;\n    private int age;\n\n    public String getName() {...}\n    public void setName(String name) {...}\n    public int getAge() {...}\n    public void setAge(int age) {...}\n}\n\nclass Student extends Person {\n    // \u4e0d\u8981\u91cd\u590dname\u548cage\u5b57\u6bb5/\u65b9\u6cd5,\n    // \u53ea\u9700\u8981\u5b9a\u4e49\u65b0\u589escore\u5b57\u6bb5/\u65b9\u6cd5:\n    private int score;\n\n    public int getScore() { \u2026 }\n    public void setScore(int score) { \u2026 }\n}\n</code></pre> <p>As you can see, with inheritance, <code>Student</code> only needs to write additional functionality and no longer needs to duplicate code.</p> <p>[!WARNING]\u6ce8\u610f</p> <p>\u5b50\u7c7b\u81ea\u52a8\u83b7\u5f97\u4e86\u7236\u7c7b\u7684\u6240\u6709\u5b57\u6bb5\uff0c\u4e25\u7981\u5b9a\u4e49\u4e0e\u7236\u7c7b\u91cd\u540d\u7684\u5b57\u6bb5\uff01</p> <p>In OOP terminology, we refer to <code>Person</code> as super class, parent class, base class and <code>Student</code> as subclass, extended class.</p>"},{"location":"30-oop/10-basic/40-inherit/#succession-tree","title":"Succession tree","text":"<p>Notice that we didn't write <code>extends</code> when we defined <code>Person</code>. In Java, classes that don't explicitly write <code>extends</code>, the compiler automatically adds <code>extends Object</code>. So, any class, except <code>Object</code>, inherits from some class. The following figure shows the inheritance tree for <code>Person</code>, <code>Student</code>:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Object   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n      \u25b2\n      \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Person   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n      \u25b2\n      \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Student  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Java only allows a class to inherit from a class, so a class has one and only one parent. Only <code>Object</code> is special in that it has no parent class.</p> <p>Similarly, if we define a <code>Teacher</code> that inherits from <code>Person</code>, their inheritance tree relationship is as follows:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502  Object   \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u25b2\n             \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502  Person   \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u25b2     \u25b2\n          \u2502     \u2502\n          \u2502     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Student  \u2502 \u2502  Teacher  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"30-oop/10-basic/40-inherit/#protected","title":"protected","text":"<p>One feature of inheritance is that child classes cannot access <code>private</code> fields or <code>private</code> methods of the parent class. For example, the <code>Student</code> class cannot access the <code>name</code> and <code>age</code> fields of the <code>Person</code> class:</p> <pre><code>class Person {\n    private String name;\n    private int age;\n}\n\nclass Student extends Person {\n    public String hello() {\n        return \"Hello, \" + name; // \u7f16\u8bd1\u9519\u8bef\uff1a\u65e0\u6cd5\u8bbf\u95eename\u5b57\u6bb5\n    }\n}\n</code></pre> <p>This makes inheritance less useful. In order for subclasses to have access to fields of the parent class, we need to change <code>private</code> to <code>protected</code>. Fields modified with <code>protected</code> can be accessed by subclasses:</p> <pre><code>class Person {\n    protected String name;\n    protected int age;\n}\n\nclass Student extends Person {\n    public String hello() {\n        return \"Hello, \" + name; // OK!\n    }\n}\n</code></pre> <p>Thus, the <code>protected</code> keyword keeps access to fields and methods inside the inheritance tree, and a <code>protected</code> field and method can be accessed by its subclasses, as well as by the subclasses of its subclasses, as we'll explain in more detail later.</p>"},{"location":"30-oop/10-basic/40-inherit/#super","title":"super","text":"<p>The <code>super</code> keyword indicates a parent class (superclass). A subclass can use <code>super.fieldName</code> when referencing a field of the parent class. Example:</p> <pre><code>class Student extends Person {\n    public String hello() {\n        return \"Hello, \" + super.name;\n    }\n}\n</code></pre> <p>In fact, using <code>super.name</code> here, or <code>this.name</code>, or <code>name</code>, has the same effect. The compiler automatically locates the <code>name</code> field of the parent class.</p> <p>However, at some point, it becomes necessary to use <code>super</code>. Let's look at an example:</p> <pre><code>// super\npublic class Main {\n    public static void main(String[] args) {\n        Student s = new Student(\"Xiao Ming\", 12, 89);\n    }\n}\n\nclass Person {\n    protected String name;\n    protected int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nclass Student extends Person {\n    protected int score;\n\n    public Student(String name, int age, int score) {\n        this.score = score;\n    }\n}\n</code></pre> <p>Running the above code gets you a compile error to the effect that the constructor method of <code>Person</code> cannot be called from within the constructor method of <code>Student</code>.</p> <p>This is because in Java, the first line of any <code>class</code> constructor method must be a call to the constructor method of the parent class. If the constructor method of the parent class is not explicitly called, the compiler will automatically add a <code>super();</code> line for us, so the constructor method of the <code>Student</code> class actually looks like this:</p> <pre><code>class Student extends Person {\n    protected int score;\n\n    public Student(String name, int age, int score) {\n        super(); // \u81ea\u52a8\u8c03\u7528\u7236\u7c7b\u7684\u6784\u9020\u65b9\u6cd5\n        this.score = score;\n    }\n}\n</code></pre> <p>However, the <code>Person</code> class does not have a parameterless constructor method, and therefore, compilation fails.</p> <p>The solution is to call one of the constructor methods that exist for the <code>Person</code> class. Example:</p> <pre><code>class Student extends Person {\n    protected int score;\n\n    public Student(String name, int age, int score) {\n        super(name, age); // \u8c03\u7528\u7236\u7c7b\u7684\u6784\u9020\u65b9\u6cd5Person(String, int)\n        this.score = score;\n    }\n}\n</code></pre> <p>This will compile properly!</p> <p>We therefore conclude that if the parent class does not have a default constructor method, the child class must explicitly call <code>super()</code> with arguments in order for the compiler to locate an appropriate constructor method for the parent class.</p> <p>There is another issue that arises here in passing: namely, subclasses will not inherit any of the parent class's constructor methods. The default constructor methods for subclasses are automatically generated by the compiler, not inherited.</p>"},{"location":"30-oop/10-basic/40-inherit/#block-inheritance","title":"Block inheritance","text":"<p>Normally, any class can inherit from a class as long as that class does not have the <code>final</code> modifier.</p> <p>Starting with Java 15, it is permissible to use <code>sealed</code> to modify a class and explicitly write the names of subclasses that can inherit from that class via <code>permits</code>.</p> <p>For example, define a <code>Shape</code> class:</p> <pre><code>public sealed class Shape permits Rect, Circle, Triangle {\n    ...\n}\n</code></pre> <p>The above <code>Shape</code> class is a <code>sealed</code> class that allows only the specified 3 classes to inherit from it. If written:</p> <pre><code>public final class Rect extends Shape {...}\n</code></pre> <p>is fine, because the <code>Rect</code> appears in the <code>Shape</code>'s <code>permits</code> list. However, if you define an <code>Ellipse</code> you get an error:</p> <pre><code>public final class Ellipse extends Shape {...}\n// Compile error: class is not allowed to extend sealed class: Shape\n</code></pre> <p>The reason for this is that <code>Ellipse</code> does not appear in the <code>Shape</code> list of <code>permits</code>. This <code>sealed</code> class is mainly used in some frameworks to prevent inheritance abuse.</p> <p>The <code>sealed</code> class is currently previewed in Java 15; to enable it, you must use the arguments <code>--enable-preview</code> and <code>--source 15</code>.</p>"},{"location":"30-oop/10-basic/40-inherit/#transitioning-upward","title":"Transitioning upward","text":"<p>If a reference variable is of type <code>Student</code>, then it can point to an instance of type <code>Student</code>:</p> <pre><code>Student s = new Student();\n</code></pre> <p>If a variable of reference type is <code>Person</code>, then it can point to an instance of type <code>Person</code>:</p> <pre><code>Person p = new Person();\n</code></pre> <p>Now the question arises: if <code>Student</code> is inherited from <code>Person</code>, can a variable with reference type <code>Person</code> point to an instance of type <code>Student</code>?</p> <pre><code>Person p = new Student(); // ???\n</code></pre> <p>A test reveals that such pointing is allowed!</p> <p>This is because <code>Student</code> inherits from <code>Person</code> and therefore has all the functionality of <code>Person</code>. A variable of type <code>Person</code> that points to an instance of type <code>Student</code> has no problem operating on it!</p> <p>This kind of assignment, which safely changes a subclass type into a parent type, is called upcasting.</p> <p>Upward transformation is actually the safe changing of a subtype into a more abstract parent type:</p> <pre><code>Student s = new Student();\nPerson p = s; // upcasting, ok\nObject o1 = p; // upcasting, ok\nObject o2 = s; // upcasting, ok\n</code></pre> <p>Notice that the inheritance tree is <code>Student &gt; Person &gt; Object</code>, so it is possible to transform the type <code>Student</code> to <code>Person</code>, or higher level <code>Object</code>.</p>"},{"location":"30-oop/10-basic/40-inherit/#transitioning-downward","title":"Transitioning downward","text":"<p>Contrary to upward transformation, if you force a parent type to transform into a child type, it is downcasting. Example:</p> <pre><code>Person p1 = new Student(); // upcasting, ok\nPerson p2 = new Person();\nStudent s1 = (Student) p1; // ok\nStudent s2 = (Student) p2; // runtime error! ClassCastException!\n</code></pre> <p>If you test the code above, you can find out:</p> <p>The <code>Person</code> type <code>p1</code> actually points to the <code>Student</code> instance, and the <code>Person</code> type variable <code>p2</code> actually points to the <code>Person</code> instance. When transforming down, transforming <code>p1</code> to <code>Student</code> will succeed because <code>p1</code> actually points to a <code>Student</code> instance, and transforming <code>p2</code> to <code>Student</code> will fail because <code>p2</code> is actually of type <code>Person</code>, and you can't change the parent class into a subclass because the subclass has more functionality than the parent, and more functionality can't be changed out of thin air.</p> <p>Therefore, the downward transition is likely to fail. When it fails, the Java Virtual Machine reports a <code>ClassCastException</code>.</p> <p>To avoid downward transformation errors, Java provides the <code>instanceof</code> operator, which allows you to first determine whether an instance is of a certain type or not:</p> <pre><code>Person p = new Person();\nSystem.out.println(p instanceof Person); // true\nSystem.out.println(p instanceof Student); // false\n\nStudent s = new Student();\nSystem.out.println(s instanceof Person); // true\nSystem.out.println(s instanceof Student); // true\n\nStudent n = null;\nSystem.out.println(n instanceof Student); // false\n</code></pre> <p><code>instanceof</code> actually determines whether the instance pointed to by a variable is of the specified type, or a subclass of that type. If a reference variable is <code>null</code>, then any <code>instanceof</code> judgment is <code>false</code>.</p> <p>Using <code>instanceof</code>, you can judge before transforming downwards:</p> <pre><code>Person p = new Student();\nif (p instanceof Student) {\n    // \u53ea\u6709\u5224\u65ad\u6210\u529f\u624d\u4f1a\u5411\u4e0b\u8f6c\u578b:\n    Student s = (Student) p; // \u4e00\u5b9a\u4f1a\u6210\u529f\n}\n</code></pre> <p>Starting with Java 14, after judging <code>instanceof</code>, you can transform directly to the specified variable, avoiding the need to force another transformation. For example, for the following code:</p> <pre><code>Object obj = \"hello\";\nif (obj instanceof String) {\n    String s = (String) obj;\n    System.out.println(s.toUpperCase());\n}\n</code></pre> <p>It can be rewritten as follows:</p> <pre><code>// instanceof variable:\npublic class Main {\n    public static void main(String[] args) {\n        Object obj = \"hello\";\n        if (obj instanceof String s) {\n            // \u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u53d8\u91cfs:\n            System.out.println(s.toUpperCase());\n        }\n    }\n}\n</code></pre> <p>This writeup using <code>instanceof</code> is more concise.</p>"},{"location":"30-oop/10-basic/40-inherit/#distinguish-between-inheritance-and-combination","title":"Distinguish between inheritance and combination","text":"<p>When using inheritance, we have to be careful about logical consistency.</p> <p>Examine the <code>Book</code> class below:</p> <pre><code>class Book {\n    protected String name;\n    public String getName() {...}\n    public void setName(String name) {...}\n}\n</code></pre> <p>This <code>Book</code> class also has a <code>name</code> field, so can we make <code>Student</code> inherit from <code>Book</code>?</p> <pre><code>class Student extends Book {\n    protected int score;\n}\n</code></pre> <p>Obviously, logically, this doesn't make sense; <code>Student</code> should not inherit from <code>Book</code>, but from <code>Person</code>.</p> <p>The reason for this is that <code>Student</code> is a type of <code>Person</code> and they are is-relationships, whereas <code>Student</code> is not <code>Book</code>. In fact the relationship between <code>Student</code> and <code>Book</code> is a has relationship.</p> <p>Having a has relationship should not use inheritance, but rather a combination, i.e. <code>Student</code> can hold a <code>Book</code> instance:</p> <pre><code>class Student extends Person {\n    protected Book book;\n    protected int score;\n}\n</code></pre> <p>Thus, inheritance is an IS relationship and combination is a HAS relationship.</p>"},{"location":"30-oop/10-basic/40-inherit/#exercise","title":"Exercise","text":"<p>Define <code>PrimaryStudent</code>, inheriting from <code>Student</code>, and add a new <code>grade</code> field:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        Person p = new Person(\"\u5c0f\u660e\", 12);\n        Student s = new Student(\"\u5c0f\u7ea2\", 20, 99);\n        // TODO: \u5b9a\u4e49PrimaryStudent\uff0c\u4eceStudent\u7ee7\u627f\uff0c\u65b0\u589egrade\u5b57\u6bb5:\n        Student ps = new PrimaryStudent(\"\u5c0f\u519b\", 9, 100, 5);\n        System.out.println(ps.getScore());\n    }\n}\n\nclass Person {\n    protected String name;\n    protected int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n\n    public int getAge() { return age; }\n    public void setAge(int age) { this.age = age; }\n}\n\nclass Student extends Person {\n    protected int score;\n\n    public Student(String name, int age, int score) {\n        super(name, age);\n        this.score = score;\n    }\n\n    public int getScore() { return score; }\n}\n\nclass PrimaryStudent {\n    // TODO\n}\n</code></pre> <p>Download exercise</p>"},{"location":"30-oop/10-basic/40-inherit/#summary","title":"Summary","text":"<p>Inheritance is a powerful way to reuse code in object-oriented programming;</p> <p>Java allows only single inheritance, and the ultimate root class of all classes is <code>Object</code>;</p> <p><code>protected</code> allows subclasses to access fields and methods of the parent class;</p> <p>Constructor methods of subclasses can be called from the parent class via <code>super()</code>;</p> <p>can be safely up-converted to a more abstract type;</p> <p>Downward transformations can be forced, preferably with the help of <code>instanceof</code> judgment;</p> <p>The relationship between a subclass and its parent is an is, has relationship cannot be used with inheritance.</p>"},{"location":"30-oop/10-basic/50-polymorphic/","title":"Polymorphic","text":""},{"location":"30-oop/10-basic/50-polymorphic/#polymorphic","title":"Polymorphic","text":"<p>In an inheritance relationship, a subclass that defines a method with the exact same method signature as the parent class is called an Override.</p> <p>For example, in the <code>Person</code> class, we define the <code>run()</code> method:</p> <pre><code>class Person {\n    public void run() {\n        System.out.println(\"Person.run\");\n    }\n}\n</code></pre> <p>Override this <code>run()</code> method in the subclass <code>Student</code>:</p> <pre><code>class Student extends Person {\n    @Override\n    public void run() {\n        System.out.println(\"Student.run\");\n    }\n}\n</code></pre> <p>Override differs from Overload in that if the method signature is different, it is Overload and the Overload method is a new method; if the method signature is the same and the return value is the same, it is <code>Override</code>.</p> <p>[!WARNING]\u6ce8\u610f</p> <p>\u65b9\u6cd5\u540d\u76f8\u540c\uff0c\u65b9\u6cd5\u53c2\u6570\u76f8\u540c\uff0c\u4f46\u65b9\u6cd5\u8fd4\u56de\u503c\u4e0d\u540c\uff0c\u4e5f\u662f\u4e0d\u540c\u7684\u65b9\u6cd5\u3002\u5728Java\u7a0b\u5e8f\u4e2d\uff0c\u51fa\u73b0\u8fd9\u79cd\u60c5\u51b5\uff0c\u7f16\u8bd1\u5668\u4f1a\u62a5\u9519\u3002</p> <pre><code>class Person {\n    public void run() { \u2026 }\n}\n\nclass Student extends Person {\n    // \u4e0d\u662fOverride\uff0c\u56e0\u4e3a\u53c2\u6570\u4e0d\u540c:\n    public void run(String s) { \u2026 }\n    // \u4e0d\u662fOverride\uff0c\u56e0\u4e3a\u8fd4\u56de\u503c\u4e0d\u540c:\n    public int run() { \u2026 }\n}\n</code></pre> <p>Adding <code>@Override</code> allows the compiler to help check that the correct override has been done. If you wish to override, but accidentally write the wrong method signature, the compiler will report an error.</p> <pre><code>// override\npublic class Main {\n    public static void main(String[] args) {\n    }\n}\n\nclass Person {\n    public void run() {}\n}\n\npublic class Student extends Person {\n    @Override // Compile error!\n    public void run(String s) {}\n}\n</code></pre> <p>But <code>@Override</code> is not required.</p> <p>In the previous section, we have learned that the declared type of a reference variable may not match its actual type, for example:</p> <pre><code>Person p = new Student();\n</code></pre> <p>Now, let's consider a situation if a subclass overrides a method of the parent class:</p> <pre><code>// override\npublic class Main {\n    public static void main(String[] args) {\n        Person p = new Student();\n        p.run(); // \u5e94\u8be5\u6253\u5370Person.run\u8fd8\u662fStudent.run?\n    }\n}\n\nclass Person {\n    public void run() {\n        System.out.println(\"Person.run\");\n    }\n}\n\nclass Student extends Person {\n    @Override\n    public void run() {\n        System.out.println(\"Student.run\");\n    }\n}\n</code></pre> <p>So, a variable with actual type <code>Student</code> and reference type <code>Person</code>, calling its <code>run()</code> method, calls the <code>run()</code> method of <code>Person</code> or <code>Student</code>?</p> <p>A quick run of the above code shows that the method actually called is the <code>run()</code> method of <code>Student</code>. Hence the conclusion can be drawn:</p> <p>Java's instance method calls are dynamic calls based on the actual type at runtime, not the declared type of the variable.</p> <p>This very important feature is called polymorphism in object-oriented programming. It is spelled very complicatedly in English: Polymorphic.</p>"},{"location":"30-oop/10-basic/50-polymorphic/#polymorphism","title":"Polymorphism","text":"<p>Polymorphism means that a method call for a certain type is made in such a way that the method it actually executes depends on the actual type of method at the runtime. Example:</p> <pre><code>Person p = new Student();\np.run(); // \u65e0\u6cd5\u786e\u5b9a\u8fd0\u884c\u65f6\u7a76\u7adf\u8c03\u7528\u54ea\u4e2arun()\u65b9\u6cd5\n</code></pre> <p>Some students will say, from the code above, it is clear that the <code>run()</code> method of <code>Student</code> is definitely called.</p> <p>But suppose we write such a method:</p> <pre><code>public void runTwice(Person p) {\n    p.run();\n    p.run();\n}\n</code></pre> <p>It passes in a parameter of type <code>Person</code>, and there is no way of knowing whether the actual type of the passed-in parameter is <code>Person</code>, or <code>Student</code>, or some other subclass of <code>Person</code> such as <code>Teacher</code>, and therefore there is no way of knowing for sure whether or not it is the <code>run()</code> method defined by the <code>Person</code> class that is being invoked.</p> <p>So, the property of polymorphism is that it is the runtime that dynamically determines the subclass method that is called. Calling a certain method on a certain type, the actual method executed may be an overridden method of a certain subclass. What exactly is the purpose of this indeterministic method invocation?</p> <p>Let's stick to examples.</p> <p>Suppose we define an income for which we need to file a tax return, then first define an <code>Income</code> class:</p> <pre><code>class Income {\n    protected double income;\n    public double getTax() {\n        return income * 0.1; // \u7a0e\u738710%\n    }\n}\n</code></pre> <p>For salary income, a base can be subtracted, then we can derive <code>SalaryIncome</code> from <code>Income</code> and override <code>getTax()</code>:</p> <pre><code>class Salary extends Income {\n    @Override\n    public double getTax() {\n        if (income &lt;= 5000) {\n            return 0;\n        }\n        return (income - 5000) * 0.2;\n    }\n}\n</code></pre> <p>If you are entitled to the State Council Special Allowance, then according to the regulations, you can be fully exempted from tax:</p> <pre><code>class StateCouncilSpecialAllowance extends Income {\n    @Override\n    public double getTax() {\n        return 0;\n    }\n}\n</code></pre> <p>Now, we are going to write a financial software for tax filing, for all the income of a person, which can be written like this:</p> <pre><code>public double totalTax(Income... incomes) {\n    double total = 0;\n    for (Income income: incomes) {\n        total = total + income.getTax();\n    }\n    return total;\n}\n</code></pre> <p>Come and try it:</p> <pre><code>// Polymorphic\npublic class Main {\n    public static void main(String[] args) {\n        // \u7ed9\u4e00\u4e2a\u6709\u666e\u901a\u6536\u5165\u3001\u5de5\u8d44\u6536\u5165\u548c\u4eab\u53d7\u56fd\u52a1\u9662\u7279\u6b8a\u6d25\u8d34\u7684\u5c0f\u4f19\u4f34\u7b97\u7a0e:\n        Income[] incomes = new Income[] {\n            new Income(3000),\n            new Salary(7500),\n            new StateCouncilSpecialAllowance(15000)\n        };\n        System.out.println(totalTax(incomes));\n    }\n\n    public static double totalTax(Income... incomes) {\n        double total = 0;\n        for (Income income: incomes) {\n            total = total + income.getTax();\n        }\n        return total;\n    }\n}\n\nclass Income {\n    protected double income;\n\n    public Income(double income) {\n        this.income = income;\n    }\n\n    public double getTax() {\n        return income * 0.1; // \u7a0e\u738710%\n    }\n}\n\nclass Salary extends Income {\n    public Salary(double income) {\n        super(income);\n    }\n\n    @Override\n    public double getTax() {\n        if (income &lt;= 5000) {\n            return 0;\n        }\n        return (income - 5000) * 0.2;\n    }\n}\n\nclass StateCouncilSpecialAllowance extends Income {\n    public StateCouncilSpecialAllowance(double income) {\n        super(income);\n    }\n\n    @Override\n    public double getTax() {\n        return 0;\n    }\n}\n</code></pre> <p>Observing the <code>totalTax()</code> method: utilizing polymorphism, the <code>totalTax()</code> method only needs to deal with <code>Income</code>, which does not need to know about the existence of <code>Salary</code> and <code>StateCouncilSpecialAllowance</code> at all, in order to correctly compute the total tax. If we want to add a new type of manuscript income, we just need to derive it from <code>Income</code> and override the <code>getTax()</code> method correctly. Pass the new type into <code>totalTax()</code> without changing any code.</p> <p>As you can see, polymorphism has a very powerful feature, which is to allow the addition of more types of subclasses to achieve functionality extensions, but do not need to modify the code based on the parent class.</p>"},{"location":"30-oop/10-basic/50-polymorphic/#overriding-object-methods","title":"Overriding Object methods","text":"<p>Because all <code>classes</code> ultimately inherit from <code>Object</code>, which defines several important methods:</p> <ul> <li><code>toString()</code>: output instance as <code>String</code>;</li> <li><code>equals()</code>: determine if two instances are logically equivalent;</li> <li><code>hashCode()</code>: computes the hash value of an instance.</li> </ul> <p>We can override these methods of <code>Object</code> if necessary. Example:</p> <pre><code>class Person {\n    ...\n    // \u663e\u793a\u66f4\u6709\u610f\u4e49\u7684\u5b57\u7b26\u4e32:\n    @Override\n    public String toString() {\n        return \"Person:name=\" + name;\n    }\n\n    // \u6bd4\u8f83\u662f\u5426\u76f8\u7b49:\n    @Override\n    public boolean equals(Object o) {\n        // \u5f53\u4e14\u4ec5\u5f53o\u4e3aPerson\u7c7b\u578b:\n        if (o instanceof Person) {\n            Person p = (Person) o;\n            // \u5e76\u4e14name\u5b57\u6bb5\u76f8\u540c\u65f6\uff0c\u8fd4\u56detrue:\n            return this.name.equals(p.name);\n        }\n        return false;\n    }\n\n    // \u8ba1\u7b97hash:\n    @Override\n    public int hashCode() {\n        return this.name.hashCode();\n    }\n}\n</code></pre>"},{"location":"30-oop/10-basic/50-polymorphic/#call-super","title":"Call super","text":"<p>In the overridden method of a subclass, if you want to call the overridden method of the parent class, you can call it via <code>super</code>. Example:</p> <pre><code>class Person {\n    protected String name;\n    public String hello() {\n        return \"Hello, \" + name;\n    }\n}\n\nclass Student extends Person {\n    @Override\n    public String hello() {\n        // \u8c03\u7528\u7236\u7c7b\u7684hello()\u65b9\u6cd5:\n        return super.hello() + \"!\";\n    }\n}\n</code></pre>"},{"location":"30-oop/10-basic/50-polymorphic/#final","title":"final","text":"<p>Inheritance allows a subclass to override a parent class's methods. If a parent class does not allow a child class to override one of its methods, it can mark the method as <code>final</code>. Methods modified with <code>final</code> cannot be <code>Overridden</code>:</p> <pre><code>class Person {\n    protected String name;\n    public final String hello() {\n        return \"Hello, \" + name;\n    }\n}\n\nclass Student extends Person {\n    // compile error: \u4e0d\u5141\u8bb8\u8986\u5199\n    @Override\n    public String hello() {\n    }\n}\n</code></pre> <p>If a class does not want any other class to inherit from it, then the class itself can be marked as <code>final</code>. Classes modified with <code>final</code> cannot be inherited:</p> <pre><code>final class Person {\n    protected String name;\n}\n\n// compile error: \u4e0d\u5141\u8bb8\u7ee7\u627f\u81eaPerson\nclass Student extends Person {\n}\n</code></pre> <p>For instance fields of a class, they can also be modified with <code>final</code>. Fields modified with <code>final</code> cannot be modified after initialization. Example:</p> <pre><code>class Person {\n    public final String name = \"Unamed\";\n}\n</code></pre> <p>Reassigning a value to a <code>final</code> field will report an error:</p> <pre><code>Person p = new Person();\np.name = \"New Name\"; // compile error!\n</code></pre> <p>You can initialize final fields in the constructor method:</p> <pre><code>class Person {\n    public final String name;\n    public Person(String name) {\n        this.name = name;\n    }\n}\n</code></pre> <p>This approach is more commonly used because it ensures that once an instance is created, its <code>final</code> field cannot be modified.</p>"},{"location":"30-oop/10-basic/50-polymorphic/#exercise","title":"Exercise","text":"<p>Doing the tax math for a partner who has a paycheck and manuscript income.</p> <p>Download exercise</p>"},{"location":"30-oop/10-basic/50-polymorphic/#summary","title":"Summary","text":"<p>Subclasses can override the methods of the parent class (Override), overriding changes the behavior of the parent class method in the subclass;</p> <p>Java's method calls always act on the actual type of the runtime object, a behavior known as polymorphism;</p> <p>The <code>final</code> modifier serves multiple purposes:</p> <ul> <li><code>final</code>-modified methods prevent overriding;</li> <li>A class modified by <code>final</code> prevents inheritance;</li> <li><code>final</code>-modified fields must be initialized when the object is created and may not be modified thereafter.</li> </ul>"},{"location":"30-oop/10-basic/60-abstract-class/","title":"Abstract Class","text":""},{"location":"30-oop/10-basic/60-abstract-class/#abstract-classes","title":"Abstract classes","text":"<p>Due to polymorphism, every subclass can override the methods of the parent class, for example:</p> <pre><code>class Person {\n    public void run() { \u2026 }\n}\n\nclass Student extends Person {\n    @Override\n    public void run() { \u2026 }\n}\n\nclass Teacher extends Person {\n    @Override\n    public void run() { \u2026 }\n}\n</code></pre> <p>Both <code>Student</code> and <code>Teacher</code>, derived from the <code>Person</code> class, can override the <code>run()</code> method.</p> <p>If the <code>run()</code> method of the parent class <code>Person</code> has no real meaning, is it possible to remove the execution statement of the method?</p> <pre><code>class Person {\n    public void run(); // Compile Error!\n}\n</code></pre> <p>The answer is no, it will result in a compilation error because when defining a method, you must implement the method's statements.</p> <p>Is it possible to remove the <code>run()</code> method of the parent class?</p> <p>The answer is still no, because by removing the <code>run()</code> method of the parent class, the polymorphic nature is lost. For example, <code>runTwice()</code> would not compile:</p> <pre><code>public void runTwice(Person p) {\n    p.run(); // Person\u6ca1\u6709run()\u65b9\u6cd5\uff0c\u4f1a\u5bfc\u81f4\u7f16\u8bd1\u9519\u8bef\n    p.run();\n}\n</code></pre> <p>A method of a parent class can be declared as an abstract method if the method itself does not need to implement any functionality, but is merely intended to define a method signature with the purpose of allowing a subclass to override it:</p> <pre><code>class Person {\n    public abstract void run();\n}\n</code></pre> <p>Declaring a method as <code>abstract</code> indicates that it is an abstract method that does not itself implement any method statements. Because this abstract method is not executable by itself, the <code>Person</code> class cannot be instantiated either. The compiler will tell us that the <code>Person</code> class cannot be compiled because it contains abstract methods.</p> <p>The <code>Person</code> class itself must also be declared as <code>abstract</code> in order for it to compile correctly:</p> <pre><code>abstract class Person {\n    public abstract void run();\n}\n</code></pre>"},{"location":"30-oop/10-basic/60-abstract-class/#abstract-class","title":"Abstract class","text":"<p>If a <code>class</code> defines a method without concrete execution code, the method is an abstract method, and abstract methods are modified with <code>abstract</code>.</p> <p>Because it is not possible to execute abstract methods, this class must also be declared as an abstract class.</p> <p>A class modified with <code>abstract</code> is an abstract class. We cannot instantiate an abstract class:</p> <pre><code>Person p = new Person(); // \u7f16\u8bd1\u9519\u8bef\n</code></pre> <p>What is the use of an abstract class that cannot be instantiated?</p> <p>Because abstract classes themselves are designed to be inherited only, they can force subclasses to implement the abstract methods they define, or else compile errors will be reported. Thus, abstract methods are effectively the equivalent of defining a \"specification\".</p> <p>For example, the <code>Person</code> class defines the abstract method <code>run()</code>, then the <code>run()</code> method must be overridden when implementing the subclass <code>Student</code>:</p> <pre><code>// abstract class\npublic class Main {\n    public static void main(String[] args) {\n        Person p = new Student();\n        p.run();\n    }\n}\n\nabstract class Person {\n    public abstract void run();\n}\n\nclass Student extends Person {\n    @Override\n    public void run() {\n        System.out.println(\"Student.run\");\n    }\n}\n</code></pre>"},{"location":"30-oop/10-basic/60-abstract-class/#abstraction-oriented-programming","title":"Abstraction-oriented programming","text":"<p>When we define the abstract class <code>Person</code>, and the concrete subclasses <code>Student</code> and <code>Teacher</code>, we can refer to instances of the concrete subclasses through the abstract class <code>Person</code> type:</p> <pre><code>Person s = new Student();\nPerson t = new Teacher();\n</code></pre> <p>The beauty of this referential abstract class is that we make method calls to it without caring about the specific subtypes of the <code>Person</code> type variable:</p> <pre><code>// \u4e0d\u5173\u5fc3Person\u53d8\u91cf\u7684\u5177\u4f53\u5b50\u7c7b\u578b:\ns.run();\nt.run();\n</code></pre> <p>The same code, if the reference is to a new subclass, we still don't care about the specific type:</p> <pre><code>// \u540c\u6837\u4e0d\u5173\u5fc3\u65b0\u7684\u5b50\u7c7b\u662f\u5982\u4f55\u5b9e\u73b0run()\u65b9\u6cd5\u7684\uff1a\nPerson e = new Employee();\ne.run();\n</code></pre> <p>This way of referencing high-level types as much as possible and avoiding references to actual subtypes is called abstract-oriented programming.</p> <p>The essence of abstraction-oriented programming is:</p> <ul> <li>Upper-level code defines only the specification (e.g., <code>abstract class Person</code>);</li> <li>Business logic can be implemented without subclassing (normal compilation);</li> <li>The specific business logic is implemented by different subclasses and is of no concern to the caller.</li> </ul>"},{"location":"30-oop/10-basic/60-abstract-class/#exercise","title":"Exercise","text":"<p>Use an abstract class to calculate taxes for a partner who has a paycheck and a draft income.</p> <p>Download exercise</p>"},{"location":"30-oop/10-basic/60-abstract-class/#summary","title":"Summary","text":"<p>Methods defined through <code>abstract</code> are abstract methods, which have only a definition, not an implementation. Abstract methods define the interface specifications that subclasses must implement;</p> <p>A class that defines an abstract method must be defined as an abstract class, and subclasses inheriting from an abstract class must implement the abstract method;</p> <p>If no abstract methods are implemented, the subclass remains an abstract class;</p> <p>Abstraction-oriented programming makes the caller only care about the definition of the abstract method and not about the concrete implementation of the subclass.</p>"},{"location":"30-oop/10-basic/70-interface/","title":"Interface","text":""},{"location":"30-oop/10-basic/70-interface/#interfaces","title":"Interfaces","text":"<p>In abstract classes, abstract methods essentially define the interface specification: that is, they specify the interface of the higher-level class, thus ensuring that all subclasses have the same implementation of the interface, and in this way, polymorphism can be powerful.</p> <p>If an abstract class has no fields, all methods are all abstract:</p> <pre><code>abstract class Person {\n    public abstract void run();\n    public abstract String getName();\n}\n</code></pre> <p>It is then possible to rewrite that abstract class as an interface: <code>interface</code>.</p> <p>In Java, an interface can be declared using <code>interface</code>:</p> <pre><code>interface Person {\n    void run();\n    String getName();\n}\n</code></pre> <p>A so-called <code>interface</code> is a purely abstract interface that is even more abstract than an abstract class, because it can't even have fields. Since all methods defined by an interface are <code>public abstract</code> by default, these two modifiers don't need to be written (the effect is the same whether you write them or not).</p> <p>The <code>implements</code> keyword is required when a concrete <code>class</code> goes to implement an <code>interface</code>. An example:</p> <pre><code>class Student implements Person {\n    private String name;\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(this.name + \" run\");\n    }\n\n    @Override\n    public String getName() {\n        return this.name;\n    }\n}\n</code></pre> <p>We know that in Java, a class can only inherit from another class, not from more than one class. However, a class can implement multiple <code>interfaces</code>, for example:</p> <pre><code>class Student implements Person, Hello { // \u5b9e\u73b0\u4e86\u4e24\u4e2ainterface\n    ...\n}\n</code></pre>"},{"location":"30-oop/10-basic/70-interface/#terminology","title":"Terminology","text":"<p>Note the distinction between the terms:</p> <p>Java's interface refers specifically to the definition of <code>interface</code>, which denotes an interface type and a set of method signatures, while programming interface refers generally to interface specifications such as method signatures, data formats, network protocols, and so on.</p> <p>The comparison between abstract classes and interfaces is as follows:</p> abstract class interface inheritance can only extends a class can implements multiple interfaces fields can define instance fields cannot define instance fields Abstract Methods can define abstract methods can define abstract methods non-abstract methods can define non-abstract methods can define default methods"},{"location":"30-oop/10-basic/70-interface/#interface-inheritance","title":"Interface inheritance","text":"<p>An <code>interface</code> can inherit from another <code>interface</code>. An <code>interface</code> inherits from an <code>interface</code> using <code>extends</code>, which is equivalent to extending the methods of the interface. Example:</p> <pre><code>interface Hello {\n    void hello();\n}\n\ninterface Person extends Hello {\n    void run();\n    String getName();\n}\n</code></pre> <p>At this point, the <code>Person</code> interface inherits from the <code>Hello</code> interface, so the <code>Person</code> interface now actually has three abstract method signatures, one of which comes from the inherited <code>Hello</code> interface.</p>"},{"location":"30-oop/10-basic/70-interface/#succession","title":"Succession","text":"<p>The inheritance relationship between <code>interface</code> and <code>abstract class</code> can be rationally designed to fully reuse the code. Generally speaking, public logic is suitable for <code>abstract class</code>, concrete logic is put into subclasses, and the interface level represents the degree of abstraction. You can refer to Java's collection class definition of a set of interfaces, abstract classes, and concrete subclass inheritance relationships:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Iterable    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u25b2                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502                \u2502      Object       \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2502  Collection   \u2502                  \u25b2\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502\n        \u25b2     \u25b2          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502AbstractCollection \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2502     List      \u2502                  \u25b2\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502\n              \u25b2          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502   AbstractList    \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u25b2     \u25b2\n                                \u2502     \u2502\n                                \u2502     \u2502\n                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                     \u2502 ArrayList  \u2502 \u2502 LinkedList \u2502\n                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>When in use, the instantiated object can only ever be a specific subclass, but it is always referenced through an interface, because interfaces are more abstract than abstract classes:</p> <pre><code>List list = new ArrayList(); // \u7528List\u63a5\u53e3\u5f15\u7528\u5177\u4f53\u5b50\u7c7b\u7684\u5b9e\u4f8b\nCollection coll = list; // \u5411\u4e0a\u8f6c\u578b\u4e3aCollection\u63a5\u53e3\nIterable it = coll; // \u5411\u4e0a\u8f6c\u578b\u4e3aIterable\u63a5\u53e3\n</code></pre>"},{"location":"30-oop/10-basic/70-interface/#default-method","title":"default method","text":"<p>In interfaces, <code>default</code> methods can be defined. For example, change the <code>run()</code> method of the <code>Person</code> interface to a <code>default</code> method:</p> <pre><code>// interface\npublic class Main {\n    public static void main(String[] args) {\n        Person p = new Student(\"Xiao Ming\");\n        p.run();\n    }\n}\n\ninterface Person {\n    String getName();\n    default void run() {\n        System.out.println(getName() + \" run\");\n    }\n}\n\nclass Student implements Person {\n    private String name;\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n}\n</code></pre> <p>Implementing classes may not have to override the <code>default</code> method. The purpose of the <code>default</code> method is that when we need to add a new method to the interface, it will involve modifying all the subclasses. If the <code>default</code> method is added, then the subclasses don't have to be modified in their entirety, and only need to override the new method wherever it needs to be overridden.</p> <p>The <code>default</code> method is different from the ordinary method of an abstract class. Because <code>interface</code> has no fields, the <code>default</code> method has no access to fields, whereas the normal methods of an abstract class have access to instance fields.</p>"},{"location":"30-oop/10-basic/70-interface/#exercise","title":"Exercise","text":"<p>Use the interface to calculate taxes for a small partner who has a paycheck and manuscript income.</p> <p>Download exercise</p>"},{"location":"30-oop/10-basic/70-interface/#summary","title":"Summary","text":"<p>Java's interface (interface) defines a purely abstract specification, a class can implement multiple interfaces;</p> <p>Interfaces are also data types and are suitable for upward and downward transformations;</p> <p>All methods of an interface are abstract methods, and interfaces cannot define instance fields;</p> <p>Interfaces can define <code>default</code> methods (JDK&gt;=1.8).</p>"},{"location":"30-oop/10-basic/80-static/","title":"Static","text":""},{"location":"30-oop/10-basic/80-static/#static-fields-and-static-methods","title":"Static fields and static methods","text":"<p>Fields defined in a <code>class</code> we call instance fields. Instance fields are characterized by the fact that each instance has a separate field, and the same field in each instance does not affect each other.</p> <p>There is another type of field, one that is modified with <code>static</code>, called a static field: <code>static field</code>.</p> <p>Instance fields have a separate \"space\" in each instance, but static fields have a shared \"space\" that is shared by all instances. As an example:</p> <pre><code>class Person {\n    public String name;\n    public int age;\n    // \u5b9a\u4e49\u9759\u6001\u5b57\u6bb5number:\n    public static int number;\n}\n</code></pre> <p>Let's take a look at the code below:</p> <pre><code>// static field\npublic class Main {\n    public static void main(String[] args) {\n        Person ming = new Person(\"Xiao Ming\", 12);\n        Person hong = new Person(\"Xiao Hong\", 15);\n        ming.number = 88;\n        System.out.println(hong.number);\n        hong.number = 99;\n        System.out.println(ming.number);\n    }\n}\n\nclass Person {\n    public String name;\n    public int age;\n\n    public static int number;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n</code></pre> <p>For static fields, the effect is the same no matter which instance's static field is modified: all instances' static fields are modified, due to the fact that static fields do not belong to instances:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nming \u2500\u2500\u25b6\u2502Person instance   \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502name = \"Xiao Ming\"\u2502\n        \u2502age = 12          \u2502\n        \u2502number \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502Person class \u2502\n                              \u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n                              \u251c\u2500\u2500\u2500\u25b6\u2502number = 99  \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nhong \u2500\u2500\u25b6\u2502Person instance   \u2502  \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n        \u2502name = \"Xiao Hong\"\u2502  \u2502\n        \u2502age = 15          \u2502  \u2502\n        \u2502number \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2518\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Although instances can access static fields, they all point to static fields of <code>Person class</code> actually. So, all instances share a static field.</p> <p>Therefore, it is not recommended to use <code>Instance Variables. Static Fields</code> to access static fields, because in Java programs, instance objects do not have static fields. In code, instance objects can access static fields only because the compiler can automatically convert them based on the instance type to <code>Class name. Static Fields</code> to access static objects.</p> <p>It is recommended to access static fields by class name. Static fields can be understood as fields that describe the <code>class</code> itself. For the above code, a better way to write it would be:</p> <pre><code>Person.number = 99;\nSystem.out.println(Person.number);\n</code></pre>"},{"location":"30-oop/10-basic/80-static/#static-methods","title":"Static methods","text":"<p>There are static fields, and there are static methods. Methods modified with <code>static</code> are called static methods.</p> <p>An instance method must be called through an instance variable, whereas a static method does not require an instance variable and can be called through the class name. Static methods are similar to functions in other programming languages. For example:</p> <pre><code>// static method\npublic class Main {\n    public static void main(String[] args) {\n        Person.setNumber(99);\n        System.out.println(Person.number);\n    }\n}\n\nclass Person {\n    public static int number;\n\n    public static void setNumber(int value) {\n        number = value;\n    }\n}\n</code></pre> <p>Because static methods belong to a <code>class</code> and not to an instance, inside a static method, there is no access to the <code>this</code> variable or to instance fields; it can only access static fields.</p> <p>Static methods can also be called through instance variables, but this is just the compiler automatically rewriting the instance to the class name for us.</p> <p>Typically, accessing static fields and static methods through instance variables will result in a compilation warning.</p> <p>Static methods are often used in tool classes. For example:</p> <ul> <li>Arrays.sort()</li> <li>Math.random()</li> </ul> <p>Static methods are also often used for helper methods. Notice that the entry point to a Java program, <code>main()</code>, is also a static method.</p>"},{"location":"30-oop/10-basic/80-static/#static-fields-for-interfaces","title":"Static fields for interfaces","text":"<p>Because <code>interface</code> is a purely abstract class, it cannot define instance fields. However, <code>interface</code> is allowed to have static fields, and the static fields must be of type <code>final</code>:</p> <pre><code>public interface Person {\n    public static final int MALE = 1;\n    public static final int FEMALE = 2;\n}\n</code></pre> <p>In fact, since fields of <code>interface</code> can only be of type <code>public static final</code>, we can remove all these modifiers and the above code can be abbreviated as:</p> <pre><code>public interface Person {\n    // \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u52a0\u4e0apublic static final:\n    int MALE = 1;\n    int FEMALE = 2;\n}\n</code></pre> <p>The compiler automatically changes the field to the <code>public static final</code> type.</p>"},{"location":"30-oop/10-basic/80-static/#exercise","title":"Exercise","text":"<p>Add a static field <code>count</code> and static method <code>getCount()</code> to the <code>Person</code> class to count the number of instances created.</p> <p>Download Exercise</p>"},{"location":"30-oop/10-basic/80-static/#summary","title":"Summary","text":"<p>Static fields are fields that are <code>shared' by all instances, in fact they are</code>class` fields;</p> <p>Calling a static method does not require an instance, and you cannot access <code>this</code>, but you can access static fields and other static methods;</p> <p>Static methods are commonly used in tool classes and helper methods.</p>"},{"location":"30-oop/10-basic/90-package/","title":"Package","text":""},{"location":"30-oop/10-basic/90-package/#package","title":"Package","text":"<p>In the previous code, we named the classes and interfaces with simple names such as <code>Person</code>, <code>Student</code>, <code>Hello</code>, and so on.</p> <p>In reality, what if Ming writes a <code>Person</code> class and Red also writes a <code>Person</code> class, and now, White wants to use both Ming's <code>Person</code> and Red's <code>Person</code>?</p> <p>If Jun writes an <code>Arrays</code> class, and it happens that the JDK also comes with an <code>Arrays</code> class, how do you resolve the class name conflict?</p> <p>In Java, we use <code>package</code> to resolve name conflicts.</p> <p>Java defines a namespace called a package: <code>package</code>. A class always belongs to a package, and the class name (e.g., <code>Person</code>) is just a shorthand; the real full class name is <code>package. ClassName</code>.</p> <p>Example:</p> <p>Xiaoming's <code>Person</code> class is stored under the package <code>ming</code>, so the full class name is <code>ming.Person</code>;</p> <p>Red's <code>Person</code> class is stored under the package <code>hong</code>, so the full class name is <code>hong.Person</code>;</p> <p>Junior's <code>Arrays</code> class is stored under package <code>mr.jun</code>, so the full class name is <code>mr.jun.Arrays</code>;</p> <p>The JDK's <code>Arrays</code> class is stored under the package <code>java.util</code>, so the full class name is <code>java.util.Arrays</code>.</p> <p>When defining a <code>class</code>, we need to declare on the first line which package the <code>class</code> belongs to.</p> <p>The <code>Person.java</code> file of Xiaoming:</p> <pre><code>package ming; // \u7533\u660e\u5305\u540dming\n\npublic class Person {\n}\n</code></pre> <p>Junior's <code>Arrays.java</code> file:</p> <pre><code>package mr.jun; // \u7533\u660e\u5305\u540dmr.jun\n\npublic class Arrays {\n}\n</code></pre> <p>When the Java Virtual Machine executes, the JVM only looks at the full class name, so as long as the package name is different, the class is different.</p> <p>Packages can be multi-layered structures, separated by <code>.</code> separated by <code>. For example:</code>java.util`.</p> <p>[!WARNING]\u7279\u522b\u6ce8\u610f</p> <p>\u5305\u6ca1\u6709\u7236\u5b50\u5173\u7cfb\u3002java.util\u548cjava.util.zip\u662f\u4e0d\u540c\u7684\u5305\uff0c\u4e24\u8005\u6ca1\u6709\u4efb\u4f55\u7ee7\u627f\u5173\u7cfb\u3002</p> <p>A <code>class</code> that does not define a package name, which uses the default package, is very prone to name clashes, so the practice of leaving the package name unspecified is not recommended.</p> <p>We also need to organize the Java files above according to the package structure. Assuming <code>package_sample</code> as the root directory and <code>src</code> as the source directory, the structure of all the files is:</p> <pre><code>package_sample\n\u2514\u2500 src\n    \u251c\u2500 hong\n    \u2502  \u2514\u2500 Person.java\n    \u2502  ming\n    \u2502  \u2514\u2500 Person.java\n    \u2514\u2500 mr\n       \u2514\u2500 jun\n          \u2514\u2500 Arrays.java\n</code></pre> <p>That is, the directory hierarchy corresponding to all Java files should be the same as the package hierarchy.</p> <p>The compiled <code>.class</code> file also needs to be stored in a package structure. If you use an IDE and put the compiled <code>.class</code> file in the <code>bin</code> directory, the structure of the compiled file is:</p> <pre><code>package_sample\n\u2514\u2500 bin\n   \u251c\u2500 hong\n   \u2502  \u2514\u2500 Person.class\n   \u2502  ming\n   \u2502  \u2514\u2500 Person.class\n   \u2514\u2500 mr\n      \u2514\u2500 jun\n         \u2514\u2500 Arrays.class\n</code></pre>"},{"location":"30-oop/10-basic/90-package/#package-scoping","title":"Package scoping","text":"<p>Classes located in the same package can access package-scoped fields and methods. Fields and methods that are not modified by <code>public</code>, <code>protected</code>, or <code>private</code> are package scopes. For example, the <code>Person</code> class is defined under the <code>hello</code> package:</p> <pre><code>package hello;\n\npublic class Person {\n    // \u5305\u4f5c\u7528\u57df:\n    void hello() {\n        System.out.println(\"Hello!\");\n    }\n}\n</code></pre> <p>The <code>Main</code> class is also defined under the <code>hello</code> package:</p> <pre><code>package hello;\n\npublic class Main {\n    public static void main(String[] args) {\n        Person p = new Person();\n        p.hello(); // \u53ef\u4ee5\u8c03\u7528\uff0c\u56e0\u4e3aMain\u548cPerson\u5728\u540c\u4e00\u4e2a\u5305\n    }\n}\n</code></pre>"},{"location":"30-oop/10-basic/90-package/#import","title":"import","text":"<p>In a <code>class</code>, we always reference other <code>classes</code>. For example, Xiao Ming's <code>ming.Person</code> class, if he wants to reference Xiao Jun's <code>mr.jun.Arrays</code> class, he has three ways to write it:</p> <p>The first, write the full class name directly, for example:</p> <pre><code>// Person.java\npackage ming;\n\npublic class Person {\n    public void run() {\n        // \u5199\u5b8c\u6574\u7c7b\u540d: mr.jun.Arrays\n        mr.jun.Arrays arrays = new mr.jun.Arrays();\n    }\n}\n</code></pre> <p>Obviously, it's more painful to write the full class name each time.</p> <p>Therefore, the second way to write it is to use the <code>import</code> statement, import Junior's <code>Arrays</code>, and then write the simple class name:</p> <pre><code>// Person.java\npackage ming;\n\n// \u5bfc\u5165\u5b8c\u6574\u7c7b\u540d:\nimport mr.jun.Arrays;\n\npublic class Person {\n    public void run() {\n        // \u5199\u7b80\u5355\u7c7b\u540d: Arrays\n        Arrays arrays = new Arrays();\n    }\n}\n</code></pre> <p>When writing <code>import</code>, you can use <code>*</code> to indicate that all <code>class</code>s under this package are imported (but not the <code>class</code>s of subpackages):</p> <pre><code>// Person.java\npackage ming;\n\n// \u5bfc\u5165mr.jun\u5305\u7684\u6240\u6709class:\nimport mr.jun.*;\n\npublic class Person {\n    public void run() {\n        Arrays arrays = new Arrays();\n    }\n}\n</code></pre> <p>We generally don't recommend this writeup because it's hard to see which package the <code>Arrays</code> class belongs to after importing multiple packages.</p> <p>There is also an <code>import static</code> syntax which imports static fields and static methods of a class:</p> <pre><code>package main;\n\n// \u5bfc\u5165System\u7c7b\u7684\u6240\u6709\u9759\u6001\u5b57\u6bb5\u548c\u9759\u6001\u65b9\u6cd5:\nimport static java.lang.System.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // \u76f8\u5f53\u4e8e\u8c03\u7528System.out.println(\u2026)\n        out.println(\"Hello, world!\");\n    }\n}\n</code></pre> <p><code>import static</code> is rarely used.</p> <p>The <code>.class</code> file that the Java compiler ultimately compiles only uses the full class name, so when the compiler encounters a <code>class</code> name in the code:</p> <ul> <li>If it is a full class name, look up the <code>class</code> directly from the full class name;</li> <li>If it is a simple class name, look it up in the following order:<ul> <li>Find out if the <code>class</code> exists in the current <code>package</code>;</li> <li>Find out if the <code>import</code> package contains this <code>class</code>;</li> <li>Find out if the <code>java.lang</code> package contains this <code>class</code>.</li> </ul> </li> </ul> <p>If the class name cannot be determined by following the rules above, the compilation reports an error.</p> <p>Let's look at an example:</p> <pre><code>// Main.java\npackage test;\n\nimport java.text.Format;\n\npublic class Main {\n    public static void main(String[] args) {\n        java.util.List list; // ok\uff0c\u4f7f\u7528\u5b8c\u6574\u7c7b\u540d -&gt; java.util.List\n        Format format = null; // ok\uff0c\u4f7f\u7528import\u7684\u7c7b -&gt; java.text.Format\n        String s = \"hi\"; // ok\uff0c\u4f7f\u7528java.lang\u5305\u7684String -&gt; java.lang.String\n        System.out.println(s); // ok\uff0c\u4f7f\u7528java.lang\u5305\u7684System -&gt; java.lang.System\n        MessageFormat mf = null; // \u7f16\u8bd1\u9519\u8bef\uff1a\u65e0\u6cd5\u627e\u5230MessageFormat: MessageFormat cannot be resolved to a type\n    }\n}\n</code></pre> <p>Therefore, when writing a class, the compiler automatically does two import actions for us:</p> <ul> <li>Automatically <code>import</code> other <code>classes</code> of the current <code>package</code> by default;</li> <li>Automatically <code>import java.lang.*</code> by default.</li> </ul> <p>[!WARNING]\u6ce8\u610f</p> <p>\u81ea\u52a8\u5bfc\u5165\u7684\u662fjava.lang\u5305\uff0c\u4f46\u7c7b\u4f3cjava.lang.reflect\u8fd9\u4e9b\u5305\u4ecd\u9700\u8981\u624b\u52a8\u5bfc\u5165\u3002</p> <p>If there are two <code>class</code>s with the same name, e.g., <code>mr.jun.Arrays</code> and <code>java.util.Arrays</code>, then only one of them can be <code>imported</code> and the other must be written with the full class name.</p>"},{"location":"30-oop/10-basic/90-package/#best-practices","title":"Best practices","text":"<p>To avoid name conflicts, we need to determine unique package names. The recommended practice is to use inverted domain names to ensure uniqueness. Example:</p> <ul> <li>org.apache.commons.log</li> <li>org.apache.commons.log</li> <li>com.liaoxuefeng.sample</li> </ul> <p>Subpackages can then name themselves according to their function.</p> <p>Be careful not to rename classes with classes from the <code>java.lang</code> package, i.e., don't use these names for your own classes:</p> <ul> <li>String</li> <li>System</li> <li>Runtime</li> <li>...</li> </ul> <p>Be careful not to rename common JDK classes either:</p> <ul> <li>java.util.List</li> <li>java.text.</li> <li>java.math.BigInteger</li> <li>...</li> </ul>"},{"location":"30-oop/10-basic/90-package/#compile-and-run","title":"Compile and run","text":"<p>Suppose we create the following directory structure:</p> <pre><code>work\n\u251c\u2500\u2500 bin\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 com\n        \u2514\u2500\u2500 itranswarp\n            \u251c\u2500\u2500 sample\n            \u2502\u00a0\u00a0 \u2514\u2500\u2500 Main.java\n            \u2514\u2500\u2500 world\n                \u2514\u2500\u2500 Person.java\n</code></pre> <p>Among them, the <code>bin</code> directory is used to store the compiled <code>class</code> files, and the <code>src</code> directory stores the Java source code according to the package structure, how can we compile these Java source code at once?</p> <p>First, make sure that the current directory is the <code>work</code> directory, the parent directory where <code>src</code> and <code>bin</code> are stored:</p> <pre><code>$ ls\nbin src\n</code></pre> <p>Then, compile all Java files in the <code>src</code> directory:</p> <pre><code>$ javac -d ./bin src/**/*.java\n</code></pre> <p>The <code>-d</code> command line specifies that the output <code>class</code> files are stored in the <code>bin</code> directory, followed by the argument <code>src/**/*.java</code> which indicates all <code>.java</code> files in the <code>src</code> directory, including subdirectories of arbitrary depth.</p> <p>Note: Windows does not support <code>**</code> which searches all subdirectories, so compiling under Windows must list all <code>.java</code> files in order:</p> <pre><code>C:\\work&gt; javac -d bin src\\com\\itranswarp\\sample\\Main.java src\\com\\itranswarp\\world\\Persion.java\n</code></pre> <p>Using Windows PowerShell you can use <code>Get-ChildItem</code> to list all <code>.java</code> files in a specified directory:</p> <pre><code>PS C:\\work&gt; (Get-ChildItem -Path .\\src -Recurse -Filter *.java).FullName\nC:\\work\\src\\com\\itranswarp\\sample\\Main.java\nC:\\work\\src\\com\\itranswarp\\world\\Person.java\n</code></pre> <p>Therefore, the compile command can be written as:</p> <pre><code>PS C:\\work&gt; javac -d .\\bin (Get-ChildItem -Path .\\src -Recurse -Filter *.java).FullName\n</code></pre> <p>If it compiles correctly, the <code>javac</code> command produces no output. The following <code>class</code> file can be seen in the <code>bin</code> directory:</p> <pre><code>bin\n\u2514\u2500\u2500 com\n    \u2514\u2500\u2500 itranswarp\n        \u251c\u2500\u2500 sample\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 Main.class\n        \u2514\u2500\u2500 world\n            \u2514\u2500\u2500 Person.class\n</code></pre> <p>Now we can run the <code>class</code> file directly. Determine the classpath based on the location of the current directory, e.g., if the current directory is still <code>work</code>, the classpath is <code>bin</code> or <code>. /bin</code>:</p> <pre><code>$ java -cp bin com.itranswarp.sample.Main \nHello, world!\n</code></pre>"},{"location":"30-oop/10-basic/90-package/#exercise","title":"Exercise","text":"<p>Please create the project according to the following package structure:</p> <pre><code>oop-package\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 com\n        \u2514\u2500\u2500 itranswarp\n            \u251c\u2500\u2500 sample\n            \u2502\u00a0\u00a0 \u2514\u2500\u2500 Main.java\n            \u2514\u2500\u2500 world\n                \u2514\u2500\u2500 Person.java\n</code></pre> <p>Download Exercise</p>"},{"location":"30-oop/10-basic/90-package/#summary","title":"Summary","text":"<p>Java has a built-in <code>package</code> mechanism to avoid <code>class</code> naming conflicts;</p> <p>The core classes of the JDK use the <code>java.lang</code> package, which is automatically imported by the compiler;</p> <p>Other common JDK classes are defined in <code>java.util.*</code>, <code>java.math.*</code>, <code>java.text.*</code>, ......;</p> <p>Inverted domain names are recommended for package names, e.g. <code>org.apache</code>.</p>"},{"location":"30-oop/20-core/","title":"Overview","text":""},{"location":"30-oop/20-core/#java-core-classes","title":"Java core classes","text":"<p>In this section we will cover the core classes of Java, including:</p> <ul> <li>String</li> <li>StringBuilder</li> <li>StringJoiner</li> <li>Wrapper Type</li> <li>JavaBean</li> <li>Enumerations</li> <li>Common utility classes</li> </ul> <p></p>"},{"location":"30-oop/20-core/10-string-encoding/","title":"String Encoding","text":""},{"location":"30-oop/20-core/10-string-encoding/#strings-and-codes","title":"Strings and codes","text":""},{"location":"30-oop/20-core/10-string-encoding/#string","title":"String","text":"<p>In Java, <code>String</code> is a reference type, which is itself a <code>class</code>. However, the Java compiler has special treatment for <code>String</code>, which means that you can directly use <code>\"...\"</code> to represent a string:</p> <pre><code>String s1 = \"Hello!\";\n</code></pre> <p>Strings are actually represented internally in <code>String</code> by a <code>char[]</code> array, so it's fine to write it as follows:</p> <pre><code>String s2 = new String(new char[] {'H', 'e', 'l', 'l', 'o', '!'});\n</code></pre> <p>Because <code>String</code> is so commonly used, Java provides <code>\"...\"</code> as a string literal representation.</p> <p>An important feature of Java strings is that they are immutable. This immutability is achieved through the internal <code>private final char[]</code> field, and the absence of any method of modifying <code>char[]</code>.</p> <p>Let's look at an example:</p> <pre><code>// String\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"Hello\";\n        System.out.println(s);\n        s = s.toUpperCase();\n        System.out.println(s);\n    }\n}\n</code></pre> <p>Based on the output of the above code, try to explain whether the content of the string has changed or not.</p>"},{"location":"30-oop/20-core/10-string-encoding/#string-comparison","title":"String comparison","text":"<p>When we want to compare two strings to see if they are the same, pay special attention to the fact that we are actually trying to compare the contents of the strings to see if they are the same. The <code>equals()</code> method must be used and not <code>==</code>.</p> <p>Let's look at the example below:</p> <pre><code>// String\npublic class Main {\n    public static void main(String[] args) {\n        String s1 = \"hello\";\n        String s2 = \"hello\";\n        System.out.println(s1 == s2);\n        System.out.println(s1.equals(s2));\n    }\n}\n</code></pre> <p>On the surface, two strings compared with <code>==</code> and <code>equals()</code> are both <code>true</code>, but in fact that's just the Java compiler in the compilation period, it will automatically treat all the same strings as an object into the constant pool, naturally <code>s1</code> and <code>s2</code> references are the same.</p> <p>So it is purely coincidental that this <code>==</code> comparison returns <code>true</code>. Written differently, the <code>==</code> comparison fails:</p> <pre><code>// String\npublic class Main {\n    public static void main(String[] args) {\n        String s1 = \"hello\";\n        String s2 = \"HELLO\".toLowerCase();\n        System.out.println(s1 == s2);\n        System.out.println(s1.equals(s2));\n    }\n}\n</code></pre> <p>Conclusion: to compare two strings, the <code>equals()</code> method must always be used.</p> <p>To ignore case comparisons, use the <code>equalsIgnoreCase()</code> method.</p> <p>The <code>String</code> class also provides a variety of methods to search for substrings and extract substrings. The commonly used methods are:</p> <pre><code>// \u662f\u5426\u5305\u542b\u5b50\u4e32:\n\"Hello\".contains(\"ll\"); // true\n</code></pre> <p>Notice that the argument to the <code>contains()</code> method is <code>CharSequence</code> and not <code>String</code>, because <code>CharSequence</code> is an interface implemented by <code>String</code>.</p> <p>More examples of searching for substrings:</p> <pre><code>\"Hello\".indexOf(\"l\"); // 2\n\"Hello\".lastIndexOf(\"l\"); // 3\n\"Hello\".startsWith(\"He\"); // true\n\"Hello\".endsWith(\"lo\"); // true\n</code></pre> <p>Example of extracting a substring:</p> <pre><code>\"Hello\".substring(2); // \"llo\"\n\"Hello\".substring(2, 4); \"ll\"\n</code></pre> <p>Note that the index numbers start at <code>0</code>.</p>"},{"location":"30-oop/20-core/10-string-encoding/#remove-leading-and-trailing-blank-characters","title":"Remove leading and trailing blank characters","text":"<p>Use the <code>trim()</code> method to remove whitespace characters from the beginning and end of a string. Whitespace characters include spaces, <code>\\t</code>, <code>\\r</code>, <code>\\n</code>:</p> <pre><code>\"  \\tHello\\r\\n \".trim(); // \"Hello\"\n</code></pre> <p>Note: <code>trim()</code> does not change the contents of the string, it returns a new string.</p> <p>Another <code>strip()</code> method also removes whitespace characters from the beginning and end of a string. It differs from <code>trim()</code> in that the Chinese-like space character \\u3000` is also removed:</p> <pre><code>\"\\u3000Hello\\u3000\".strip(); // \"Hello\"\n\" Hello \".stripLeading(); // \"Hello \"\n\" Hello \".stripTrailing(); // \" Hello\"\n</code></pre> <p><code>String</code> also provides <code>isEmpty()</code> and <code>isBlank()</code> to determine whether a string is empty and a blank string:</p> <pre><code>\"\".isEmpty(); // true\uff0c\u56e0\u4e3a\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a0\n\"  \".isEmpty(); // false\uff0c\u56e0\u4e3a\u5b57\u7b26\u4e32\u957f\u5ea6\u4e0d\u4e3a0\n\"  \\n\".isBlank(); // true\uff0c\u56e0\u4e3a\u53ea\u5305\u542b\u7a7a\u767d\u5b57\u7b26\n\" Hello \".isBlank(); // false\uff0c\u56e0\u4e3a\u5305\u542b\u975e\u7a7a\u767d\u5b57\u7b26\n</code></pre>"},{"location":"30-oop/20-core/10-string-encoding/#replace-the-substring","title":"Replace the substring","text":"<p>To replace a substring in a string, there are two methods. One is to replace based on characters or strings:</p> <pre><code>String s = \"hello\";\ns.replace('l', 'w'); // \"hewwo\"\uff0c\u6240\u6709\u5b57\u7b26'l'\u88ab\u66ff\u6362\u4e3a'w'\ns.replace(\"ll\", \"~~\"); // \"he~~o\"\uff0c\u6240\u6709\u5b50\u4e32\"ll\"\u88ab\u66ff\u6362\u4e3a\"~~\"\n</code></pre> <p>The other is by regular expression substitution:</p> <pre><code>String s = \"A,,B;C ,D\";\ns.replaceAll(\"[\\\\,\\\\;\\\\s]+\", \",\"); // \"A,B,C,D\"\n</code></pre> <p>The above code uniformly replaces the matched substrings with <code>\",\"</code> by regular expressions. We will explain the usage of regular expressions in detail later.</p>"},{"location":"30-oop/20-core/10-string-encoding/#splitting-strings","title":"Splitting strings","text":"<p>To split a string, use the <code>split()</code> method and pass in a regular expression as well:</p> <pre><code>String s = \"A,B,C,D\";\nString[] ss = s.split(\"\\\\,\"); // {\"A\", \"B\", \"C\", \"D\"}\n</code></pre>"},{"location":"30-oop/20-core/10-string-encoding/#splicing-strings","title":"Splicing strings","text":"<p>String concatenation uses the static method <code>join()</code>, which joins an array of strings with the specified string:</p> <pre><code>String[] arr = {\"A\", \"B\", \"C\"};\nString s = String.join(\"***\", arr); // \"A***B***C\"\n</code></pre>"},{"location":"30-oop/20-core/10-string-encoding/#formatting-strings","title":"Formatting strings","text":"<p>Strings provide the <code>formatted()</code> method and the <code>format()</code> static method, which can be passed additional arguments, placeholders replaced, and a new string generated:</p> <pre><code>// String\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"Hi %s, your score is %d!\";\n        System.out.println(s.formatted(\"Alice\", 80));\n        System.out.println(String.format(\"Hi %s, your score is %.2f!\", \"Bob\", 59.5));\n    }\n}\n</code></pre> <p>There are several placeholders, followed by several parameters passed in. The parameter types should be the same as the placeholders. We often use this to format information. Commonly used placeholders are:</p> <ul> <li><code>%s</code>: displays a string;</li> <li><code>%d</code>: displays integers;</li> <li><code>%x</code>: displays hexadecimal integers;</li> <li><code>%f</code>: displays floating point numbers.</li> </ul> <p>Placeholders can also be formatted, e.g. <code>%.2f</code> means to display two decimals. If you're not sure what placeholder to use, then always use <code>%s</code>, since <code>%s</code> can display any data type. To see the full formatting syntax, see the JDK documentation.</p>"},{"location":"30-oop/20-core/10-string-encoding/#type-conversion","title":"Type conversion","text":"<p>To convert any basic or reference type to a string, use the static method <code>valueOf()</code>. This is an overloaded method and the compiler will automatically choose the appropriate method based on the arguments:</p> <pre><code>String.valueOf(123); // \"123\"\nString.valueOf(45.67); // \"45.67\"\nString.valueOf(true); // \"true\"\nString.valueOf(new Object()); // \u7c7b\u4f3cjava.lang.Object@636be97c\n</code></pre> <p>To convert strings to other types, it depends on the situation. For example, to convert a string to type <code>int</code>:</p> <pre><code>int n1 = Integer.parseInt(\"123\"); // 123\nint n2 = Integer.parseInt(\"ff\", 16); // \u6309\u5341\u516d\u8fdb\u5236\u8f6c\u6362\uff0c255\n</code></pre> <p>Converts a string to a <code>boolean</code> type:</p> <pre><code>boolean b1 = Boolean.parseBoolean(\"true\"); // true\nboolean b2 = Boolean.parseBoolean(\"FALSE\"); // false\n</code></pre> <p>In particular, note that <code>Integer</code> has a <code>getInteger(String)</code> method that, instead of converting a string to an <code>int</code>, converts the system variable corresponding to that string to an <code>Integer</code>:</p> <pre><code>Integer.getInteger(\"java.version\"); // \u7248\u672c\u53f7\uff0c11\n</code></pre>"},{"location":"30-oop/20-core/10-string-encoding/#converted-to-char","title":"Converted to char[]","text":"<p>The types <code>String</code> and <code>char[]</code> can be converted to each other by:</p> <pre><code>char[] cs = \"Hello\".toCharArray(); // String -&gt; char[]\nString s = new String(cs); // char[] -&gt; String\n</code></pre> <p>If the <code>char[]</code> array is modified, <code>String</code> does not change:</p> <pre><code>// String &lt;-&gt; char[]\npublic class Main {\n    public static void main(String[] args) {\n        char[] cs = \"Hello\".toCharArray();\n        String s = new String(cs);\n        System.out.println(s);\n        cs[0] = 'X';\n        System.out.println(s);\n    }\n}\n</code></pre> <p>This is because when a new <code>String</code> instance is created via <code>new String(char[])</code>, it doesn't directly reference the incoming <code>char[]</code> array, it makes a copy of it, so modifying the external <code>char[]</code> array won't affect the <code>char[]</code> array inside the <code>String</code> instance, because it's two different arrays.</p> <p>It is clear from the design of <code>String</code>'s invariant that we need to copy rather than directly reference the passed-in object if it is likely to change.</p> <p>For example, the following code is designed to hold the grades of a group of students in a <code>Score</code> class:</p> <pre><code>// int[]\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] scores = new int[] { 88, 77, 51, 66 };\n        Score s = new Score(scores);\n        s.printScores();\n        scores[2] = 99;\n        s.printScores();\n    }\n}\n\nclass Score {\n    private int[] scores;\n    public Score(int[] scores) {\n        this.scores = scores;\n    }\n\n    public void printScores() {\n        System.out.println(Arrays.toString(scores));\n    }\n}\n</code></pre> <p>Observing the two outputs, since <code>Score</code> internally directly references the externally passed <code>int[]</code> array, this can cause modifications to the <code>int[]</code> array by the external code, affecting the fields of the <code>Score</code> class. This creates a security risk if the external code is not trustworthy.</p> <p>Please fix the constructor method of <code>Score</code> so that modifications to the array by external code do not affect the <code>int[]</code> field of the <code>Score</code> instance.</p>"},{"location":"30-oop/20-core/10-string-encoding/#character-encoding","title":"Character encoding","text":"<p>In early computer systems, to encode characters, the American National Standard Institute (ANSI) developed a set of codes for English letters, numbers, and commonly used symbols, which occupied a single byte and ranged from <code>0</code> to <code>127</code>, with the highest bit always being <code>0</code>, known as the <code>ASCII</code> encoding. For example, the character <code>'A'</code> is encoded as <code>0x41</code>, and the character <code>'1'</code> is encoded as <code>0x31</code>.</p> <p>If Chinese characters are to be included in computer coding, it is clear that one byte is not enough. The <code>GB2312' standard uses two bytes to represent a Chinese character, where the highest bit of the first byte is always</code>1' in order to distinguish it from the <code>ASCII' code. For example, the</code>GB2312' code for the Chinese character <code>`zhong'' is</code>0xd6d0'.</p> <p>Similarly, there are <code>Shift_JIS</code> encodings for Japanese and <code>EUC-KR</code> encodings for Korean, and these encodings, because of the lack of standardization, are used at the same time, which creates conflicts.</p> <p>In order to standardize the encoding of all languages around the world, the Globally Harmonized Code Consortium issued the `Unicode' encoding, which incorporates the major languages of the world into the same encoding so that Chinese, Japanese, Korean and other languages do not conflict.</p> <p><code>Unicode</code> encoding requires two or more bytes to represent, we can compare the encoding of Chinese and English characters in <code>ASCII</code>, <code>GB2312</code> and <code>Unicode</code>:</p> <p>The <code>ASCII</code> and <code>Unicode</code> encoding of the English character <code>'A'</code>:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2510\nASCII:   \u2502 41 \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2518\n         \u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\nUnicode: \u2502 00 \u2502 41 \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The <code>Unicode</code> encoding of English characters is simply adding a <code>00</code> byte to the front.</p> <p>The <code>GB2312</code> and <code>Unicode</code> encoding of the Chinese character <code>Middle</code>:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\nGB2312:  \u2502 d6 \u2502 d0 \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n         \u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\nUnicode: \u2502 4e \u2502 2d \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>What is the <code>UTF-8</code> encoding that we often use? Because the high byte of the <code>Unicode</code> code for English characters is always <code>00</code>, and the text containing a large number of English characters will waste space, so <code>UTF-8</code> encoding appeared, which is a kind of variable-length encoding, used to turn the fixed-length <code>Unicode</code> code into a variable-length encoding of 1 to 4 bytes. With <code>UTF-8</code> encoding, the <code>UTF-8</code> encoding of the English character <code>'A</code> becomes <code>0x41</code>, which is exactly the same as the <code>ASCII</code> code, while the <code>UTF-8</code> encoding of the Chinese character <code>'zhong</code> is 3 bytes <code>0xe4b8ad</code>.</p> <p>Another advantage of <code>UTF-8' encoding is its fault tolerance. If some characters are incorrectly transmitted, the subsequent characters are not affected because</code>UTF-8' encoding relies on the high byte bit to determine how many bytes a character is, and it is often used as a transmission encoding.</p> <p>In Java, the <code>char</code> type is actually the two-byte <code>Unicode</code> encoding. If we want to manually convert a string to another encoding, we can do so:</p> <pre><code>byte[] b1 = \"Hello\".getBytes(); // \u6309\u7cfb\u7edf\u9ed8\u8ba4\u7f16\u7801\u8f6c\u6362\uff0c\u4e0d\u63a8\u8350\nbyte[] b2 = \"Hello\".getBytes(\"UTF-8\"); // \u6309UTF-8\u7f16\u7801\u8f6c\u6362\nbyte[] b2 = \"Hello\".getBytes(\"GBK\"); // \u6309GBK\u7f16\u7801\u8f6c\u6362\nbyte[] b3 = \"Hello\".getBytes(StandardCharsets.UTF_8); // \u6309UTF-8\u7f16\u7801\u8f6c\u6362\n</code></pre> <p>Note: After converting the encoding, it is no longer of type <code>char</code>, but an array represented by type <code>byte</code>.</p> <p>To convert a <code>byte[]</code> with a known encoding to a <code>String</code>, do this:</p> <pre><code>byte[] b = ...\nString s1 = new String(b, \"GBK\"); // \u6309GBK\u8f6c\u6362\nString s2 = new String(b, StandardCharsets.UTF_8); // \u6309UTF-8\u8f6c\u6362\n</code></pre> <p>Always keep in mind: Java's <code>String</code> and <code>char</code> are always represented in memory as Unicode encodings.</p>"},{"location":"30-oop/20-core/10-string-encoding/#read-more","title":"Read more","text":"<p>For different versions of the JDK, the <code>String</code> class has different optimizations in memory. Specifically, <code>String</code> in early JDK versions is always stored as <code>char[]</code>, which is defined as follows:</p> <pre><code>public final class String {\n    private final char[] value;\n    private final int offset;\n    private final int count;\n}\n</code></pre> <p>Newer JDK versions of <code>String</code>, on the other hand, store <code>String</code> as <code>byte[]</code>: one character per <code>byte</code> if the <code>String</code> contains only ASCII characters, and one character for every two <code>bytes</code> otherwise; this is done to conserve memory because a large number of <code>String</code>s of short lengths usually contain only ASCII characters:</p> <pre><code>public final class String {\n    private final byte[] value;\n    private final byte coder; // 0 = LATIN1, 1 = UTF16\n</code></pre> <p>For the user, the <code>String</code> internal optimizations do not affect any existing code, since its <code>public</code> method signature is unchanged.</p>"},{"location":"30-oop/20-core/10-string-encoding/#summary","title":"Summary","text":"<p>The Java string <code>String</code> is an immutable object;</p> <p>String operations do not change the contents of the original string, but return a new string;</p> <p>Commonly used string operations: extract substrings, find, replace, case conversion, etc;</p> <p>Java uses Unicode to represent <code>String</code> and <code>char</code>;</p> <p>Converting an encoding is converting <code>String</code> to <code>byte[]</code>, and requires the encoding to be specified;</p> <p>When converting to <code>byte[]</code>, always give preference to <code>UTF-8</code> encoding.</p>"},{"location":"30-oop/20-core/100-utils/","title":"Utils","text":""},{"location":"30-oop/20-core/100-utils/#common-tool-classes","title":"Common tool classes","text":"<p>Java's core library provides a large number of ready-made classes for us to use. In this section we introduce a few commonly used tool classes.</p>"},{"location":"30-oop/20-core/100-utils/#math","title":"Math","text":"<p>As the name suggests, the <code>Math</code> class is used for mathematical calculations, and it provides a large number of static methods to facilitate our implementation of mathematical calculations:</p> <p>Find the absolute value:</p> <pre><code>Math.abs(-100); // 100\nMath.abs(-7.8); // 7.8\n</code></pre> <p>Takes the maximum or minimum value:</p> <pre><code>Math.max(100, 99); // 100\nMath.min(1.2, 2.3); // 1.2\n</code></pre> <p>Calculate the x<sup>y</sup>th power:</p> <pre><code>Math.pow(2, 10); // 2\u768410\u6b21\u65b9=1024\n</code></pre> <p>Compute $\\sqrt x$:</p> <pre><code>Math.sqrt(2); // 1.414...\n</code></pre> <p>Calculate the e<sup>x</sup>th power:</p> <pre><code>Math.exp(2); // 7.389...\n</code></pre> <p>Compute the logarithm with e as the base:</p> <pre><code>Math.log(4); // 1.386...\n</code></pre> <p>Calculate logarithms with base 10:</p> <pre><code>Math.log10(100); // 2\n</code></pre> <p>Trigonometric functions:</p> <pre><code>Math.sin(3.14); // 0.00159...\nMath.cos(3.14); // -0.9999...\nMath.tan(3.14); // -0.0015...\nMath.asin(1.0); // 1.57079...\nMath.acos(1.0); // 0.0\n</code></pre> <p>Math also provides several mathematical constants:</p> <pre><code>double pi = Math.PI; // 3.14159...\ndouble e = Math.E; // 2.7182818...\nMath.sin(Math.PI / 6); // sin(\u03c0/6) = 0.5\n</code></pre> <p>Generate a random number x in the range <code>0 &lt;= x &lt; 1</code>:</p> <pre><code>Math.random(); // 0.53907... \u6bcf\u6b21\u90fd\u4e0d\u4e00\u6837\n</code></pre> <p>If we want to generate a random number with interval in <code>[MIN, MAX)</code>, we can achieve it with the help of <code>Math.random()</code>, which is calculated as follows:</p> <pre><code>// \u533a\u95f4\u5728[MIN, MAX)\u7684\u968f\u673a\u6570\npublic class Main {\n    public static void main(String[] args) {\n        double x = Math.random(); // x\u7684\u8303\u56f4\u662f[0,1)\n        double min = 10;\n        double max = 50;\n        double y = x * (max - min) + min; // y\u7684\u8303\u56f4\u662f[10,50)\n        long n = (long) y; // n\u7684\u8303\u56f4\u662f[10,50)\u7684\u6574\u6570\n        System.out.println(y);\n        System.out.println(n);\n    }\n}\n</code></pre> <p>Some of you may have noticed that the Java Standard Library also provides a <code>StrictMath</code>, which provides almost exactly the same methods as <code>Math</code>. The difference between these two classes is that, because floating-point calculations have errors, the results of calculations on different platforms (e.g., x86 and ARM) may not be consistent (meaning that the errors are different), so <code>StrictMath</code> guarantees that the results of calculations on all platforms are identical, while <code>Math</code> tries to optimize the speed of calculations for the platforms, so that, for the vast majority of cases, the use of <code>Math</code> will be is sufficient in most cases.</p>"},{"location":"30-oop/20-core/100-utils/#hexformat","title":"HexFormat","text":"<p>When dealing with <code>byte[]</code> arrays, we often need to be converted to hexadecimal strings, it is more trouble to write your own, with the Java standard library provides <code>HexFormat</code> can be convenient to help us convert.</p> <p>To convert a <code>byte[]</code> array to a hexadecimal string, use the <code>formatHex()</code> method:</p> <pre><code>import java.util.HexFormat;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        byte[] data = \"Hello\".getBytes();\n        HexFormat hf = HexFormat.of();\n        String hexData = hf.formatHex(data); // 48656c6c6f\n    }\n}\n</code></pre> <p>If you want to customize the conversion format, use a customized <code>HexFormat</code> instance:</p> <pre><code>// \u5206\u9694\u7b26\u4e3a\u7a7a\u683c\uff0c\u6dfb\u52a0\u524d\u7f000x\uff0c\u5927\u5199\u5b57\u6bcd:\nHexFormat hf = HexFormat.ofDelimiter(\" \").withPrefix(\"0x\").withUpperCase();\nhf.formatHex(\"Hello\".getBytes())); // 0x48 0x65 0x6C 0x6C 0x6F\n</code></pre> <p>Convert from a hexadecimal string to a <code>byte[]</code> array, using the <code>parseHex()</code> method:</p> <pre><code>byte[] bs = HexFormat.of().parseHex(\"48656c6c6f\");\n</code></pre>"},{"location":"30-oop/20-core/100-utils/#random","title":"Random","text":"<p><code>Random</code> is used to create pseudo-random numbers. By pseudo-random numbers, we mean that given an initial seed, the sequence of random numbers generated is exactly the same.</p> <p>To generate a random number, you can use <code>nextInt()</code>, <code>nextLong()</code>, <code>nextFloat()</code>, <code>nextDouble()</code>:</p> <pre><code>Random r = new Random();\nr.nextInt(); // 2071575453,\u6bcf\u6b21\u90fd\u4e0d\u4e00\u6837\nr.nextInt(10); // 5,\u751f\u6210\u4e00\u4e2a[0,10)\u4e4b\u95f4\u7684int\nr.nextLong(); // 8811649292570369305,\u6bcf\u6b21\u90fd\u4e0d\u4e00\u6837\nr.nextFloat(); // 0.54335...\u751f\u6210\u4e00\u4e2a[0,1)\u4e4b\u95f4\u7684float\nr.nextDouble(); // 0.3716...\u751f\u6210\u4e00\u4e2a[0,1)\u4e4b\u95f4\u7684double\n</code></pre> <p>Some children asked, every time you run the program, the random number generated is different, did not see the pseudo-random number characteristics.</p> <p>This is because when we create a <code>Random</code> instance, we use the current system timestamp as the seed if it is not given, so each time we run it, the seed is different and we get a different sequence of pseudo-random numbers.</p> <p>If we specify a seed when we create an instance of <code>Random</code>, we get a completely deterministic sequence of random numbers:</p> <pre><code>import java.util.Random;\n\npublic class Main {\n    public static void main(String[] args) {\n        Random r = new Random(12345);\n        for (int i = 0; i &lt; 10; i++) {\n            System.out.println(r.nextInt(100));\n        }\n        // 51, 80, 41, 28, 55...\n    }\n}\n</code></pre> <p>The <code>Math.random()</code> we used earlier actually calls the <code>Random</code> class internally, so it's also pseudo-random, we just can't specify the seed.</p>"},{"location":"30-oop/20-core/100-utils/#securerandom","title":"SecureRandom","text":"<p>There are pseudo-random numbers, and then there are true random numbers. In fact true true random numbers can only be obtained by quantum mechanical principles, and what we want is an unpredictable and secure random number, <code>SecureRandom</code> is used to create secure random numbers:</p> <pre><code>SecureRandom sr = new SecureRandom();\nSystem.out.println(sr.nextInt(100));\n</code></pre> <p><code>SecureRandom</code> cannot specify a seed, it uses the RNG (random number generator) algorithm.The JDK's <code>SecureRandom</code> actually has a number of different underlying implementations, some of which use a secure random seed coupled with a pseudo-random number algorithm to generate secure random numbers, and some of which use a true random number generator. In practice, you can prioritize getting a high-strength secure random number generator, and if one is not provided, then you can use a normal level secure random number generator:</p> <pre><code>import java.util.Arrays;\nimport java.security.SecureRandom;\nimport java.security.NoSuchAlgorithmException;\n\npublic class Main {\n    public static void main(String[] args) {\n        SecureRandom sr = null;\n        try {\n            sr = SecureRandom.getInstanceStrong(); // \u83b7\u53d6\u9ad8\u5f3a\u5ea6\u5b89\u5168\u968f\u673a\u6570\u751f\u6210\u5668\n        } catch (NoSuchAlgorithmException e) {\n            sr = new SecureRandom(); // \u83b7\u53d6\u666e\u901a\u7684\u5b89\u5168\u968f\u673a\u6570\u751f\u6210\u5668\n        }\n        byte[] buffer = new byte[16];\n        sr.nextBytes(buffer); // \u7528\u5b89\u5168\u968f\u673a\u6570\u586b\u5145buffer\n        System.out.println(Arrays.toString(buffer));\n    }\n}\n</code></pre> <p><code>SecureRandom</code> is secured by generating random numbers from a secure random seed provided by the operating system. This seed is the \"entropy\" generated by various random events such as CPU thermal noise, bytes read and written to disk, network traffic, and so on.</p> <p>In cryptography, secure random numbers are very important. If insecure pseudo-random numbers are used, all cryptographic systems will be broken. Therefore, always keep in mind that <code>SecureRandom</code> must be used to generate secure random numbers.</p> <p>[!CAUTION]\u6ce8\u610f</p> <p>\u9700\u8981\u4f7f\u7528\u5b89\u5168\u968f\u673a\u6570\u7684\u65f6\u5019\uff0c\u5fc5\u987b\u4f7f\u7528SecureRandom\uff0c\u7edd\u4e0d\u80fd\u4f7f\u7528Random\uff01</p>"},{"location":"30-oop/20-core/100-utils/#summary","title":"Summary","text":"<p>The common tool classes provided by Java are:</p> <ul> <li>Math: math calculation</li> <li>HexFormat: format hexadecimal numbers</li> <li>Random: generate pseudo-random numbers</li> <li>SecureRandom: generate secure random numbers</li> </ul>"},{"location":"30-oop/20-core/20-string-builder/","title":"StringBuilder","text":""},{"location":"30-oop/20-core/20-string-builder/#stringbuilder","title":"StringBuilder","text":"<p>The Java compiler does a special treatment of <code>String</code> that allows us to splice strings directly with <code>+</code>.</p> <p>Examine the following loop code:</p> <pre><code>String s = \"\";\nfor (int i = 0; i &lt; 1000; i++) {\n    s = s + \",\" + i;\n}\n</code></pre> <p>Although it is possible to splice strings directly, in a loop, each loop creates a new string object and then throws away the old string. Thus, the vast majority of strings are temporary objects, which not only wastes memory, but also affects GC efficiency.</p> <p>For efficient string splicing, the Java Standard Library provides <code>StringBuilder</code>, which is a mutable object that can be preallocated with a buffer, so that when new characters are added to <code>StringBuilder</code>, no new temporary objects are created:</p> <pre><code>StringBuilder sb = new StringBuilder(1024);\nfor (int i = 0; i &lt; 1000; i++) {\n    sb.append(',');\n    sb.append(i);\n}\nString s = sb.toString();\n</code></pre> <p><code>StringBuilder</code> can also perform chaining operations:</p> <pre><code>// \u94fe\u5f0f\u64cd\u4f5c\npublic class Main {\n    public static void main(String[] args) {\n        var sb = new StringBuilder(1024);\n        sb.append(\"Mr \")\n          .append(\"Bob\")\n          .append(\"!\")\n          .insert(0, \"Hello, \");\n        System.out.println(sb.toString());\n    }\n}\n</code></pre> <p>If we look at the source code of <code>StringBuilder</code>, we can see that the key to chaining operations is that the <code>append()</code> method defined returns <code>this</code> so that other methods of itself can be called over and over again.</p> <p>Modeled after <code>StringBuilder</code>, we can also design classes that support chaining operations. For example, a counter that can be incremented:</p> <pre><code>// \u94fe\u5f0f\u64cd\u4f5c\npublic class Main {\n    public static void main(String[] args) {\n        Adder adder = new Adder();\n        adder.add(3)\n             .add(5)\n             .inc()\n             .add(10);\n        System.out.println(adder.value());\n    }\n}\n\nclass Adder {\n    private int sum = 0;\n\n    public Adder add(int n) {\n        sum += n;\n        return this;\n    }\n\n    public Adder inc() {\n        sum ++;\n        return this;\n    }\n\n    public int value() {\n        return sum;\n    }\n}\n</code></pre> <p>Note: For normal string <code>+</code> operations, there is no need for us to rewrite them as <code>StringBuilder</code>, because the Java compiler automatically encodes multiple consecutive <code>+</code> operations as <code>StringConcatFactory</code> operations at compile time. At runtime, <code>StringConcatFactory</code> automatically optimizes string concatenation operations to array copy or <code>StringBuilder</code> operations.</p> <p>You may also have heard of <code>StringBuffer</code>, a thread-safe version of <code>StringBuilder</code> from the early days of Java, which ensures that it is also safe for multiple threads to manipulate <code>StringBuffer</code> through synchronization, but synchronization brings about a slowdown in execution.</p> <p>The <code>StringBuilder</code> and <code>StringBuffer</code> interfaces are identical, and there is no need to use <code>StringBuffer</code> at all now.</p>"},{"location":"30-oop/20-core/20-string-builder/#exercise","title":"Exercise","text":"<p>Please construct an <code>INSERT</code> statement using <code>StringBuilder</code>:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        String[] fields = { \"name\", \"position\", \"salary\" };\n        String table = \"employee\";\n        String insert = buildInsertSql(table, fields);\n        System.out.println(insert);\n        String s = \"INSERT INTO employee (name, position, salary) VALUES (?, ?, ?)\";\n        System.out.println(s.equals(insert) ? \"\u6d4b\u8bd5\u6210\u529f\" : \"\u6d4b\u8bd5\u5931\u8d25\");\n    }\n\n    static String buildInsertSql(String table, String[] fields) {\n        // TODO:\n        return \"\";\n    }\n}\n</code></pre> <p>Download Exercise</p>"},{"location":"30-oop/20-core/20-string-builder/#summary","title":"Summary","text":"<p><code>StringBuilder</code> are mutable objects used to splice strings efficiently;</p> <p><code>StringBuilder</code> can support chaining operations, and the key to implementing chaining operations is to return the instance itself;</p> <p><code>StringBuffer</code> is a thread-safe version of <code>StringBuilder</code>, which is rarely used these days.</p>"},{"location":"30-oop/20-core/30-string-joiner/","title":"StringJoiner","text":""},{"location":"30-oop/20-core/30-string-joiner/#stringjoiner","title":"StringJoiner","text":"<p>To splice strings efficiently, you should use <code>StringBuilder</code>.</p> <p>Many times, we splice strings like this:</p> <pre><code>// \u8f93\u51fa: Hello Bob, Alice, Grace!\npublic class Main {\n    public static void main(String[] args) {\n        String[] names = {\"Bob\", \"Alice\", \"Grace\"};\n        var sb = new StringBuilder();\n        sb.append(\"Hello \");\n        for (String name : names) {\n            sb.append(name).append(\", \");\n        }\n        // \u6ce8\u610f\u53bb\u6389\u6700\u540e\u7684\", \":\n        sb.delete(sb.length() - 2, sb.length());\n        sb.append(\"!\");\n        System.out.println(sb.toString());\n    }\n}\n</code></pre> <p>The need to splice arrays with delimiters like this is common, so the Java standard library also provides a <code>StringJoiner</code> to do this:</p> <pre><code>import java.util.StringJoiner;\npublic class Main {\n    public static void main(String[] args) {\n        String[] names = {\"Bob\", \"Alice\", \"Grace\"};\n        var sj = new StringJoiner(\", \");\n        for (String name : names) {\n            sj.add(name);\n        }\n        System.out.println(sj.toString());\n    }\n}\n</code></pre> <p>Slowly! The result with <code>StringJoiner</code> is missing the leading <code>\"Hello\"</code> and the ending <code>\"!\"</code>! In this case, you need to specify <code>Beginning</code> and <code>End</code> for <code>StringJoiner</code>:</p> <pre><code>import java.util.StringJoiner;\npublic class Main {\n    public static void main(String[] args) {\n        String[] names = {\"Bob\", \"Alice\", \"Grace\"};\n        var sj = new StringJoiner(\", \", \"Hello \", \"!\");\n        for (String name : names) {\n            sj.add(name);\n        }\n        System.out.println(sj.toString());\n    }\n}\n</code></pre>"},{"location":"30-oop/20-core/30-string-joiner/#stringjoin","title":"String.join()","text":"<p><code>String</code> also provides a static method <code>join()</code>, which internally uses <code>StringJoiner</code> to concatenate strings, and <code>String.join()</code> is more convenient when you don't need to specify the <code>beginning' and</code>end'. String.join()<code>is more convenient when you don't need to specify the</code>beginning<code>and</code>end`:</p> <pre><code>String[] names = {\"Bob\", \"Alice\", \"Grace\"};\nvar s = String.join(\", \", names);\n</code></pre>"},{"location":"30-oop/20-core/30-string-joiner/#exercise","title":"Exercise","text":"<p>Please construct a <code>SELECT</code> statement using <code>StringJoiner</code>:</p> <pre><code>import java.util.StringJoiner;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] fields = { \"name\", \"position\", \"salary\" };\n        String table = \"employee\";\n        String select = buildSelectSql(table, fields);\n        System.out.println(select);\n        System.out.println(\"SELECT name, position, salary FROM employee\".equals(select) ? \"\u6d4b\u8bd5\u6210\u529f\" : \"\u6d4b\u8bd5\u5931\u8d25\");\n    }\n\n    static String buildSelectSql(String table, String[] fields) {\n        // TODO:\n        return \"\";\n    }\n}\n</code></pre> <p>Download exercise</p>"},{"location":"30-oop/20-core/30-string-joiner/#summary","title":"Summary","text":"<p>It is more convenient to use <code>StringJoiner</code> or <code>String.join()</code> when splicing an array of strings with the specified separator;</p> <p>When splicing strings with <code>StringJoiner</code>, it is possible to append an additional \"beginning\" and \"end\".</p>"},{"location":"30-oop/20-core/40-wrapper/","title":"Wrapper","text":""},{"location":"30-oop/20-core/40-wrapper/#package-type","title":"Package type","text":"<p>We already know that there are two types of data types in Java:</p> <ul> <li>Basic types: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>boolean</code>, <code>float</code>, <code>double</code>, <code>char</code>;</li> <li>Reference types: all <code>class</code> and <code>interface</code> types.</li> </ul> <p>Reference types can be assigned <code>null</code> for null, but basic types cannot be assigned <code>null</code>:</p> <pre><code>String s = null;\nint n = null; // compile error!\n</code></pre> <p>So how do you consider a basic type to be an object (a reference type)?</p> <p>For example, to turn the <code>int</code> base type into a reference type, we can define an <code>Integer</code> class that contains only one instance field, <code>int</code>, so that the <code>Integer</code> class can be regarded as a Wrapper Class for <code>int</code>:</p> <pre><code>public class Integer {\n    private int value;\n\n    public Integer(int value) {\n        this.value = value;\n    }\n\n    public int intValue() {\n        return this.value;\n    }\n}\n</code></pre> <p>With the <code>Integer</code> class defined, we can convert <code>int</code> and <code>Integer</code> to each other:</p> <pre><code>Integer n = null;\nInteger n2 = new Integer(99);\nint n3 = n2.intValue();\n</code></pre> <p>In fact, because wrapper types are so useful, the Java core library provides a corresponding wrapper type for each basic type:</p> Basic Types Corresponding Reference Types boolean java.lang. byte java.lang. short java.lang. Byte short long java.lang. float java.lang. double java.lang. char java.lang. <p>We can use it directly and don't need to define it ourselves:</p> <pre><code>// Integer:\npublic class Main {\n    public static void main(String[] args) {\n        int i = 100;\n        // \u901a\u8fc7new\u64cd\u4f5c\u7b26\u521b\u5efaInteger\u5b9e\u4f8b(\u4e0d\u63a8\u8350\u4f7f\u7528,\u4f1a\u6709\u7f16\u8bd1\u8b66\u544a):\n        Integer n1 = new Integer(i);\n        // \u901a\u8fc7\u9759\u6001\u65b9\u6cd5valueOf(int)\u521b\u5efaInteger\u5b9e\u4f8b:\n        Integer n2 = Integer.valueOf(i);\n        // \u901a\u8fc7\u9759\u6001\u65b9\u6cd5valueOf(String)\u521b\u5efaInteger\u5b9e\u4f8b:\n        Integer n3 = Integer.valueOf(\"100\");\n        System.out.println(n3.intValue());\n    }\n}\n</code></pre>"},{"location":"30-oop/20-core/40-wrapper/#auto-boxing","title":"Auto Boxing","text":"<p>Because <code>int</code> and <code>Integer</code> can be converted to each other:</p> <pre><code>int i = 100;\nInteger n = Integer.valueOf(i);\nint x = n.intValue();\n</code></pre> <p>So, the Java compiler can help us automatically transform between <code>int</code> and <code>Integer</code>:</p> <pre><code>Integer n = 100; // \u7f16\u8bd1\u5668\u81ea\u52a8\u4f7f\u7528Integer.valueOf(int)\nint x = n; // \u7f16\u8bd1\u5668\u81ea\u52a8\u4f7f\u7528Integer.intValue()\n</code></pre> <p>This way of writing assignments that directly change <code>int</code> to <code>Integer</code> is called Auto Boxing, and conversely, the way of writing assignments that change <code>Integer</code> to <code>int</code> is called Auto Unboxing.</p> <p>[!NOTICE]\u6ce8\u610f</p> <p>\u81ea\u52a8\u88c5\u7bb1\u548c\u81ea\u52a8\u62c6\u7bb1\u53ea\u53d1\u751f\u5728\u7f16\u8bd1\u9636\u6bb5\uff0c\u76ee\u7684\u662f\u4e3a\u4e86\u5c11\u5199\u4ee3\u7801\u3002</p> <p>Boxing and unboxing affects the efficiency of code execution because compiled <code>class</code> code strictly distinguishes between basic types and reference types. Moreover, automatic unboxing execution may report <code>NullPointerException</code>:</p> <pre><code>// NullPointerException\npublic class Main {\n    public static void main(String[] args) {\n        Integer n = null;\n        int i = n;\n    }\n}\n</code></pre>"},{"location":"30-oop/20-core/40-wrapper/#no-change-class","title":"No-change class","text":"<p>All wrapper types are invariant classes. As we can see by looking at the source code of <code>Integer</code>, its core code is as follows:</p> <pre><code>public final class Integer {\n    private final int value;\n}\n</code></pre> <p>Thus, once an <code>Integer</code> object has been created, the object is invariant.</p> <p>Special attention should be paid to comparing two <code>Integer</code> instances: never use <code>==</code> to compare, because <code>Integer</code> is a reference type and must be compared using <code>equals()</code>:</p> <pre><code>// == or equals?\npublic class Main {\n    public static void main(String[] args) {\n        Integer x = 127;\n        Integer y = 127;\n        Integer m = 99999;\n        Integer n = 99999;\n        System.out.println(\"x == y: \" + (x==y)); // true\n        System.out.println(\"m == n: \" + (m==n)); // false\n        System.out.println(\"x.equals(y): \" + x.equals(y)); // true\n        System.out.println(\"m.equals(n): \" + m.equals(n)); // true\n    }\n}\n</code></pre> <p>If you look at the result carefully, you can see that <code>==</code> comparison, the smaller two same <code>Integer</code> return <code>true</code>, the larger two same <code>Integer</code> return <code>false</code>, this is because <code>Integer</code> is an invariant class, the compiler change <code>Integer x = 127;</code> automatically to <code>Integer x = Integer.valueOf(127);</code>, and to save memory, <code>Integer.valueOf()</code> always returns the same instance for smaller numbers, so the <code>==</code> comparison \"just happens\" to be <code>true</code>, but we mustn't because the Java Standard Library's <code>Integer</code> has internal cache optimizations, we must use the <code>equals()</code> method to compare two <code>Integers</code>.</p> <p>[!TIP]\u6700\u4f73\u5b9e\u8df5</p> <p>\u6309\u7167\u8bed\u4e49\u7f16\u7a0b\uff0c\u800c\u4e0d\u662f\u9488\u5bf9\u7279\u5b9a\u7684\u5e95\u5c42\u5b9e\u73b0\u53bb\u201c\u4f18\u5316\u201d\u3002</p> <p>Since <code>Integer.valueOf()</code> may always return the same <code>Integer</code> instance, here are two ways to do it when we create <code>Integer</code> ourselves:</p> <ul> <li>Method 1: <code>Integer n = new Integer(100);</code></li> <li>Method 2: <code>Integer n = Integer.valueOf(100);</code></li> </ul> <p>Method 2 is better because method 1 always creates a new instance of <code>Integer</code>, and method 2 leaves the internal optimization to the implementer of <code>Integer</code>, and even if it is not optimized in the current version, it may be optimized in the next version.</p> <p>We call static methods that create \"new\" objects static factory methods. An example of a static factory method is <code>Integer.valueOf()</code>, which returns as many cached instances as possible to save memory.</p> <p>[!TIP]\u6700\u4f73\u5b9e\u8df5</p> <p>\u521b\u5efa\u65b0\u5bf9\u8c61\u65f6\uff0c\u4f18\u5148\u9009\u7528\u9759\u6001\u5de5\u5382\u65b9\u6cd5\u800c\u4e0d\u662fnew\u64cd\u4f5c\u7b26\u3002</p> <p>If we examine the source code of the <code>Byte.valueOf()</code> method, we can see that all the instances of <code>Byte</code> returned by the standard library are cached instances, but the caller doesn't care whether the static factory method creates a new instance in any way or returns the cached instance directly.</p>"},{"location":"30-oop/20-core/40-wrapper/#conversion","title":"Conversion","text":"<p>The <code>Integer</code> class itself also provides a large number of methods, for example, the most commonly used static method <code>parseInt()</code> parses a string into an integer:</p> <pre><code>int x1 = Integer.parseInt(\"100\"); // 100\nint x2 = Integer.parseInt(\"100\", 16); // 256,\u56e0\u4e3a\u630916\u8fdb\u5236\u89e3\u6790\n</code></pre> <p><code>Integer</code> can also format an integer into a string of the specified binary:</p> <pre><code>// Integer:\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Integer.toString(100)); // \"100\",\u8868\u793a\u4e3a10\u8fdb\u5236\n        System.out.println(Integer.toString(100, 36)); // \"2s\",\u8868\u793a\u4e3a36\u8fdb\u5236\n        System.out.println(Integer.toHexString(100)); // \"64\",\u8868\u793a\u4e3a16\u8fdb\u5236\n        System.out.println(Integer.toOctalString(100)); // \"144\",\u8868\u793a\u4e3a8\u8fdb\u5236\n        System.out.println(Integer.toBinaryString(100)); // \"1100100\",\u8868\u793a\u4e3a2\u8fdb\u5236\n    }\n}\n</code></pre> <p>Note: The output of all of the above methods is <code>String</code>, which is represented in computer memory only in binary; no decimal or hexadecimal representation exists. <code>int n = 100</code> is always represented in memory in 4-byte binary:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u250200000000\u250200000000\u250200000000\u250201100100\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>We often use <code>System.out.println(n);</code> which relies on the core library to automatically format integers into decimal for output and display on the screen, and use <code>Integer.toHexString(n)</code> to automatically format integers into hexadecimal via the core library.</p> <p>Here we note an important principle of program design: the storage and display of data should be separated.</p> <p>Java's wrapper types also define some useful static variables</p> <pre><code>// boolean\u53ea\u6709\u4e24\u4e2a\u503ctrue/false\uff0c\u5176\u5305\u88c5\u7c7b\u578b\u53ea\u9700\u8981\u5f15\u7528Boolean\u63d0\u4f9b\u7684\u9759\u6001\u5b57\u6bb5:\nBoolean t = Boolean.TRUE;\nBoolean f = Boolean.FALSE;\n// int\u53ef\u8868\u793a\u7684\u6700\u5927/\u6700\u5c0f\u503c:\nint max = Integer.MAX_VALUE; // 2147483647\nint min = Integer.MIN_VALUE; // -2147483648\n// long\u7c7b\u578b\u5360\u7528\u7684bit\u548cbyte\u6570\u91cf:\nint sizeOfLong = Long.SIZE; // 64 (bits)\nint bytesOfLong = Long.BYTES; // 8 (bytes)\n</code></pre> <p>Finally, all wrapper types for integers and floats inherit from <code>Number</code>, so it is very easy to get the various basic types directly from the wrapper types:</p> <pre><code>// \u5411\u4e0a\u8f6c\u578b\u4e3aNumber:\nNumber num = new Integer(999);\n// \u83b7\u53d6byte, int, long, float, double:\nbyte b = num.byteValue();\nint n = num.intValue();\nlong ln = num.longValue();\nfloat f = num.floatValue();\ndouble d = num.doubleValue();\n</code></pre>"},{"location":"30-oop/20-core/40-wrapper/#handling-unsigned-integers","title":"Handling unsigned integers","text":"<p>In Java, there is no unsigned integer (Unsigned) basic data type. <code>byte</code>, <code>short</code>, <code>int</code>, and <code>long</code> are all signed integers, with the highest bit being the sign bit. C, on the other hand, provides all the data types supported by the CPU, including unsigned integers. Conversion between unsigned and signed integers is done in Java with the help of static methods of wrapper types.</p> <p>For example, byte is a signed integer with a range of <code>-128</code> to <code>+127</code>, but if <code>byte</code> is considered as an unsigned integer, its range is <code>0</code> to <code>255</code>. We convert a negative <code>byte</code> to <code>int</code> by unsigned integer:</p> <pre><code>// Byte\npublic class Main {\n    public static void main(String[] args) {\n        byte x = -1;\n        byte y = 127;\n        System.out.println(Byte.toUnsignedInt(x)); // 255\n        System.out.println(Byte.toUnsignedInt(y)); // 127\n    }\n}\n</code></pre> <p>Since the binary representation of <code>-1</code> of a <code>byte</code> is <code>11111111</code>, an <code>int</code> converted as an unsigned integer is <code>255</code>.</p> <p>Similarly, it is possible to convert a <code>short</code> to an <code>int</code> by unsigned and an <code>int</code> to a <code>long</code> by unsigned.</p>"},{"location":"30-oop/20-core/40-wrapper/#summary","title":"Summary","text":"<p>The Java core library provides wrapper types that can wrap basic types as <code>class</code>;</p> <p>Auto-boxing and auto-unboxing are both done at compile time (JDK&gt;=1.5);</p> <p>Loading and unloading boxes affects execution efficiency and a <code>NullPointerException</code> may occur when unloading boxes;</p> <p>Comparisons of wrapper types must use <code>equals()</code>;</p> <p>The wrapper types for both integers and floats inherit from <code>Number</code>;</p> <p>Packaging types provide a number of practical methods.</p>"},{"location":"30-oop/20-core/50-javabean/","title":"JavaBean","text":""},{"location":"30-oop/20-core/50-javabean/#javabean","title":"JavaBean","text":"<p>In Java, there are many <code>class</code> definitions that conform to such a specification:</p> <ul> <li>Several <code>private</code> instance fields;</li> <li>Read and write instance fields through <code>public</code> methods.</li> </ul> <p>Example:</p> <pre><code>public class Person {\n    private String name;\n    private int age;\n\n    public String getName() { return this.name; }\n    public void setName(String name) { this.name = name; }\n\n    public int getAge() { return this.age; }\n    public void setAge(int age) { this.age = age; }\n}\n</code></pre> <p>If the read and write methods conform to this naming convention below:</p> <pre><code>// \u8bfb\u65b9\u6cd5:\npublic Type getXyz()\n// \u5199\u65b9\u6cd5:\npublic void setXyz(Type value)\n</code></pre> <p>Then this <code>class</code> is called a <code>JavaBean</code>:</p> <p></p> <p>The field above is <code>xyz</code>, so the read/write method names start with <code>get</code> and <code>set</code>, respectively, and are followed by the field name <code>Xyz</code> in uppercase, so the two read/write method names are <code>getXyz()</code> and <code>setXyz()</code>, respectively.</p> <p>The <code>boolean</code> field is special in that its read method is generally named <code>isXyz()</code>:</p> <pre><code>// \u8bfb\u65b9\u6cd5:\npublic boolean isChild()\n// \u5199\u65b9\u6cd5:\npublic void setChild(boolean value)\n</code></pre> <p>We usually refer to a set of corresponding read methods (<code>getter</code>) and write methods (<code>setter</code>) as a property (<code>property</code>). For example, the <code>name</code> property:</p> <ul> <li>The corresponding read method is <code>String getName()</code>.</li> <li>The corresponding write method is <code>setName(String)</code>.</li> </ul> <p>Properties with only a <code>getter</code> are called read-only properties, for example, defining an age read-only property:</p> <ul> <li>The corresponding read method is <code>int getAge()</code>.</li> <li>No corresponding write method <code>setAge(int)</code></li> </ul> <p>Similarly, properties with only <code>setter</code> are called write-only properties.</p> <p>Obviously, read-only attributes are common and write-only attributes are not.</p> <p>Attributes only require <code>getter</code> and <code>setter</code> methods to be defined, not necessarily corresponding fields. For example, the <code>child</code> read-only attribute is defined as follows:</p> <pre><code>public class Person {\n    private String name;\n    private int age;\n\n    public String getName() { return this.name; }\n    public void setName(String name) { this.name = name; }\n\n    public int getAge() { return this.age; }\n    public void setAge(int age) { this.age = age; }\n\n    public boolean isChild() {\n        return age &lt;= 6;\n    }\n}\n</code></pre> <p>As you can see, <code>getter</code> and <code>setter</code> are also methods of data encapsulation.</p>"},{"location":"30-oop/20-core/50-javabean/#the-role-of-javabean","title":"The role of JavaBean","text":"<p>JavaBean is mainly used to pass data, that is, a set of data combined into a JavaBean for easy transmission. In addition, JavaBean can be easily analyzed by IDE tools to generate code for reading and writing properties, mainly used in the visual design of graphical interfaces.</p> <p>With the IDE, <code>getter</code> and <code>setter</code> can be generated quickly. For example, in Eclipse, start by typing the following code:</p> <pre><code>public class Person {\n    private String name;\n    private int age;\n}\n</code></pre> <p>Then, right click, in the pop-up menu, select \"Source\", \"Generate Getters and Setters\", in the pop-up dialog box, select the fields you need to generate <code>getter</code> and <code>setter</code> methods. getter<code>and</code>setter` methods in the pop-up dialog box, click OK to have the IDE automatically complete all the method code.</p>"},{"location":"30-oop/20-core/50-javabean/#enumerating-javabean-properties","title":"Enumerating JavaBean properties","text":"<p>To enumerate all the properties of a JavaBean, you can directly use the <code>Introspector</code> provided by the Java core library:</p> <pre><code>import java.beans.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        BeanInfo info = Introspector.getBeanInfo(Person.class);\n        for (PropertyDescriptor pd : info.getPropertyDescriptors()) {\n            System.out.println(pd.getName());\n            System.out.println(\"  \" + pd.getReadMethod());\n            System.out.println(\"  \" + pd.getWriteMethod());\n        }\n    }\n}\n\nclass Person {\n    private String name;\n    private int age;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n</code></pre> <p>Running the above code lists all the attributes, and the corresponding read and write methods. Note that the <code>class</code> attribute is brought from the <code>getClass()</code> method inherited from <code>Object</code>.</p>"},{"location":"30-oop/20-core/50-javabean/#summary","title":"Summary","text":"<p>A JavaBean is a <code>class</code> that conforms to a naming convention and defines properties via <code>getter</code> and <code>setter</code>;</p> <p>Attribute is a generic name, not a Java syntax requirement;</p> <p>The IDE can be used to quickly generate <code>getter</code> and <code>setter</code>;</p> <p>Use <code>Introspector.getBeanInfo()</code> to get the list of properties.</p>"},{"location":"30-oop/20-core/60-enum/","title":"Enum","text":""},{"location":"30-oop/20-core/60-enum/#enumerated-classes","title":"Enumerated classes","text":"<p>In Java, we can define constants by <code>static final</code>. For example, if we wish to define 7 constants from Monday to Sunday, we can use 7 different <code>int</code> representations:</p> <pre><code>public class Weekday {\n    public static final int SUN = 0;\n    public static final int MON = 1;\n    public static final int TUE = 2;\n    public static final int WED = 3;\n    public static final int THU = 4;\n    public static final int FRI = 5;\n    public static final int SAT = 6;\n}\n</code></pre> <p>When using constants, they can be referenced this way:</p> <pre><code>if (day == Weekday.SAT || day == Weekday.SUN) {\n    // TODO: work at home\n}\n</code></pre> <p>It is also possible to define constants as string types, for example, defining constants for 3 colors:</p> <pre><code>public class Color {\n    public static final String RED = \"r\";\n    public static final String GREEN = \"g\";\n    public static final String BLUE = \"b\";\n}\n</code></pre> <p>When using constants, they can be referenced this way:</p> <pre><code>String color = ...\nif (Color.RED.equals(color)) {\n    // TODO:\n}\n</code></pre> <p>One serious problem with using either <code>int</code> constants or <code>String</code> constants to represent a set of enumerated values is that the compiler can't check the reasonableness of each value. For example:</p> <pre><code>if (weekday == 6 || weekday == 7) {\n    if (tasks == Weekday.MON) {\n        // TODO:\n    }\n}\n</code></pre> <p>The above code compiles and runs without errors, but there are two problems:</p> <ul> <li>Notice that <code>Weekday</code> defines constants in the range <code>0</code> to <code>6</code> and does not include <code>7</code>, and the compiler cannot check for <code>int</code> values that are not in the enumeration;</li> <li>Defined constants can still be compared to other variables, but their use is not to enumerate weekday values.</li> </ul>"},{"location":"30-oop/20-core/60-enum/#enum","title":"enum","text":"<p>In order for the compiler to automatically check that a value is within the set of enumerations, and, since enumerations for different purposes require different types to be labeled and cannot be mixed, we can use <code>enum</code> to define enumeration classes:</p> <pre><code>// enum\npublic class Main {\n    public static void main(String[] args) {\n        Weekday day = Weekday.SUN;\n        if (day == Weekday.SAT || day == Weekday.SUN) {\n            System.out.println(\"Work at home!\");\n        } else {\n            System.out.println(\"Work at office!\");\n        }\n    }\n}\n\nenum Weekday {\n    SUN, MON, TUE, WED, THU, FRI, SAT;\n}\n</code></pre> <p>Noting that defining enumeration classes is accomplished with the keyword <code>enum</code>, we simply list the constant names of the enumerations in order.</p> <p>Defining enumerations with <code>enum</code> has the following advantages over <code>int</code>-defined constants:</p> <p>First, the <code>enum</code> constant itself carries type information, i.e., the <code>Weekday.SUN</code> type is <code>Weekday</code>, and the compiler automatically checks for type errors. For example, the following statement is unlikely to compile:</p> <pre><code>int day = 1;\nif (day == Weekday.SUN) { // Compile error: bad operand types for binary operator '=='\n}\n</code></pre> <p>Second, it's impossible to reference to a non-enumerated value because it won't pass compilation.</p> <p>Finally, enumerations of different types cannot be compared or assigned to each other because the types do not match. For example, a variable of type <code>Weekday</code> enumeration cannot be assigned a value of type <code>Color</code> enumeration:</p> <pre><code>Weekday x = Weekday.SUN; // ok!\nWeekday y = Color.RED; // Compile error: incompatible types\n</code></pre> <p>This allows the compiler to automatically check for all possible potential errors at compile time.</p>"},{"location":"30-oop/20-core/60-enum/#comparison-of-enum","title":"Comparison of enum","text":"<p>The enum class defined using <code>enum</code> is a reference type. As we mentioned earlier, to compare reference types, use the <code>equals()</code> method, and if you use the <code>==</code> comparison, it compares whether two variables of the reference type are the same object or not. Therefore, always use the <code>equals()</code> method for reference type comparisons, with the exception of <code>enum</code> types.</p> <p>This is because each constant of type <code>enum</code> has only one unique instance in the JVM, so it can be compared directly with <code>==</code>:</p> <pre><code>if (day == Weekday.FRI) { // ok!\n}\nif (day.equals(Weekday.SUN)) { // ok, but more code!\n}\n</code></pre>"},{"location":"30-oop/20-core/60-enum/#enum-type","title":"enum type","text":"<p>What is the difference between an enum class defined via <code>enum</code> and any other <code>class</code>?</p> <p>The answer is that there is no difference. The type defined by <code>enum</code> is <code>class</code>, except that it has the following characteristics:</p> <ul> <li>The type <code>enum</code> defined always inherits from <code>java.lang.Enum</code> and cannot be inherited;</li> <li>Only instances of <code>enum</code> can be defined, and instances of <code>enum</code> cannot be created by the <code>new</code> operator;</li> <li>Each instance defined is a unique instance of the reference type;</li> <li>The <code>enum</code> type can be used in <code>switch</code> statements.</li> </ul> <p>For example, we define the <code>Color</code> enum class:</p> <pre><code>public enum Color {\n    RED, GREEN, BLUE;\n}\n</code></pre> <p>The compiler compiles a <code>class</code> that looks roughly like this:</p> <pre><code>public final class Color extends Enum { // \u7ee7\u627f\u81eaEnum\uff0c\u6807\u8bb0\u4e3afinal class\n    // \u6bcf\u4e2a\u5b9e\u4f8b\u5747\u4e3a\u5168\u5c40\u552f\u4e00:\n    public static final Color RED = new Color();\n    public static final Color GREEN = new Color();\n    public static final Color BLUE = new Color();\n    // private\u6784\u9020\u65b9\u6cd5\uff0c\u786e\u4fdd\u5916\u90e8\u65e0\u6cd5\u8c03\u7528new\u64cd\u4f5c\u7b26:\n    private Color() {}\n}\n</code></pre> <p>So there is no difference between the compiled <code>enum</code> class and a normal <code>class</code>. But we can't define <code>enum</code> by ourselves in the same way that we define a regular <code>class</code>; we have to use the <code>enum</code> keyword, which is required by the Java syntax.</p> <p>Because <code>enum</code> is a <code>class</code>, the value of each enumeration is a <code>class</code> instance, and as such, these instances have a number of methods:</p>"},{"location":"30-oop/20-core/60-enum/#name","title":"name()","text":"<p>Returns the name of a constant, for example:</p> <pre><code>String s = Weekday.SUN.name(); // \"SUN\"\n</code></pre>"},{"location":"30-oop/20-core/60-enum/#ordinal","title":"ordinal()","text":"<p>Returns the order of defined constants, counting from 0, for example:</p> <pre><code>int n = Weekday.MON.ordinal(); // 1\n</code></pre> <p>Changing the order in which enumeration constants are defined causes the <code>ordinal()</code> return value to change. Example:</p> <pre><code>public enum Weekday {\n    SUN, MON, TUE, WED, THU, FRI, SAT;\n}\n</code></pre> <p>cap (a poem)</p> <pre><code>public enum Weekday {\n    MON, TUE, WED, THU, FRI, SAT, SUN;\n}\n</code></pre> <p>The <code>ordinal</code> of <code>enum</code> is the difference. If you write a statement like <code>if(x.ordinal()==1)</code> in your code, make sure that the enumeration order of <code>enum</code> cannot change. New constants must be added last.</p> <p>Some kids may wonder if it's not very convenient to use <code>ordinal()</code> for <code>Weekday</code> enum constants if they are to be converted with <code>int</code>? For example, write it like this:</p> <pre><code>String task = Weekday.MON.ordinal() + \"/ppt\";\nsaveToFile(task);\n</code></pre> <p>However, if the order of the enumerations is accidentally changed, the compiler cannot check for such logical errors. To write robust code, don't rely on <code>ordinal()</code> return values. Since <code>enum</code> is itself a <code>class</code>, we can define <code>private</code> constructor methods and, add fields to each enumeration constant:</p> <pre><code>// enum\npublic class Main {\n    public static void main(String[] args) {\n        Weekday day = Weekday.SUN;\n        if (day.dayValue == 6 || day.dayValue == 0) {\n            System.out.println(\"Work at home!\");\n        } else {\n            System.out.println(\"Work at office!\");\n        }\n    }\n}\n\nenum Weekday {\n    MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0);\n\n    public final int dayValue;\n\n    private Weekday(int dayValue) {\n        this.dayValue = dayValue;\n    }\n}\n</code></pre> <p>This eliminates the need to worry about order changes, and when adding new enumeration constants, you also need to specify an <code>int</code> value.</p> <p>[!WARNING]\u6ce8\u610f</p> <p>\u679a\u4e3e\u7c7b\u7684\u5b57\u6bb5\u4e5f\u53ef\u4ee5\u662f\u975efinal\u7c7b\u578b\uff0c\u5373\u53ef\u4ee5\u5728\u8fd0\u884c\u671f\u4fee\u6539\uff0c\u4f46\u662f\u4e0d\u63a8\u8350\u8fd9\u6837\u505a\uff01</p> <p>By default, calling <code>toString()</code> on enum constants returns the same string as <code>name()</code>. However, <code>toString()</code> can be overridden, whereas <code>name()</code> cannot. We can add the <code>toString()</code> method to <code>Weekday</code>:</p> <pre><code>// enum\npublic class Main {\n    public static void main(String[] args) {\n        Weekday day = Weekday.SUN;\n        if (day.dayValue == 6 || day.dayValue == 0) {\n            System.out.println(\"Today is \" + day + \". Work at home!\");\n        } else {\n            System.out.println(\"Today is \" + day + \". Work at office!\");\n        }\n    }\n}\n\nenum Weekday {\n    MON(1, \"\u661f\u671f\u4e00\"), TUE(2, \"\u661f\u671f\u4e8c\"), WED(3, \"\u661f\u671f\u4e09\"), THU(4, \"\u661f\u671f\u56db\"), FRI(5, \"\u661f\u671f\u4e94\"), SAT(6, \"\u661f\u671f\u516d\"), SUN(0, \"\u661f\u671f\u65e5\");\n\n    public final int dayValue;\n    private final String chinese;\n\n    private Weekday(int dayValue, String chinese) {\n        this.dayValue = dayValue;\n        this.chinese = chinese;\n    }\n\n    @Override\n    public String toString() {\n        return this.chinese;\n    }\n}\n</code></pre> <p>The purpose of overriding <code>toString()</code> is to make the output more readable.</p> <p>[!WARNING]\u6ce8\u610f</p> <p>\u5224\u65ad\u679a\u4e3e\u5e38\u91cf\u7684\u540d\u5b57\uff0c\u8981\u59cb\u7ec8\u4f7f\u7528name()\u65b9\u6cd5\uff0c\u7edd\u4e0d\u80fd\u8c03\u7528toString()\uff01</p>"},{"location":"30-oop/20-core/60-enum/#switch","title":"Switch","text":"<p>Finally, enumerated classes can be used in <code>switch</code> statements. Because enumerated classes inherently have type information and a limited number of enumeration constants, they are better suited for use in <code>switch</code> statements than <code>int</code> and <code>String</code> types:</p> <pre><code>// switch\npublic class Main {\n    public static void main(String[] args) {\n        Weekday day = Weekday.SUN;\n        switch(day) {\n        case MON:\n        case TUE:\n        case WED:\n        case THU:\n        case FRI:\n            System.out.println(\"Today is \" + day + \". Work at office!\");\n            break;\n        case SAT:\n        case SUN:\n            System.out.println(\"Today is \" + day + \". Work at home!\");\n            break;\n        default:\n            throw new RuntimeException(\"cannot process \" + day);\n        }\n    }\n}\n\nenum Weekday {\n    MON, TUE, WED, THU, FRI, SAT, SUN;\n}\n</code></pre> <p>Adding the <code>default</code> statement allows you to automatically report an error if you miss writing one of the enumeration constants, so that you can catch the error in time.</p>"},{"location":"30-oop/20-core/60-enum/#summary","title":"Summary","text":"<p>Java uses <code>enum</code> to define enumeration types, which are compiled by the compiler as <code>final class Xxx extends Enum { ... }</code>;</p> <p>Get the string defined by the constant via <code>name()</code>, being careful not to use <code>toString()</code>;</p> <p>Returns the order of constant definitions (without substance) via <code>ordinal()</code>;</p> <p>Constructors, fields, and methods can be written for <code>enum</code></p> <p>The <code>enum</code> constructor is to be declared <code>private</code> and fields are strongly recommended to be declared <code>final</code>;</p> <p><code>enum</code> is suitable for use in <code>switch</code> statements.</p>"},{"location":"30-oop/20-core/70-record/","title":"Record","text":""},{"location":"30-oop/20-core/70-record/#record-classes","title":"Record classes","text":"<p>When using types such as <code>String</code>, <code>Integer</code>, etc., which are invariant classes, an invariant class has the following characteristics:</p> <ol> <li>Use <code>final</code> when defining class to make it impossible to derive subclasses;</li> <li>use <code>final</code> for each field to ensure that no field can be modified after the instance is created.</li> </ol> <p>Suppose we wish to define a <code>Point</code> class with <code>x</code> and <code>y</code> variables and it is also an invariant class, it can be written like this:</p> <pre><code>public final class Point {\n    private final int x;\n    private final int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int x() {\n        return this.x;\n    }\n\n    public int y() {\n        return this.y;\n    }\n}\n</code></pre> <p>In order to ensure comparison of invariant classes, it is also necessary to override the <code>equals()</code> and <code>hashCode()</code> methods correctly so that they can be used properly in collection classes. We'll explain the correct overriding of <code>equals()</code> and <code>hashCode()</code> in more detail later, and the purpose of demonstrating the writing of the <code>Point</code> invariant class here is that all of this code is very simple to write, but tedious.</p>"},{"location":"30-oop/20-core/70-record/#record","title":"record","text":"<p>Starting with Java 14, a new <code>Record</code> class was introduced. We define the <code>Record</code> class using the keyword <code>record</code>. Rewrite the above <code>Point</code> class as <code>Record</code> class with the following code:</p> <pre><code>// Record\npublic class Main {\n    public static void main(String[] args) {\n        Point p = new Point(123, 456);\n        System.out.println(p.x());\n        System.out.println(p.y());\n        System.out.println(p);\n    }\n}\n\nrecord Point(int x, int y) {}\n</code></pre> <p>Look closely at the definition of <code>Point</code>:</p> <pre><code>record Point(int x, int y) {}\n</code></pre> <p>Rewriting the above definition as a class is equivalent to the following code:</p> <pre><code>final class Point extends Record {\n    private final int x;\n    private final int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int x() {\n        return this.x;\n    }\n\n    public int y() {\n        return this.y;\n    }\n\n    public String toString() {\n        return String.format(\"Point[x=%s, y=%s]\", x, y);\n    }\n\n    public boolean equals(Object o) {\n        ...\n    }\n    public int hashCode() {\n        ...\n    }\n}\n</code></pre> <p>In addition to modifying the class with <code>final</code> and each field, the compiler automatically creates constructor methods for us, methods with the same name as the field name, and overrides the <code>toString()</code>, <code>equals()</code>, and <code>hashCode()</code> methods.</p> <p>In other words, using the <code>record</code> keyword, an invariant class can be written in one line.</p> <p>Similar to <code>enum</code>, we ourselves cannot derive directly from <code>Record</code>, but can only implement inheritance by the compiler via the <code>record</code> keyword.</p>"},{"location":"30-oop/20-core/70-record/#constructor","title":"Constructor","text":"<p>By default, the compiler automatically creates a constructor method in the order of the variables declared by <code>record</code> and assigns values to the fields within the method. So the question arises, what should we do if we want to check the parameters?</p> <p>Assuming that the <code>x</code> and <code>y</code> of the <code>Point</code> class don't allow negative numbers, we'll have to add checking logic to the <code>Point</code> constructor:</p> <pre><code>public record Point(int x, int y) {\n    public Point {\n        if (x &lt; 0 || y &lt; 0) {\n            throw new IllegalArgumentException();\n        }\n    }\n}\n</code></pre> <p>Notice that the method <code>public Point {...}</code> is called Compact Constructor and its purpose is to allow us to write the checking logic, the compiler ends up generating the constructor method as follows:</p> <pre><code>public final class Point extends Record {\n    public Point(int x, int y) {\n        // \u8fd9\u662f\u6211\u4eec\u7f16\u5199\u7684Compact Constructor:\n        if (x &lt; 0 || y &lt; 0) {\n            throw new IllegalArgumentException();\n        }\n        // \u8fd9\u662f\u7f16\u8bd1\u5668\u7ee7\u7eed\u751f\u6210\u7684\u8d4b\u503c\u4ee3\u7801:\n        this.x = x;\n        this.y = y;\n    }\n    ...\n}\n</code></pre> <p>Static methods can still be added to <code>Point</code> as a <code>record</code>. One common static method is the <code>of()</code> method, which is used to create a <code>Point</code>:</p> <pre><code>public record Point(int x, int y) {\n    public static Point of() {\n        return new Point(0, 0);\n    }\n    public static Point of(int x, int y) {\n        return new Point(x, y);\n    }\n}\n</code></pre> <p>This way we can write cleaner code:</p> <pre><code>var z = Point.of();\nvar p = Point.of(123, 456);\n</code></pre>"},{"location":"30-oop/20-core/70-record/#summary","title":"Summary","text":"<p>Starting with Java 14, the new <code>record</code> keyword is provided, which makes it very easy to define Data Classes:</p> <ul> <li>Invariant classes are defined using <code>record</code>;</li> <li>Compact Constructors can be written to validate parameters;</li> <li>Static methods can be defined.</li> </ul>"},{"location":"30-oop/20-core/80-biginteger/","title":"BigInteger","text":""},{"location":"30-oop/20-core/80-biginteger/#biginteger","title":"BigInteger","text":"<p>In Java, the maximum range of integers provided natively by the CPU is 64-bit <code>long</code> integers. Using <code>long</code> integers can be computed directly by CPU instructions, which is very fast.</p> <p>What if the range of integers we use exceeds the <code>long</code> type? At this point, the only way to simulate a large integer is to use software. <code>java.math.BigInteger</code> is used to represent an integer of any size. BigInteger<code>internally uses an</code>int[]` array to simulate a very large integer:</p> <pre><code>BigInteger bi = new BigInteger(\"1234567890\");\nSystem.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000\n</code></pre> <p>When doing operations on <code>BigInteger</code>, only instance methods can be used, e.g., addition:</p> <pre><code>BigInteger i1 = new BigInteger(\"1234567890\");\nBigInteger i2 = new BigInteger(\"12345678901234567890\");\nBigInteger sum = i1.add(i2); // 12345678902469135780\n</code></pre> <p>Compared to <code>long</code> type integer arithmetic, <code>BigInteger</code> does not have a range restriction, but has the disadvantage of being slower.</p> <p>It is also possible to convert <code>BigInteger</code> to <code>long</code> type:</p> <pre><code>BigInteger i = new BigInteger(\"123456789000\");\nSystem.out.println(i.longValue()); // 123456789000\nSystem.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range\n</code></pre> <p>When using the <code>longValueExact()</code> method, an <code>ArithmeticException</code> is thrown if the <code>long</code> type is out of range.</p> <p><code>BigInteger</code>, like <code>Integer</code> and <code>Long</code>, is an immutable class and also inherits from the <code>Number</code> class. This is because <code>Number</code> defines several methods for converting to basic types:</p> <ul> <li>Conversion to <code>byte</code>: <code>byteValue()</code>.</li> <li>Convert to <code>short</code>: <code>shortValue()</code>.</li> <li>Converts to <code>int</code>: <code>intValue()</code>.</li> <li>Converts to <code>long</code>: <code>longValue()</code>.</li> <li>Convert to <code>float</code>: <code>floatValue()</code>.</li> <li>Convert to <code>double</code>: <code>doubleValue()</code>.</li> </ul> <p>Thus, by the above method, <code>BigInteger</code> can be converted to a basic type. If <code>BigInteger</code> represents a range that exceeds the range of the basic type, the high level information will be lost when converting, i.e., the result may not be accurate. If you need to accurately convert to a basic type, you can use methods such as <code>intValueExact()</code>, <code>longValueExact()</code>, etc., and an <code>ArithmeticException</code> will be thrown directly if the range is exceeded during the conversion.</p> <p>If the value of <code>BigInteger</code> exceeds even the maximum range of <code>float</code> (3.4x10<sup>38</sup>), what is the returned float?</p> <pre><code>// BigInteger to float\nimport java.math.BigInteger;\n\npublic class Main {\n    public static void main(String[] args) {\n        BigInteger n = new BigInteger(\"999999\").pow(99);\n        float f = n.floatValue();\n        System.out.println(f); // Infinity\n    }\n}\n</code></pre>"},{"location":"30-oop/20-core/80-biginteger/#summary","title":"Summary","text":"<p><code>BigInteger</code> is used to represent an integer of arbitrary size;</p> <p><code>BigInteger</code> is the invariant class and inherits from <code>Number</code>;</p> <p>Converting <code>BigInteger</code> to a basic type can be done using methods such as <code>longValueExact()</code> to ensure accurate results.</p>"},{"location":"30-oop/20-core/90-bigdecimal/","title":"BigDecimal","text":""},{"location":"30-oop/20-core/90-bigdecimal/#bigdecimal","title":"BigDecimal","text":"<p>Similar to <code>BigInteger</code>, <code>BigDecimal</code> can represent a floating-point number of any size with exactly the right precision.</p> <pre><code>BigDecimal bd = new BigDecimal(\"123.4567\");\nSystem.out.println(bd.multiply(bd)); // 15241.55677489\n</code></pre> <p><code>BigDecimal</code> uses <code>scale()</code> to indicate the number of decimal places, for example:</p> <pre><code>BigDecimal d1 = new BigDecimal(\"123.45\");\nBigDecimal d2 = new BigDecimal(\"123.4500\");\nBigDecimal d3 = new BigDecimal(\"1234500\");\nSystem.out.println(d1.scale()); // 2,\u4e24\u4f4d\u5c0f\u6570\nSystem.out.println(d2.scale()); // 4\nSystem.out.println(d3.scale()); // 0\n</code></pre> <p>With the <code>stripTrailingZeros()</code> method of <code>BigDecimal</code>, it is possible to format a <code>BigDecimal</code> into an equal, but stripped of the trailing zeros, <code>BigDecimal</code>:</p> <pre><code>BigDecimal d1 = new BigDecimal(\"123.4500\");\nBigDecimal d2 = d1.stripTrailingZeros();\nSystem.out.println(d1.scale()); // 4\nSystem.out.println(d2.scale()); // 2,\u56e0\u4e3a\u53bb\u6389\u4e8600\n\nBigDecimal d3 = new BigDecimal(\"1234500\");\nBigDecimal d4 = d3.stripTrailingZeros();\nSystem.out.println(d3.scale()); // 0\nSystem.out.println(d4.scale()); // -2\n</code></pre> <p>If the <code>scale()</code> of a <code>BigDecimal</code> returns a negative number, e.g., <code>-2</code>, it means that the number is an integer and has 2 zeros at the end.</p> <p>It is possible to set its <code>scale</code> for a <code>BigDecimal</code>, and if the precision is lower than the original value, then round or just truncate as specified:</p> <pre><code>import java.math.BigDecimal;\nimport java.math.RoundingMode;\n----\npublic class Main {\n    public static void main(String[] args) {\n        BigDecimal d1 = new BigDecimal(\"123.456789\");\n        BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // \u56db\u820d\u4e94\u5165\uff0c123.4568\n        BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // \u76f4\u63a5\u622a\u65ad\uff0c123.4567\n        System.out.println(d2);\n        System.out.println(d3);\n    }\n}\n</code></pre> <p>Precision is not lost when adding, subtracting, or multiplying <code>BigDecimal</code>, but when dividing, there are cases where you can't divide all the way, so you have to specify the precision and how to truncate:</p> <pre><code>BigDecimal d1 = new BigDecimal(\"123.456\");\nBigDecimal d2 = new BigDecimal(\"23.456789\");\nBigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // \u4fdd\u755910\u4f4d\u5c0f\u6570\u5e76\u56db\u820d\u4e94\u5165\nBigDecimal d4 = d1.divide(d2); // \u62a5\u9519\uff1aArithmeticException\uff0c\u56e0\u4e3a\u9664\u4e0d\u5c3d\n</code></pre> <p>It is also possible to divide <code>BigDecimal</code> and find the remainder at the same time:</p> <pre><code>import java.math.BigDecimal;\n----\npublic class Main {\n    public static void main(String[] args) {\n        BigDecimal n = new BigDecimal(\"12.345\");\n        BigDecimal m = new BigDecimal(\"0.12\");\n        BigDecimal[] dr = n.divideAndRemainder(m);\n        System.out.println(dr[0]); // 102\n        System.out.println(dr[1]); // 0.105\n    }\n}\n</code></pre> <p>When the <code>divideAndRemainder()</code> method is called, the array returned contains two <code>BigDecimal</code>s, the quotient and remainder, where the quotient is always an integer and the remainder is not greater than the divisor. We can use this method to determine if the two <code>BigDecimal</code> are integer multiples:</p> <pre><code>BigDecimal n = new BigDecimal(\"12.75\");\nBigDecimal m = new BigDecimal(\"0.15\");\nBigDecimal[] dr = n.divideAndRemainder(m);\nif (dr[1].signum() == 0) {\n    // n\u662fm\u7684\u6574\u6570\u500d\n}\n</code></pre>"},{"location":"30-oop/20-core/90-bigdecimal/#compare-bigdecimal","title":"Compare BigDecimal","text":"<p>When comparing two <code>BigDecimal</code> values to be equal, pay special attention to the fact that using the <code>equals()</code> method requires not only that the values of the two <code>BigDecimal</code>s are equal, but also that their <code>scale()</code>s are equal:</p> <pre><code>BigDecimal d1 = new BigDecimal(\"123.456\");\nBigDecimal d2 = new BigDecimal(\"123.45600\");\nSystem.out.println(d1.equals(d2)); // false,\u56e0\u4e3ascale\u4e0d\u540c\nSystem.out.println(d1.equals(d2.stripTrailingZeros())); // true,\u56e0\u4e3ad2\u53bb\u9664\u5c3e\u90e80\u540escale\u53d8\u4e3a3\nSystem.out.println(d1.compareTo(d2)); // 0 = \u76f8\u7b49, -1 = d1 &lt; d2, 1 = d1 &gt; d2\n</code></pre> <p>Comparisons must be made using the <code>compareTo()</code> method, which returns negative, positive, and <code>0</code> for less than, greater than, and equal to, respectively, depending on the size of the two values.</p> <p>[!WARNING]\u6ce8\u610f</p> <p>\u603b\u662f\u4f7f\u7528compareTo()\u6bd4\u8f83\u4e24\u4e2aBigDecimal\u7684\u503c\uff0c\u4e0d\u8981\u4f7f\u7528equals()\uff01</p> <p>If you look at the source code of <code>BigDecimal</code>, you can see that a <code>BigDecimal</code> is actually represented by a <code>BigInteger</code> and a <code>scale</code>, i.e., the <code>BigInteger</code> represents a full integer and the <code>scale</code> represents the number of decimal places:</p> <pre><code>public class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt; {\n    private final BigInteger intVal;\n    private final int scale;\n}\n</code></pre> <p><code>BigDecimal</code> also inherits from <code>Number</code> and is also an immutable object.</p>"},{"location":"30-oop/20-core/90-bigdecimal/#summary","title":"Summary","text":"<p><code>BigDecimal</code> is used to represent exact decimals and is often used in financial calculations;</p> <p>To compare <code>BigDecimal</code> values for equality, you must use <code>compareTo()</code> and not <code>equals()</code>.</p>"},{"location":"40-exception/","title":"Overview","text":""},{"location":"40-exception/#exception-handling","title":"Exception handling","text":"<p>Various errors often occur when a program is running.</p> <p>For example, when using Excel, it sometimes reports errors:</p> <p></p> <p>In this chapter we discuss how to handle various exceptions in Java programs.</p> <p></p>"},{"location":"40-exception/10-java-exception/","title":"Java Exception Basics","text":""},{"location":"40-exception/10-java-exception/#exceptions-in-java","title":"Exceptions in Java","text":"<p>In the process of running a computer program, there are always various errors.</p> <p>There are some errors caused by the user, for example, the user is expected to enter an age of type <code>int</code>, but the user's input is <code>abc</code>:</p> <pre><code>// \u5047\u8bbe\u7528\u6237\u8f93\u5165\u4e86abc\uff1a\nString s = \"abc\";\nint n = Integer.parseInt(s); // NumberFormatException!\n</code></pre> <p>The program wants to read and write the contents of a file, but the user has deleted it:</p> <pre><code>// \u7528\u6237\u5220\u9664\u4e86\u8be5\u6587\u4ef6\uff1a\nString t = readFile(\"C:\\\\abc.txt\"); // FileNotFoundException!\n</code></pre> <p>There are also mistakes that occur randomly and can never be avoided. For example:</p> <ul> <li>The network was suddenly disconnected and could not connect to the remote server;</li> <li>Memory runs out and the program crashes;</li> <li>The user clicks \"Print\", but there is no printer;</li> <li>......</li> </ul> <p>Therefore, a robust program must handle a wide variety of errors.</p> <p>An error is when a program calls a function and if it fails, it indicates an error.</p> <p>How can the caller be informed of a failed call? There are two ways:</p> <p>Method 1: Agree to return an error code.</p> <p>For example, processing a file that returns <code>0</code> indicates success, and returns some other integer that indicates an agreed-upon error code:</p> <pre><code>int code = processFile(\"C:\\\\test.txt\");\nif (code == 0) {\n    // ok:\n} else {\n    // error:\n    switch (code) {\n    case 1:\n        // file not found:\n    case 2:\n        // no read permission:\n    default:\n        // unknown error:\n    }\n}\n</code></pre> <p>Because of the use of <code>int</code> type error codes, it is very cumbersome to try to deal with them. This approach is common in underlying C functions.</p> <p>Approach 2: Provide an exception handling mechanism at the language level.</p> <p>Java has a built-in exception handling mechanism that always uses exceptions to indicate errors.</p> <p>An exception is a <code>class</code> and thus carries type information on its own. Exceptions can be thrown anywhere, but only need to be caught at a higher level so that they are separated from the method call:</p> <pre><code>try {\n    String s = processFile(\u201cC:\\\\test.txt\u201d);\n    // ok:\n} catch (FileNotFoundException e) {\n    // file not found:\n} catch (SecurityException e) {\n    // no read permission:\n} catch (IOException e) {\n    // io error:\n} catch (Exception e) {\n    // other error:\n}\n</code></pre> <p>Because Java's exceptions are <code>class</code>, it has the following inheritance relationship:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                     \u2502  Object   \u2502\n                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u25b2\n                           \u2502\n                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                     \u2502 Throwable \u2502\n                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u25b2\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                 \u2502                   \u2502\n           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502   Error   \u2502       \u2502 Exception \u2502\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u25b2                   \u25b2\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502                      \u2502               \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502OutOfMemoryError \u2502... \u2502RuntimeException \u2502\u2502IOException\u2502...\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u25b2\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502                         \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502NullPointerException \u2502 \u2502IllegalArgumentException \u2502...\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>From the inheritance relationship: <code>Throwable</code> is the root of the exception system, which inherits from <code>Object</code>. <code>Throwable</code> has two systems: <code>Error</code> and <code>Exception</code>, <code>Error</code> indicates a serious error, which the program can't generally do anything about, for example:</p> <ul> <li><code>OutOfMemoryError</code>: ran out of memory</li> <li><code>NoClassDefFoundError</code>: Could not load a class.</li> <li><code>StackOverflowError</code>: stack overflowed</li> </ul> <p>An <code>Exception</code>, on the other hand, is a runtime error that can be caught and handled.</p> <p>Certain exceptions are part of the application logic processing and should be caught and handled. Example:</p> <ul> <li><code>NumberFormatException</code>: formatting error for numeric type</li> <li><code>FileNotFoundException</code>: file not found</li> <li><code>SocketException</code>: Failed to read network.</li> </ul> <p>There are also exceptions that are the result of incorrectly written program logic and should be fixed in the program itself. Example:</p> <ul> <li><code>NullPointerException</code>: a method or field is called on a <code>null</code> object.</li> <li><code>IndexOutOfBoundsException</code>: array index out of bounds</li> </ul> <p><code>Exception</code> is subdivided into two main categories:</p> <ol> <li><code>RuntimeException</code> and its subclasses;</li> <li>non-RuntimeException<code>(including</code>IOException<code>,</code>ReflectiveOperationException`, etc.)</li> </ol> <p>Java regulations:</p> <ul> <li>Exceptions that must be caught, including <code>Exception</code> and its subclasses, but excluding <code>RuntimeException</code> and its subclasses; this type of exception is called a Checked Exception.</li> <li>Exceptions that do not need to be caught, including <code>Error</code> and its subclasses, and <code>RuntimeException</code> and its subclasses.</li> </ul> <p>[!WARNING]\u6ce8\u610f</p> <p>\u7f16\u8bd1\u5668\u5bf9RuntimeException\u53ca\u5176\u5b50\u7c7b\u4e0d\u505a\u5f3a\u5236\u6355\u83b7\u8981\u6c42\uff0c\u4e0d\u662f\u6307\u5e94\u7528\u7a0b\u5e8f\u672c\u8eab\u4e0d\u5e94\u8be5\u6355\u83b7\u5e76\u5904\u7406RuntimeException\u3002\u662f\u5426\u9700\u8981\u6355\u83b7\uff0c\u5177\u4f53\u95ee\u9898\u5177\u4f53\u5206\u6790\u3002</p>"},{"location":"40-exception/10-java-exception/#catch-exceptions","title":"Catch exceptions","text":"<p>Catching an exception uses a <code>try.... .catch</code> statement, which puts the code where the exception might occur into a <code>try {...}</code>, and then use <code>catch</code> to catch the corresponding <code>Exception</code> and its subclasses:</p> <pre><code>// try...catch\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        byte[] bs = toGBK(\"\u4e2d\u6587\");\n        System.out.println(Arrays.toString(bs));\n    }\n\n    static byte[] toGBK(String s) {\n        try {\n            // \u7528\u6307\u5b9a\u7f16\u7801\u8f6c\u6362String\u4e3abyte[]:\n            return s.getBytes(\"GBK\");\n        } catch (UnsupportedEncodingException e) {\n            // \u5982\u679c\u7cfb\u7edf\u4e0d\u652f\u6301GBK\u7f16\u7801\uff0c\u4f1a\u6355\u83b7\u5230UnsupportedEncodingException:\n            System.out.println(e); // \u6253\u5370\u5f02\u5e38\u4fe1\u606f\n            return s.getBytes(); // \u5c1d\u8bd5\u4f7f\u7528\u9ed8\u8ba4\u7f16\u7801\n        }\n    }\n}\n</code></pre> <p>If we don't catch <code>UnsupportedEncodingException</code>, there will be a compilation failure:</p> <pre><code>// try...catch\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        byte[] bs = toGBK(\"\u4e2d\u6587\");\n        System.out.println(Arrays.toString(bs));\n    }\n\n    static byte[] toGBK(String s) {\n        return s.getBytes(\"GBK\");\n    }\n}\n</code></pre> <p>The compiler reports an error with a message similar to: unreported exception UnsupportedEncodingException; must be caught or declared to be thrown, and pinpoints the statement that needs to be caught as <code>return s.getBytes(\" GBK\");</code>. Meaning that a Checked Exception like <code>UnsupportedEncodingException</code> must be caught.</p> <p>This is because the <code>String.getBytes(String)</code> method definition is:</p> <pre><code>public byte[] getBytes(String charsetName) throws UnsupportedEncodingException {\n    ...\n}\n</code></pre> <p>At the time of method definition, <code>throws Xxx</code> is used to indicate the types of exceptions that may be thrown by the method. The caller must force these exceptions to be caught at the time of the call, otherwise the compiler will report an error.</p> <p>In the <code>toGBK()</code> method, an <code>UnsupportedEncodingException</code> must be caught because the <code>String.getBytes(String)</code> method is called. Instead of catching it, we can also let the <code>toGBK()</code> method pass compiler checking by indicating that the <code>toGBK()</code> method may throw an <code>UnsupportedEncodingException</code> with throws at the method definition:</p> <pre><code>// try...catch\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        byte[] bs = toGBK(\"\u4e2d\u6587\");\n        System.out.println(Arrays.toString(bs));\n    }\n\n    static byte[] toGBK(String s) throws UnsupportedEncodingException {\n        return s.getBytes(\"GBK\");\n    }\n}\n</code></pre> <p>The above code still gets a compile error, but this time, instead of calling <code>return s.getBytes(\"GBK\");</code>, the compiler prompts for <code>byte[] bs = toGBK(\"Chinese\");</code>. This is because the call to <code>toGBK()</code> in the <code>main()</code> method does not catch the <code>UnsupportedEncodingException</code> that it declares may be thrown.</p> <p>The fix is to catch the exception in the <code>main()</code> method and handle it:</p> <pre><code>// try...catch\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            byte[] bs = toGBK(\"\u4e2d\u6587\");\n            System.out.println(Arrays.toString(bs));\n        } catch (UnsupportedEncodingException e) {\n            System.out.println(e);\n        }\n    }\n\n    static byte[] toGBK(String s) throws UnsupportedEncodingException {\n        // \u7528\u6307\u5b9a\u7f16\u7801\u8f6c\u6362String\u4e3abyte[]:\n        return s.getBytes(\"GBK\");\n    }\n}\n</code></pre> <p>As you can see, any Checked Exception declared by a method that is not caught at the calling level must also be caught at a higher calling level. All uncaught exceptions must also eventually be caught in the <code>main()</code> method, and there will be no missed <code>try</code>s. This is guaranteed by the compiler. The <code>main()</code> method is also the last opportunity to catch <code>Exception</code>.</p> <p>The above is slightly more cumbersome to write if you are testing code. If you don't want to write any <code>try</code> code, you can just define the <code>main()</code> method as <code>throws Exception</code>:</p> <pre><code>// try...catch\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        byte[] bs = toGBK(\"\u4e2d\u6587\");\n        System.out.println(Arrays.toString(bs));\n    }\n\n    static byte[] toGBK(String s) throws UnsupportedEncodingException {\n        // \u7528\u6307\u5b9a\u7f16\u7801\u8f6c\u6362String\u4e3abyte[]:\n        return s.getBytes(\"GBK\");\n    }\n}\n</code></pre> <p>Because the <code>main()</code> method declares that <code>Exception</code> may be thrown, it also declares that all <code>Exception</code>s may be thrown, so there is no need to catch them internally. The tradeoff is that the program will exit as soon as the exception occurs.</p> <p>There are also some kids who like to \"digest\" exceptions inside <code>toGBK()</code>:</p> <pre><code>static byte[] toGBK(String s) {\n    try {\n        return s.getBytes(\"GBK\");\n    } catch (UnsupportedEncodingException e) {\n        // \u4ec0\u4e48\u4e5f\u4e0d\u5e72\n    }\n    return null;\n</code></pre> <p>This catch-and-don't-handle approach is very bad; even if you really can't do anything, log the exception first:</p> <pre><code>static byte[] toGBK(String s) {\n    try {\n        return s.getBytes(\"GBK\");\n    } catch (UnsupportedEncodingException e) {\n        // \u5148\u8bb0\u4e0b\u6765\u518d\u8bf4:\n        e.printStackTrace();\n    }\n    return null;\n</code></pre> <p>All exceptions can be printed by calling the <code>printStackTrace()</code> method to print the exception stack, which is a simple and useful way to quickly print exceptions.</p>"},{"location":"40-exception/10-java-exception/#summary","title":"Summary","text":"<p>Java uses exceptions to indicate errors, and catches them via <code>try ... catch</code> to catch exceptions;</p> <p>Java exceptions are <code>class</code> and inherit from <code>Throwable</code>;</p> <p>An <code>Error</code> is a serious error that does not need to be caught, and an <code>Exception</code> is a handleable error that should be caught;</p> <p>A <code>RuntimeException</code> does not need to be forced to be caught, a non-<code>RuntimeException</code> (Checked Exception) needs to be forced to be caught or declared with <code>throws</code>;</p> <p>It is not recommended to catch an exception but not do anything with it.</p>"},{"location":"40-exception/100-slf4j-logback/","title":"SLF4J and Logback","text":""},{"location":"40-exception/100-slf4j-logback/#using-slf4j-and-logback","title":"Using SLF4J and Logback","text":"<p>Previously introduced Commons Logging and Log4j this pair of good friends, they are responsible for acting as a logging API, one is responsible for the implementation of the logging layer, with the use of very easy to develop.</p> <p>Some of you may have heard of SLF4J and Logback, which also look like logs, but what are they?</p> <p>In fact, SLF4J is similar to Commons Logging, which is also a logging interface, and Logback is similar to Log4j, which is a logging implementation.</p> <p>Why is it that with Commons Logging and Log4j, SLF4J and Logback pop up? It's because Java has a very long history of open source, not only is the OpenJDK itself open source, but also the third party libraries that we use, almost all of which are open source. One particular aspect of the rich open source ecosystem is that you can find several competing open source libraries for the same function.</p> <p>Because of dissatisfaction with Commons Logging's interface, someone got SLF4J. Because of dissatisfaction with Log4j's performance, someone got Logback.</p> <p>Let's first look at how SLF4J has improved the interface to Commons Logging. In Commons Logging, we want to print the log, and sometimes we have to write it like this:</p> <pre><code>int score = 99;\np.setScore(score);\nlog.info(\"Set score \" + score + \" for Person \" + p.getName() + \" ok.\");\n</code></pre> <p>Spelling strings is a real pain in the ass, so SLF4J's logging interface was improved to look like this:</p> <pre><code>int score = 99;\np.setScore(score);\nlogger.info(\"Set score {} for Person {} ok.\", score, p.getName());\n</code></pre> <p>We can guess that SLF4J's logging interface passes in a string with a placeholder, and automatically replaces the placeholder with the variable that follows it, so it looks more natural.</p> <p>How to use SLF4J Its interface is actually almost exactly the same as Commons Logging:</p> <pre><code>import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass Main {\n    final Logger logger = LoggerFactory.getLogger(getClass());\n}\n</code></pre> <p>Compare the interfaces of Commons Logging and SLF4J:</p> Commons Logging SLF4J org.apache.commons.logging.Log org.slf4j.Logger org.apache.commons.logging.LogFactory org.slf4j.LoggerFactory <p>The difference is that <code>Log</code> becomes <code>Logger</code> and <code>LogFactory</code> becomes <code>LoggerFactory</code>.</p> <p>The use of SLF4J and Logback is similar to the use of Commons Logging and Log4j as mentioned earlier, first download SLF4J and Logback, and then put the following jar package to the classpath:</p> <ul> <li>slf4j-api-1.7.x.jar</li> <li>logback-classic-1.2.x.jar</li> <li>logback-core-1.2.x.jar</li> </ul> <p>Then just use SLF4J's <code>Logger</code> and <code>LoggerFactory</code>.</p> <p>Similar to Log4j, we still need a Logback configuration file, put <code>logback.xml</code> under the classpath and configure it as follows:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n    &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;\n            &lt;charset&gt;utf-8&lt;/charset&gt;\n        &lt;/encoder&gt;\n        &lt;file&gt;log/output.log&lt;/file&gt;\n        &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.FixedWindowRollingPolicy\"&gt;\n            &lt;fileNamePattern&gt;log/output.log.%i&lt;/fileNamePattern&gt;\n        &lt;/rollingPolicy&gt;\n        &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt;\n            &lt;MaxFileSize&gt;1MB&lt;/MaxFileSize&gt;\n        &lt;/triggeringPolicy&gt;\n    &lt;/appender&gt;\n\n    &lt;root level=\"INFO\"&gt;\n        &lt;appender-ref ref=\"CONSOLE\" /&gt;\n        &lt;appender-ref ref=\"FILE\" /&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre> <p>Run it to get an output similar to the following:</p> <pre><code>13:15:25.328 [main] INFO com.itranswarp.learnjava.Main - Start process...\n</code></pre> <p>From the current trend , more and more open source projects from Commons Logging plus Log4j to SLF4J plus Logback .</p>"},{"location":"40-exception/100-slf4j-logback/#exercise","title":"Exercise","text":"<p>Observe the log files written by Logback according to the configuration file.</p> <p>Download exercise</p>"},{"location":"40-exception/100-slf4j-logback/#summary","title":"Summary","text":"<p>SLF4J and Logback can replace Commons Logging and Log4j;</p> <p>Always use SLF4J's interface to write logs, using Logback requires only configuration and no code changes.</p>"},{"location":"40-exception/20-catch-exception/","title":"Catching Exceptions","text":""},{"location":"40-exception/20-catch-exception/#catch-exceptions","title":"Catch exceptions","text":"<p>In Java, any statement that may throw an exception can be caught with <code>try ... catch</code>. Place statements that may throw exceptions in <code>try { ... }</code> and then use <code>catch</code> to catch the corresponding <code>Exception</code> and its subclasses.</p>"},{"location":"40-exception/20-catch-exception/#multiple-catch-statements","title":"Multiple catch statements","text":"<p>Multiple <code>catch</code> statements can be used, with each <code>catch</code> catching the corresponding <code>Exception</code> and its subclasses.The JVM matches the <code>catch</code> statements from top to bottom after an exception is caught, and when it matches a particular <code>catch</code>, it executes the <code>catch</code> block and doesn't _continue to match.</p> <p>Simply put: only one of multiple <code>catch</code> statements can be executed. Example:</p> <pre><code>public static void main(String[] args) {\n    try {\n        process1();\n        process2();\n        process3();\n    } catch (IOException e) {\n        System.out.println(e);\n    } catch (NumberFormatException e) {\n        System.out.println(e);\n    }\n}\n</code></pre> <p>When multiple <code>catch</code>s exist, the order of the <code>catch</code>s is important: the subclass must be written first. Example:</p> <pre><code>public static void main(String[] args) {\n    try {\n        process1();\n        process2();\n        process3();\n    } catch (IOException e) {\n        System.out.println(\"IO error\");\n    } catch (UnsupportedEncodingException e) { // \u6c38\u8fdc\u6355\u83b7\u4e0d\u5230\n        System.out.println(\"Bad encoding\");\n    }\n}\n</code></pre> <p>For the code above, the <code>UnsupportedEncodingException</code> exception is never caught because it is a subclass of <code>IOException</code>. When the <code>UnsupportedEncodingException</code> exception is thrown, it is caught by <code>catch (IOException e) { ... }</code> is caught and executed.</p> <p>Therefore, the correct way to write it is to put the subclass in front:</p> <pre><code>public static void main(String[] args) {\n    try {\n        process1();\n        process2();\n        process3();\n    } catch (UnsupportedEncodingException e) {\n        System.out.println(\"Bad encoding\");\n    } catch (IOException e) {\n        System.out.println(\"IO error\");\n    }\n}\n</code></pre>"},{"location":"40-exception/20-catch-exception/#finally-statement","title":"finally statement","text":"<p>Regardless of whether an exception occurs or not, how do we write statements if we wish to execute something, such as a cleanup job?</p> <p>You can write the execution statement a number of times: the normal execution is put into <code>try</code>, and each <code>catch</code> is written again. Example:</p> <pre><code>public static void main(String[] args) {\n    try {\n        process1();\n        process2();\n        process3();\n        System.out.println(\"END\");\n    } catch (UnsupportedEncodingException e) {\n        System.out.println(\"Bad encoding\");\n        System.out.println(\"END\");\n    } catch (IOException e) {\n        System.out.println(\"IO error\");\n        System.out.println(\"END\");\n    }\n}\n</code></pre> <p>The above code executes the statement <code>System.out.println(\"END\");</code> whether or not an exception occurs.</p> <p>So how do you eliminate this repetitive code?Java's <code>try ... catch</code> mechanism also provides <code>finally</code> statements, <code>finally</code> blocks that are guaranteed to execute with or without errors. The above code can be rewritten as follows:</p> <pre><code>public static void main(String[] args) {\n    try {\n        process1();\n        process2();\n        process3();\n    } catch (UnsupportedEncodingException e) {\n        System.out.println(\"Bad encoding\");\n    } catch (IOException e) {\n        System.out.println(\"IO error\");\n    } finally {\n        System.out.println(\"END\");\n    }\n}\n</code></pre> <p>Note that <code>finally</code> has several features:</p> <ol> <li>The <code>finally</code> statement is not required and may or may not be written;</li> <li><code>finally</code> is always executed last.</li> </ol> <p>If no exception occurs, execute the <code>try { ... }</code> block and then execute <code>finally</code>. If an exception occurs, you interrupt execution of the <code>try { ... }</code> block, then skip to the matching <code>catch</code> block, and finally execute <code>finally</code>.</p> <p>As you can see, <code>finally</code> is used to ensure that some code must be executed.</p> <p>In some cases, it is possible to have no <code>catch</code> and just use the <code>try ... finally</code> structure. Example:</p> <pre><code>void process(String file) throws IOException {\n    try {\n        ...\n    } finally {\n        System.out.println(\"END\");\n    }\n}\n</code></pre> <p>Because the method declares exceptions that may be thrown, you can leave out <code>catch</code>.</p>"},{"location":"40-exception/20-catch-exception/#catch-multiple-exceptions","title":"Catch multiple exceptions","text":"<p>If some exceptions have the same handling logic, but the exceptions themselves are not inherited, then multiple <code>catch</code> clauses have to be written:</p> <pre><code>public static void main(String[] args) {\n    try {\n        process1();\n        process2();\n        process3();\n    } catch (IOException e) {\n        System.out.println(\"Bad input\");\n    } catch (NumberFormatException e) {\n        System.out.println(\"Bad input\");\n    } catch (Exception e) {\n        System.out.println(\"Unknown error\");\n    }\n}\n</code></pre> <p>Since the code that handles <code>IOException</code> and <code>NumberFormatException</code> is the same, we can merge the two together with <code>|</code>:</p> <pre><code>public static void main(String[] args) {\n    try {\n        process1();\n        process2();\n        process3();\n    } catch (IOException | NumberFormatException e) {\n        // IOException\u6216NumberFormatException\n        System.out.println(\"Bad input\");\n    } catch (Exception e) {\n        System.out.println(\"Unknown error\");\n    }\n}\n</code></pre>"},{"location":"40-exception/20-catch-exception/#exercise","title":"Exercise","text":"<p>Use <code>try ... catch</code> to catch exceptions and handle them.</p> <p>Download exercise</p>"},{"location":"40-exception/20-catch-exception/#summary","title":"Summary","text":"<p>When catching exceptions, the order in which multiple <code>catch</code> statements are matched is very important, and the subclass must come first;</p> <p>The <code>finally</code> statement guarantees that it will be executed with or without an exception; it is optional;</p> <p>A <code>catch</code> statement can also match multiple exceptions that are not inherited relationships.</p>"},{"location":"40-exception/30-throw-exception/","title":"Throwing Exceptions","text":""},{"location":"40-exception/30-throw-exception/#throw-an-exception","title":"Throw an exception","text":""},{"location":"40-exception/30-throw-exception/#the-propagation-of-anomalies","title":"The propagation of anomalies","text":"<p>When a method throws an exception, if the current method doesn't catch the exception, the exception is thrown to the higher level calling method until it encounters some <code>try ... catch</code> is caught:</p> <pre><code>// exception\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            process1();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    static void process1() {\n        process2();\n    }\n\n    static void process2() {\n        Integer.parseInt(null); // \u4f1a\u629b\u51faNumberFormatException\n    }\n}\n</code></pre> <p>With <code>printStackTrace()</code> you can print out the call stack of a method, similarly:</p> <pre><code>java.lang.NumberFormatException: null\n    at java.base/java.lang.Integer.parseInt(Integer.java:614)\n    at java.base/java.lang.Integer.parseInt(Integer.java:770)\n    at Main.process2(Main.java:16)\n    at Main.process1(Main.java:12)\n    at Main.main(Main.java:5)\n</code></pre> <p>The <code>printStackTrace()</code> is very useful for debugging errors, and the above message says: <code>NumberFormatException</code> was thrown in the <code>java.lang.Integer.parseInt</code> method, and the calling hierarchy is in order from the bottom up:</p> <ol> <li><code>main()</code> calls <code>process1()</code>;</li> <li><code>process1()</code> calls <code>process2()</code>;</li> <li><code>process2()</code> calls <code>Integer.parseInt(String)</code>;</li> <li><code>Integer.parseInt(String)</code> calling <code>Integer.parseInt(String, int)</code>.</li> </ol> <p>A look at the <code>Integer.java</code> source code shows that the code for the method that throws the exception is as follows:</p> <pre><code>public static int parseInt(String s, int radix) throws NumberFormatException {\n    if (s == null) {\n        throw new NumberFormatException(\"null\");\n    }\n    ...\n}\n</code></pre> <p>Moreover, the line numbers of the source code are given for each level of calls, which can be directly located.</p>"},{"location":"40-exception/30-throw-exception/#throw-an-exception_1","title":"Throw an exception","text":"<p>When an error occurs, for example, the user enters an illegal character, we can throw an exception.</p> <p>How to throw an exception? Referring to the <code>Integer.parseInt()</code> method, throwing an exception is done in two steps:</p> <ol> <li>Create an instance of <code>Exception</code>;</li> <li>throw it with a <code>throw</code> statement.</li> </ol> <p>Here is an example:</p> <pre><code>void process2(String s) {\n    if (s==null) {\n        NullPointerException e = new NullPointerException();\n        throw e;\n    }\n}\n</code></pre> <p>In fact, the vast majority of code that throws exceptions is merged and written on one line:</p> <pre><code>void process2(String s) {\n    if (s==null) {\n        throw new NullPointerException();\n    }\n}\n</code></pre> <p>If a method catches an exception and then throws a new exception in a <code>catch</code> clause, it is equivalent to \"converting\" the type of exception thrown:</p> <pre><code>void process1(String s) {\n    try {\n        process2();\n    } catch (NullPointerException e) {\n        throw new IllegalArgumentException();\n    }\n}\n\nvoid process2(String s) {\n    if (s==null) {\n        throw new NullPointerException();\n    }\n}\n</code></pre> <p>When <code>process2()</code> throws <code>NullPointerException</code>, it is caught by <code>process1()</code>, which then throws <code>IllegalArgumentException()</code>.</p> <p>If <code>IllegalArgumentException</code> is caught in <code>main()</code>, let's take a look at the printed exception stack:</p> <pre><code>// exception\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            process1();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    static void process1() {\n        try {\n            process2();\n        } catch (NullPointerException e) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    static void process2() {\n        throw new NullPointerException();\n    }\n}\n</code></pre> <p>The printed exception stack is similar:</p> <pre><code>java.lang.IllegalArgumentException\n    at Main.process1(Main.java:15)\n    at Main.main(Main.java:5)\n</code></pre> <p>This means that the new exception has lost the original exception information and we can no longer see the original exception <code>NullPointerException</code>.</p> <p>To be able to trace the full exception stack, pass in the original <code>Exception</code> instance when constructing the exception, and the new <code>Exception</code> will hold the original <code>Exception</code> information. Improvements to the above code are as follows:</p> <pre><code>// exception\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            process1();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    static void process1() {\n        try {\n            process2();\n        } catch (NullPointerException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    static void process2() {\n        throw new NullPointerException();\n    }\n}\n</code></pre> <p>Running the above code prints out a similar exception stack:</p> <pre><code>java.lang.IllegalArgumentException: java.lang.NullPointerException\n    at Main.process1(Main.java:15)\n    at Main.main(Main.java:5)\nCaused by: java.lang.NullPointerException\n    at Main.process2(Main.java:20)\n    at Main.process1(Main.java:13)\n</code></pre> <p>Notice the <code>Caused by: Xxx</code>, indicating that the caught <code>IllegalArgumentException</code> is not the root cause of the problem, the root cause is the <code>NullPointerException</code>, which is thrown in the <code>Main.process2()</code> method.</p> <p>The <code>Throwable.getCause()</code> method can be used to get the original exception in code. If it returns <code>null</code>, it is already a root exception.</p> <p>With complete information about the exception stack, we can quickly locate and fix problems with the code.</p> <p>[!NOTICE]\u6700\u4f73\u5b9e\u8df5</p> <p>\u6355\u83b7\u5230\u5f02\u5e38\u5e76\u518d\u6b21\u629b\u51fa\u65f6\uff0c\u4e00\u5b9a\u8981\u7559\u4f4f\u539f\u59cb\u5f02\u5e38\uff0c\u5426\u5219\u5f88\u96be\u5b9a\u4f4d\u7b2c\u4e00\u6848\u53d1\u73b0\u573a\uff01</p> <p>If we throw an exception in a <code>try</code> or <code>catch</code> statement block, does the <code>finally</code> statement execute? Example:</p> <pre><code>// exception\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            Integer.parseInt(\"abc\");\n        } catch (Exception e) {\n            System.out.println(\"catched\");\n            throw new RuntimeException(e);\n        } finally {\n            System.out.println(\"finally\");\n        }\n    }\n}\n</code></pre> <p>The result of the execution of the above code is as follows:</p> <pre><code>catched\nfinally\nException in thread \"main\" java.lang.RuntimeException: java.lang.NumberFormatException: For input string: \"abc\"\n    at Main.main(Main.java:8)\nCaused by: java.lang.NumberFormatException: For input string: \"abc\"\n    at ...\n</code></pre> <p>The first line prints <code>catched</code>, indicating that the <code>catch</code> statement block was entered. The second line prints <code>finally</code>, indicating that the <code>finally</code> block was executed.</p> <p>Therefore, throwing an exception in <code>catch</code> will not affect the execution of <code>finally</code>.The JVM will execute <code>finally</code> first and then throw the exception.</p>"},{"location":"40-exception/30-throw-exception/#anomaly-masking","title":"Anomaly masking","text":"<p>If an exception is thrown during the execution of a <code>finally</code> statement, can the exception for the <code>catch</code> statement continue to be thrown? Example:</p> <pre><code>// exception\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            Integer.parseInt(\"abc\");\n        } catch (Exception e) {\n            System.out.println(\"catched\");\n            throw new RuntimeException(e);\n        } finally {\n            System.out.println(\"finally\");\n            throw new IllegalArgumentException();\n        }\n    }\n}\n</code></pre> <p>The above code is executed and the following exception message is found:</p> <pre><code>catched\nfinally\nException in thread \"main\" java.lang.IllegalArgumentException\n    at Main.main(Main.java:11)\n</code></pre> <p>This means that when <code>finally</code> throws an exception, the exception that was going to be thrown in <code>catch</code> \"disappears\", because only one exception can be thrown. Exceptions that are not thrown are called \"suppressed exceptions\".</p> <p>In rare cases, we need to be informed of all exceptions. How to save all the exception information? The way to do it is to first save the original exception with the <code>origin</code> variable, then call <code>Throwable.addSuppressed()</code> to add the original exception, and finally throw it in <code>finally</code>:</p> <pre><code>// exception\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Exception origin = null;\n        try {\n            System.out.println(Integer.parseInt(\"abc\"));\n        } catch (Exception e) {\n            origin = e;\n            throw e;\n        } finally {\n            Exception e = new IllegalArgumentException();\n            if (origin != null) {\n                e.addSuppressed(origin);\n            }\n            throw e;\n        }\n    }\n}\n</code></pre> <p>When both <code>catch</code> and <code>finally</code> throw exceptions, the exception thrown by <code>finally</code> still contains it, even though the <code>catch</code> exception is masked:</p> <pre><code>Exception in thread \"main\" java.lang.IllegalArgumentException\n    at Main.main(Main.java:11)\nSuppressed: java.lang.NumberFormatException: For input string: \"abc\"\n    at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\n    at java.base/java.lang.Integer.parseInt(Integer.java:652)\n    at java.base/java.lang.Integer.parseInt(Integer.java:770)\n    at Main.main(Main.java:6)\n</code></pre> <p>All <code>Suppressed Exception</code>s can be obtained via <code>Throwable.getSuppressed()</code>.</p> <p>In the vast majority of cases, don't throw exceptions in <code>finally</code>. Therefore, we usually don't need to care about <code>Suppressed Exception</code>.</p>"},{"location":"40-exception/30-throw-exception/#post-an-exception-when-asking-a-question","title":"Post an exception when asking a question","text":"<p>The detailed stack information printed by the exception is the key to find out the problem, many beginners in the question only post the code, not the exception, the equivalent of only report the case without giving clues, Holmes can not do anything.</p> <p></p> <p>Some other kids only post part of the anomaly information, the most critical <code>Caused by: xxx</code> is omitted, this is the incorrect way to ask the question, need to be changed.</p>"},{"location":"40-exception/30-throw-exception/#exercise","title":"Exercise","text":"<p>Throws <code>IllegalArgumentException</code> if the passed argument is negative.</p> <p>Download exercise</p>"},{"location":"40-exception/30-throw-exception/#summary","title":"Summary","text":"<p>Calling <code>printStackTrace()</code> prints the exception propagation stack, which is useful for debugging;</p> <p>When an exception is caught and a new exception is thrown again, the original exception information should be held;</p> <p>Normally do not throw exceptions in <code>finally</code>. If an exception is thrown in <code>finally</code>, the original exception should be added to the original exception. The caller can get all added <code>Suppressed Exception</code>s via <code>Throwable.getSuppressed()</code>.</p>"},{"location":"40-exception/40-custom-exception/","title":"Custom Exceptions","text":""},{"location":"40-exception/40-custom-exception/#customized-exceptions","title":"Customized exceptions","text":"<p>Common exceptions defined by the Java Standard Library include:</p> <pre><code>Exception\n\u251c\u2500 RuntimeException\n\u2502  \u251c\u2500 NullPointerException\n\u2502  \u251c\u2500 IndexOutOfBoundsException\n\u2502  \u251c\u2500 SecurityException\n\u2502  \u2514\u2500 IllegalArgumentException\n\u2502     \u2514\u2500 NumberFormatException\n\u251c\u2500 IOException\n\u2502  \u251c\u2500 UnsupportedCharsetException\n\u2502  \u251c\u2500 FileNotFoundException\n\u2502  \u2514\u2500 SocketException\n\u251c\u2500 ParseException\n\u251c\u2500 GeneralSecurityException\n\u251c\u2500 SQLException\n\u2514\u2500 TimeoutException\n</code></pre> <p>When we need to throw exceptions in our code, we try to use the exception types already defined by the JDK. For example, <code>IllegalArgumentException</code> should be thrown for illegal argument checking:</p> <pre><code>static void process1(int age) {\n    if (age &lt;= 0) {\n        throw new IllegalArgumentException();\n    }\n}\n</code></pre> <p>In a large project, it is possible to customize new exception types, but it is important to maintain a sensible exception inheritance system.</p> <p>A common practice is to customize a <code>BaseException</code> as the <code>root exception</code> and then, derive exceptions for various business types.</p> <p><code>BaseException</code> needs to be derived from a suitable <code>Exception</code>, and it is usually recommended to derive it from <code>RuntimeException</code>:</p> <pre><code>public class BaseException extends RuntimeException {\n}\n</code></pre> <p>Exceptions for other business types can then be derived from <code>BaseException</code>:</p> <pre><code>public class UserNotFoundException extends BaseException {\n}\n\npublic class LoginFailedException extends BaseException {\n}\n\n...\n</code></pre> <p>A custom <code>BaseException</code> should provide multiple constructor methods:</p> <pre><code>public class BaseException extends RuntimeException {\n    public BaseException() {\n        super();\n    }\n\n    public BaseException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    public BaseException(String message) {\n        super(message);\n    }\n\n    public BaseException(Throwable cause) {\n        super(cause);\n    }\n}\n</code></pre> <p>All of the above constructors actually copy <code>RuntimeException</code> as is. This way, when an exception is thrown, the appropriate constructor method can be chosen. The IDE makes it possible to quickly generate constructor methods for subclasses based on the parent class.</p>"},{"location":"40-exception/40-custom-exception/#exercise","title":"Exercise","text":"<p>Please derive custom exceptions from <code>BaseException</code>.</p> <p>Download exercise</p>"},{"location":"40-exception/40-custom-exception/#summary","title":"Summary","text":"<p>When throwing exceptions, try to reuse the exception types already defined by the JDK;</p> <p>When customizing the exception system, it is recommended to derive the \"root exception\" from <code>RuntimeException</code> and then derive the business exception;</p> <p>When customizing exceptions, multiple constructor methods should be provided.</p>"},{"location":"40-exception/50-null-pointer-exception/","title":"NullPointerException","text":""},{"location":"40-exception/50-null-pointer-exception/#nullpointerexception","title":"NullPointerException","text":"<p>Of all the <code>RuntimeException</code> exceptions, the one Java programmers are most familiar with is probably the <code>NullPointerException</code>.</p> <p><code>NullPointerException</code> i.e. Null Pointer Exception, commonly known as NPE. if an object is <code>null</code>, calling its methods or accessing its fields will generate a <code>NullPointerException</code>, which is usually thrown by the JVM, for example:</p> <pre><code>// NullPointerException\npublic class Main {\n    public static void main(String[] args) {\n        String s = null;\n        System.out.println(s.toLowerCase());\n    }\n}\n</code></pre> <p>The concept of pointers actually originated in C. There are no pointers in Java. The variables we define are actually references, and a Null Pointer is more accurately called a Null Reference, although there is little difference between the two.</p>"},{"location":"40-exception/50-null-pointer-exception/#handling-nullpointerexception","title":"Handling NullPointerException","text":"<p>What should we do if we encounter a <code>NullPointerException</code>? First of all, it must be clear that <code>NullPointerException</code> is a kind of code logic error, encounter <code>NullPointerException</code>, follow the principle of early exposure, early repair, strictly prohibit the use of <code>catch</code> to hide this kind of coding error:</p> <pre><code>// \u9519\u8bef\u793a\u4f8b: \u6355\u83b7NullPointerException\ntry {\n    transferMoney(from, to, amount);\n} catch (NullPointerException e) {\n}\n</code></pre> <p>Good coding habits can greatly reduce the generation of <code>NullPointerException</code>, for example:</p> <p>Member variables are initialized at definition time:</p> <pre><code>public class Person {\n    private String name = \"\";\n}\n</code></pre> <p>Using the empty string <code>\"\"</code> instead of the default <code>null</code> avoids a lot of <code>NullPointerException</code>, and it is much safer to write business logic with the empty string <code>\"\"</code> to indicate that it is not filled in than <code>null</code>.</p> <p>Returns the empty string <code>\"\"</code>, the empty array instead of <code>null</code>:</p> <pre><code>public String[] readLinesFromFile(String file) {\n    if (getFileSize(file) == 0) {\n        // \u8fd4\u56de\u7a7a\u6570\u7ec4\u800c\u4e0d\u662fnull:\n        return new String[0];\n    }\n    ...\n}\n</code></pre> <p>This makes it unnecessary for the caller to check if the result is <code>null</code>.</p> <p>If the caller must judge based on <code>null</code>, such as returning <code>null</code> to indicate that the file does not exist, then consider returning <code>Optional&lt;T&gt;</code>:</p> <pre><code>public Optional&lt;String&gt; readFromFile(String file) {\n    if (!fileExist(file)) {\n        return Optional.empty();\n    }\n    ...\n}\n</code></pre> <p>This way the caller must determine if there is a result by <code>Optional.isPresent()</code>.</p>"},{"location":"40-exception/50-null-pointer-exception/#locating-nullpointerexception","title":"Locating NullPointerException","text":"<p>If a <code>NullPointerException</code> is generated, e.g., a call to <code>a.b.c.x()</code> generates a <code>NullPointerException</code>, the cause may be:</p> <ul> <li><code>a</code> is <code>null</code>;</li> <li><code>a.b</code> is <code>null</code>;</li> <li><code>a.b.c</code> is <code>null</code>;</li> </ul> <p>Determining exactly which object is <code>null</code> can only print such a log until then:</p> <pre><code>System.out.println(a);\nSystem.out.println(a.b);\nSystem.out.println(a.b.c);\n</code></pre> <p>Starting with Java 14, if a <code>NullPointerException</code> is thrown, the JVM can give us detailed information about who the <code>null</code> object actually is. Let's look at the example:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        Person p = new Person();\n        System.out.println(p.address.city.toLowerCase());\n    }\n}\n\nclass Person {\n    String[] name = new String[2];\n    Address address = new Address();\n}\n\nclass Address {\n    String city;\n    String street;\n    String zipcode;\n}\n</code></pre> <p>It is possible to see in the <code>NullPointerException</code> details something like <code>... because \"&lt;local1&gt;.address.city\" is null</code>, meaning that the <code>city</code> field is <code>null</code>, so we can quickly pinpoint the problem.</p> <p>This enhanced <code>NullPointerException</code> details is a new feature in Java 14, but is turned off by default, we can enable it by adding a <code>-XX:+ShowCodeDetailsInExceptionMessages</code> parameter to the JVM:</p> <pre><code>java -XX:+ShowCodeDetailsInExceptionMessages Main.java\n</code></pre>"},{"location":"40-exception/50-null-pointer-exception/#summary","title":"Summary","text":"<p><code>NullPointerException</code> is a common logic error in Java code and should be exposed and fixed early;</p> <p>Enhanced exception messages for Java 14 can be enabled to view detailed error messages for <code>NullPointerException</code>.</p>"},{"location":"40-exception/60-assert/","title":"Assertions (`assert`)","text":""},{"location":"40-exception/60-assert/#use-of-assertions","title":"Use of assertions","text":"<p>Assertion is a way to debug a program. In Java, assertion is implemented using the <code>assert</code> keyword.</p> <p>Let's look at an example first:</p> <pre><code>public static void main(String[] args) {\n    double x = Math.abs(-123.45);\n    assert x &gt;= 0;\n    System.out.println(x);\n}\n</code></pre> <p>The statement <code>assert x &gt;= 0;</code> is an assertion, and the assertion condition <code>x &gt;= 0</code> is expected to be <code>true</code>. If the result of the computation is <code>false</code>, the assertion fails and <code>AssertionError</code> is thrown.</p> <p>An optional assertion message can also be added when using the <code>assert</code> statement:</p> <pre><code>assert x &gt;= 0 : \"x must &gt;= 0\";\n</code></pre> <p>This way, when the assertion fails, <code>AssertionError</code> will carry the message <code>x must &gt;= 0</code>, making it easier to debug.</p> <p>Java assertions are characterized by the fact that <code>AssertionError</code> is thrown when the assertion fails, causing the program to end and exit. Therefore, assertions should not be used for recoverable program errors and should only be used in the development and testing phases.</p> <p>Assertions should not be used for recoverable program errors. Example:</p> <pre><code>void sort(int[] arr) {\n    assert arr != null;\n}\n</code></pre> <p>Exceptions should be thrown and caught at higher levels:</p> <pre><code>void sort(int[] arr) {\n    if (arr == null) {\n        throw new IllegalArgumentException(\"array cannot be null\");\n    }\n}\n</code></pre> <p>When we use <code>assert</code> in a program, for example, a simple assertion:</p> <pre><code>// assert\npublic class Main {\n    public static void main(String[] args) {\n        int x = -1;\n        assert x &gt; 0;\n        System.out.println(x);\n    }\n}\n</code></pre> <p>Asserting that <code>x</code> must be greater than <code>0</code>, when in fact <code>x</code> is <code>-1</code>, the assertion must have failed. Executing the above code, I found that the program did not throw <code>AssertionError</code>, but printed the value of <code>x</code> normally.</p> <p>What's going on here? Why doesn't the <code>assert</code> statement work?</p> <p>This is because the JVM turns off the assertion directive by default, i.e., it automatically ignores the <code>assert</code> statement when it encounters it and does not execute it.</p> <p>To execute the <code>assert</code> statement, assertions must be enabled by passing the <code>-enableassertions</code> (which can be abbreviated as <code>-ea</code>) parameter to the Java Virtual Machine. Therefore, the above program must be run from the command line to be effective:</p> <pre><code>$ java -ea Main.java\nException in thread \"main\" java.lang.AssertionError\n    at Main.main(Main.java:5)\n</code></pre> <p>Assertions can also be selectively enabled for specific classes, with the command line argument: <code>-ea:com.itranswarp.sample.Main</code>, which means that assertions are enabled only for the class <code>com.itranswarp.sample.Main</code>.</p> <p>Or to enable assertions for specific packages, the command line argument is: <code>-ea:com.itranswarp.sample...</code> (note the 3 <code>.</code>), which enables assertions for the package <code>com.itranswarp.sample</code>.</p> <p>In practice, assertions are rarely used in development. A better approach is to write unit tests, and we'll explain the use of <code>JUnit</code> later.</p>"},{"location":"40-exception/60-assert/#summary","title":"Summary","text":"<p>Assertion is a debugging method that throws <code>AssertionError</code> if it fails, and should only be enabled during the development and testing phases;</p> <p>Assertions should not be used for recoverable errors; instead, exceptions should be thrown;</p> <p>Assertions are rarely used, and a better approach is to write unit tests.</p>"},{"location":"40-exception/70-jdk-logging/","title":"JDK Logging","text":""},{"location":"40-exception/70-jdk-logging/#using-jdk-logging","title":"Using JDK Logging","text":"<p>In the process of writing a program, what to do when you find that the result of running the program is not as expected? Of course, it is to use <code>System.out.println()</code> to print out certain variables during execution, observe whether the result of each step is consistent with the code logic, and then modify the code in a targeted manner.</p> <p>What to do when the code is changed? Remove the useless <code>System.out.println()</code> statement, of course.</p> <p>What if I change the code and then change the problem? Add <code>System.out.println()</code>.</p> <p>Repeat this a few times and soon everyone realizes that using <code>System.out.println()</code> is very cumbersome.</p> <p>What to do?</p> <p>The solution is to use logs.</p> <p>So what is logging? Logging is Logging, which is meant to replace <code>System.out.println()</code>.</p> <p>Outputting the log instead of using <code>System.out.println()</code> has several advantages:</p> <ol> <li>You can set the output style to avoid writing <code>\"ERROR: \" + var</code> every time;</li> <li>you can set the output level to disable certain levels of output. For example, only the error log is output;</li> <li>can be redirected to a file so that the log can be viewed at the end of the program run;</li> <li>you can control the logging level by package name to output only logs typed by certain packages;</li> <li>can be ......</li> </ol> <p>In short, there are a lot of benefits.</p> <p>How does that work with logs?</p> <p>Because the Java standard library has a built-in logging package <code>java.util.logging</code>, we can use it directly. Let's look at a simple example:</p> <pre><code>// logging\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class Hello {\n    public static void main(String[] args) {\n        Logger logger = Logger.getGlobal();\n        logger.info(\"start process...\");\n        logger.warning(\"memory is running out...\");\n        logger.fine(\"ignored.\");\n        logger.severe(\"process will be terminated...\");\n    }\n}\n</code></pre> <p>Running the above code gives an output similar to the following:</p> <pre><code>Mar 02, 2019 6:32:13 PM Hello main\nINFO: start process...\nMar 02, 2019 6:32:13 PM Hello main\nWARNING: memory is running out...\nMar 02, 2019 6:32:13 PM Hello main\nSEVERE: process will be terminated...\n</code></pre> <p>As you can see by comparison, the biggest benefit of using logging is that it automatically prints the time, calling class, calling method, and a lot of other useful information.</p> <p>Looking more closely, I found that 4 logs, only 3 are printed, <code>logger.fine()</code> is not printed. This is because the output of the log can be set at a level.JDK Logging defines 7 logging levels, from severe to normal:</p> <ul> <li>SEVERE</li> <li>WARNING</li> <li>INFO</li> <li>CONFIG</li> <li>FINE</li> <li>FINER</li> <li>FINEST</li> </ul> <p>Because the default level is INFO, logs below the INFO level are not printed. The advantage of using logging levels is that by adjusting the level, you can block out a lot of debugging-related logging output.</p> <p>Using Logging built into the Java Standard Library has the following limitations:</p> <p>The Logging system reads the configuration file and completes the initialization when the JVM starts, and once it starts running the <code>main()</code> method, it is not possible to modify the configuration;</p> <p>Configuration is less convenient and requires passing the parameter <code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code> at JVM startup.</p> <p>As a result, the Java standard library built-in Logging is not very widely used. We will introduce a more convenient logging system later.</p>"},{"location":"40-exception/70-jdk-logging/#exercise","title":"Exercise","text":"<p>Use <code>logger.severe()</code> to print the exception:</p> <pre><code>import java.io.UnsupportedEncodingException;\nimport java.util.logging.Logger;\n\npublic class Main {\n    public static void main(String[] args) {\n        Logger logger = Logger.getLogger(Main.class.getName());\n        logger.info(\"Start process...\");\n        try {\n            \"\".getBytes(\"invalidCharsetName\");\n        } catch (UnsupportedEncodingException e) {\n            // TODO: \u4f7f\u7528logger.severe()\u6253\u5370\u5f02\u5e38\n        }\n        logger.info(\"Process end.\");\n    }\n}\n</code></pre> <p>Download Exercise</p>"},{"location":"40-exception/70-jdk-logging/#summary","title":"Summary","text":"<p>Logging is meant to be a replacement for <code>System.out.println()</code> and can define formats, redirect to files, etc;</p> <p>Logs can be archived for easy tracking of issues;</p> <p>Log records can be categorized by level, making it easy to turn certain levels on or off;</p> <p>Logging can be adjusted according to the configuration file without modifying the code;</p> <p>The Java standard library provides <code>java.util.logging</code> to implement logging functionality.</p>"},{"location":"40-exception/80-commons-logging/","title":"Commons Logging","text":""},{"location":"40-exception/80-commons-logging/#use-commons-logging","title":"Use Commons Logging","text":"<p>Unlike the logging provided by the Java standard library, Commons Logging is a third-party logging library, which is a logging module created by Apache.</p> <p>Commons Logging features the ability to hook up different logging systems and specify which logging system to hook up via a configuration file. By default, Commons Loggin automatically searches for and uses Log4j (Log4j is another popular logging system), and then uses JDK Logging if Log4j is not found.</p> <p>There are only two classes to deal with using Commons Logging, and it's only a two-step process:</p> <p>In the first step, get an instance of the <code>Log</code> class through <code>LogFactory</code>; In the second step, use the methods of the <code>Log</code> instance to type the log.</p> <p>The sample code is as follows:</p> <pre><code>import org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\npublic class Main {\n    public static void main(String[] args) {\n        Log log = LogFactory.getLog(Main.class);\n        log.info(\"start...\");\n        log.warn(\"end.\");\n    }\n}\n</code></pre> <p>Running the above code will definitely get a compile error, something like <code>error: package org.apache.commons.logging does not exist</code> (the package <code>org.apache.commons.logging</code> could not be found). Since Commons Logging is a library provided by a third party, you must download it first. After downloading it, unzip it, find the file <code>commons-logging-1.2.jar</code>, and put the Java source code <code>Main.java</code> into a directory, such as the <code>work</code> directory:</p> <pre><code>work\n\u251c\u2500 commons-logging-1.2.jar\n\u2514\u2500 Main.java\n</code></pre> <p>Then compile <code>Main.java</code> with <code>javac</code>, specifying <code>classpath</code> when compiling, otherwise the compiler won't be able to find the <code>org.apache.commons.logging</code> package we referenced. The compilation command is as follows:</p> <pre><code>javac -cp commons-logging-1.2.jar Main.java\n</code></pre> <p>If the compilation is successful, then there will be an additional <code>Main.class</code> file in the current directory:</p> <pre><code>work\n\u251c\u2500 commons-logging-1.2.jar\n\u251c\u2500 Main.java\n\u2514\u2500 Main.class\n</code></pre> <p>This <code>Main.class</code> can now be executed, using the <code>java</code> command, which must also specify the <code>classpath</code>, with the following command:</p> <pre><code>java -cp .;commons-logging-1.2.jar Main\n</code></pre> <p>Notice that the incoming <code>classpath</code> has two parts: a <code>.</code> and one for <code>commons-logging-1.2.jar</code>, split by <code>;</code>. The <code>.</code> indicates the current directory; without this <code>.</code>, the JVM will not search for <code>Main.class</code> in the current directory, and will report an error.</p> <p>If running under Linux or macOS, note that the separator for <code>classpath</code> is not <code>;</code>, but <code>:</code>:</p> <pre><code>java -cp .:commons-logging-1.2.jar Main\n</code></pre> <p>The results of the run are as follows:</p> <pre><code>Mar 02, 2019 7:15:31 PM Main main\nINFO: start...\nMar 02, 2019 7:15:31 PM Main main\nWARNING: end.\n</code></pre> <p>Commons Logging defines six logging levels:</p> <ul> <li>FATAL</li> <li>ERROR</li> <li>WARNING</li> <li>INFO</li> <li>DEBUG</li> <li>TRACE</li> </ul> <p>The default level is <code>INFO</code>.</p> <p>When using Commons Logging, it is usually straightforward to define a static type variable if <code>Log</code> is referenced in a static method:</p> <pre><code>// \u5728\u9759\u6001\u65b9\u6cd5\u4e2d\u5f15\u7528Log:\npublic class Main {\n    static final Log log = LogFactory.getLog(Main.class);\n\n    static void foo() {\n        log.info(\"foo\");\n    }\n}\n</code></pre> <p>Referencing <code>Log</code> in an instance method usually defines an instance variable:</p> <pre><code>// \u5728\u5b9e\u4f8b\u65b9\u6cd5\u4e2d\u5f15\u7528Log:\npublic class Person {\n    protected final Log log = LogFactory.getLog(getClass());\n\n    void foo() {\n        log.info(\"foo\");\n    }\n}\n</code></pre> <p>Notice that the instance variable log is obtained by <code>LogFactory.getLog(getClass())</code>, and while it is also possible to use <code>LogFactory.getLog(Person.class)</code>, the former approach has the very great advantage that subclasses can use that <code>log</code> instance directly. Example:</p> <pre><code>// \u5728\u5b50\u7c7b\u4e2d\u4f7f\u7528\u7236\u7c7b\u5b9e\u4f8b\u5316\u7684log:\npublic class Student extends Person {\n    void bar() {\n        log.info(\"bar\");\n    }\n}\n</code></pre> <p>Due to the dynamic nature of Java classes, the <code>log</code> field fetched by the subclass is actually equivalent to <code>LogFactory.getLog(Student.class)</code>, but is inherited from the parent class and requires no code changes.</p> <p>In addition, Commons Logging's logging methods, such as <code>info()</code>, provide a very useful overloaded method, <code>info(String, Throwable)</code>, in addition to the standard <code>info(String)</code>, which makes logging exceptions much easier:</p> <pre><code>try {\n    ...\n} catch (Exception e) {\n    log.error(\"got exception!\", e);\n}\n</code></pre>"},{"location":"40-exception/80-commons-logging/#exercise","title":"Exercise","text":"<p>Use <code>log.error(String, Throwable)</code> to print the exception.</p> <p>Download exercise</p>"},{"location":"40-exception/80-commons-logging/#summary","title":"Summary","text":"<p>Commons Logging is the most widely used logging module;</p> <p>The Commons Logging API is very simple;</p> <p>Commons Logging can automatically detect and use other logging modules.</p>"},{"location":"40-exception/90-log4j/","title":"Log4j","text":""},{"location":"40-exception/90-log4j/#using-log4j","title":"Using Log4j","text":"<p>Previously introduced Commons Logging, can be used as a \"logging interface\". The real \"logging implementation\" can use Log4j.</p> <p>Log4j is a very popular logging framework, the latest version is 2.x.</p> <p>Log4j is a componentized design of the logging system, its architecture is roughly as follows:</p> <pre><code>log.info(\"User signed in.\");\n \u2502\n \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u251c\u2500\u2500\u25b6\u2502 Appender \u2502\u2500\u2500\u2500\u25b6\u2502  Filter  \u2502\u2500\u2500\u2500\u25b6\u2502  Layout  \u2502\u2500\u2500\u2500\u25b6\u2502 Console  \u2502\n \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n \u2502\n \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u251c\u2500\u2500\u25b6\u2502 Appender \u2502\u2500\u2500\u2500\u25b6\u2502  Filter  \u2502\u2500\u2500\u2500\u25b6\u2502  Layout  \u2502\u2500\u2500\u2500\u25b6\u2502   File   \u2502\n \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n \u2502\n \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2514\u2500\u2500\u25b6\u2502 Appender \u2502\u2500\u2500\u2500\u25b6\u2502  Filter  \u2502\u2500\u2500\u2500\u25b6\u2502  Layout  \u2502\u2500\u2500\u2500\u25b6\u2502  Socket  \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>When we output a log using Log4j, Log4j automatically outputs the same log to different destinations through different Appenders. For example:</p> <ul> <li>console: output to screen;</li> <li>file: output to file;</li> <li>socket: output to a remote computer over a network;</li> <li>jdbc: output to database</li> </ul> <p>In the process of outputting logs, Filter is used to filter which logs need to be output and which logs do not need to be output. For example, only <code>ERROR</code> level logs are output.</p> <p>Finally, the log information is formatted via Layout, e.g., by automatically adding information such as date, time, and method name.</p> <p>The above structure is complex, but we don't need to care about the Log4j API when we actually use it, but rather configure it through configuration files.</p> <p>Taking XML configuration as an example, when using Log4j, we put a <code>log4j2.xml</code> file under <code>classpath</code> to allow Log4j to read the configuration file and output logs according to our configuration. Here is an example of a configuration file:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Configuration&gt;\n    &lt;Properties&gt;\n        &lt;!-- \u5b9a\u4e49\u65e5\u5fd7\u683c\u5f0f --&gt;\n        &lt;Property name=\"log.pattern\"&gt;%d{MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36}%n%msg%n%n&lt;/Property&gt;\n        &lt;!-- \u5b9a\u4e49\u6587\u4ef6\u540d\u53d8\u91cf --&gt;\n        &lt;Property name=\"file.err.filename\"&gt;log/err.log&lt;/Property&gt;\n        &lt;Property name=\"file.err.pattern\"&gt;log/err.%i.log.gz&lt;/Property&gt;\n    &lt;/Properties&gt;\n    &lt;!-- \u5b9a\u4e49Appender\uff0c\u5373\u76ee\u7684\u5730 --&gt;\n    &lt;Appenders&gt;\n        &lt;!-- \u5b9a\u4e49\u8f93\u51fa\u5230\u5c4f\u5e55 --&gt;\n        &lt;Console name=\"console\" target=\"SYSTEM_OUT\"&gt;\n            &lt;!-- \u65e5\u5fd7\u683c\u5f0f\u5f15\u7528\u4e0a\u9762\u5b9a\u4e49\u7684log.pattern --&gt;\n            &lt;PatternLayout pattern=\"${log.pattern}\" /&gt;\n        &lt;/Console&gt;\n        &lt;!-- \u5b9a\u4e49\u8f93\u51fa\u5230\u6587\u4ef6,\u6587\u4ef6\u540d\u5f15\u7528\u4e0a\u9762\u5b9a\u4e49\u7684file.err.filename --&gt;\n        &lt;RollingFile name=\"err\" bufferedIO=\"true\" fileName=\"${file.err.filename}\" filePattern=\"${file.err.pattern}\"&gt;\n            &lt;PatternLayout pattern=\"${log.pattern}\" /&gt;\n            &lt;Policies&gt;\n                &lt;!-- \u6839\u636e\u6587\u4ef6\u5927\u5c0f\u81ea\u52a8\u5207\u5272\u65e5\u5fd7 --&gt;\n                &lt;SizeBasedTriggeringPolicy size=\"1 MB\" /&gt;\n            &lt;/Policies&gt;\n            &lt;!-- \u4fdd\u7559\u6700\u8fd110\u4efd --&gt;\n            &lt;DefaultRolloverStrategy max=\"10\" /&gt;\n        &lt;/RollingFile&gt;\n    &lt;/Appenders&gt;\n    &lt;Loggers&gt;\n        &lt;Root level=\"info\"&gt;\n            &lt;!-- \u5bf9info\u7ea7\u522b\u7684\u65e5\u5fd7\uff0c\u8f93\u51fa\u5230console --&gt;\n            &lt;AppenderRef ref=\"console\" level=\"info\" /&gt;\n            &lt;!-- \u5bf9error\u7ea7\u522b\u7684\u65e5\u5fd7\uff0c\u8f93\u51fa\u5230err\uff0c\u5373\u4e0a\u9762\u5b9a\u4e49\u7684RollingFile --&gt;\n            &lt;AppenderRef ref=\"err\" level=\"error\" /&gt;\n        &lt;/Root&gt;\n    &lt;/Loggers&gt;\n&lt;/Configuration&gt;\n</code></pre> <p>Although configuring Log4j is a bit tedious, once it is configured, it is very easy to use. For the above configuration file, all <code>INFO</code> level logs will be automatically output to the screen, while <code>ERROR</code> level logs will not only be output to the screen, but also to the file at the same time. And, once the log file reaches the specified size (1MB), Log4j will automatically cut the new log file and keep up to 10 copies.</p> <p>Having a configuration file is not enough, because Log4j is also a third-party library, we need to download Log4j from here, unzip it, and put the following 3 jar packages into the <code>classpath</code>:</p> <ul> <li>log4j-api-2.x.jar</li> <li>log4j-core-2.x.jar</li> <li>log4j-jcl-2.x.jar</li> </ul> <p>Since Commons Logging automatically discovers and uses Log4j, put the <code>commons-logging-1.2.jar</code> you downloaded in the previous section into the <code>classpath</code> as well.</p> <p>To print the logs, just write it the way Commons Logging writes it, without changing any code, to get Log4j log output, similarly:</p> <pre><code>03-03 12:09:45.880 [main] INFO com.itranswarp.learnjava.Main\nStart process...\n</code></pre>"},{"location":"40-exception/90-log4j/#best-practices","title":"Best practices","text":"<p>In the development phase, always use the Commons Logging interface to write logs, and there is no need to introduce Log4j in the development phase. if you need to write logs to a file, you just need to put the correct configuration file and Log4j-related jar packages into the <code>classpath</code>, and then you can automatically switch the logs to be written using Log4j, without modifying any code.</p>"},{"location":"40-exception/90-log4j/#exercise","title":"Exercise","text":"<p>Observe the log files written by Log4j according to the configuration file.</p> <p>Download exercise</p>"},{"location":"40-exception/90-log4j/#summary","title":"Summary","text":"<p>Logging is implemented through Commons Logging and no code changes are required to use Log4j;</p> <p>To use Log4j you just need to put log4j2.xml and related jar into the classpath;</p> <p>To replace Log4j, simply remove log4j2.xml and the associated jar;</p> <p>Only when you extend Log4j, you need to refer to the Log4j interface (for example, the function of writing logs encrypted to the database needs to be developed by yourself).</p>"}]}